{
    "potential code injection": {
        "title": "Potential Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.\n\n\nThe attacker can inject arbitrary data via the Action properties, which is later used by executing the action.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* If dynamic execution is necessary, run all dynamic code in an external\u00a0`Process`, and pass the external data as a parameter to the process using\u00a0`ProcessBuilder`.\n* Alternatively, it is possible to perform dynamic execution of code in an isolated sandbox running on a separate thread, by implementing a custom\u00a0`SecurityManager`\u00a0to implement a restrictive\u00a0`Policy`, and a custom\u00a0`ClassLoader`\u00a0to allow loading of only permitted classes, from pre-defined sandboxed locations. Note that this can never provide complete protection from sandbox exploits, and all dynamic execution should be avoided if possible."
    },
    "potential command injection": {
        "title": "Potential Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application passes unvalidated data, as a string, to the Operating System, to be executed as a system command. This command is run with the same system privileges as the application.\n\n\nIn particular, the attacker may be able to inject the malicious data into the application as user input, which is retrieved by the application via Struts Action properties or Session attributes.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege.\n* If absolutely necessary to call a system command or execute an external program with user input, use only the safe form of the\u00a0`ProcessBuilder`\u00a0class, using a hardcoded system command or executable as the first parameter.\n* Do not directly execute any shell or command interpreters, such as\u00a0`bash`,\u00a0`cmd`, or\u00a0`make`, with user-controlled input."
    },
    "potential connection string injection": {
        "title": "Potential Connection String Injection",
        "desc": "In order to communicate with the database, or with another external server (for example, Active Directory), the application dynamically constructs a connection string. This connection string includes untrusted data, which may be controlled by a malicious user. Since it is not constrained or properly sanitized, the untrusted data could be used to maliciously manipulate the connection string.",
        "impact": "If an attacker could manipulate the application\u2019s connection string to the database server, they might be able do any of the following:\n\n* Damage application performance (by increasing the MIN POOL SIZE)\n* Tamper with the network connection (for example, via TRUSTED CONNECTION)\n* Direct the application to the attacker\u2019s bogus database\n* Discover the password to the system account on the database (by a brute-force attack).",
        "mitigation": "* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Do not allow users to control the database connection string. Avoid dynamically building connection strings based on untrusted data, especially user input.\n* Store all connection strings in appropriate configuration mechanisms. If it is necessary to dynamically construct a connection string at runtime, do not include untrusted data directly in the connection string; instead, allow users to select from pre-defined connection strings."
    },
    "potential gwt reflected xss": {
        "title": "Potential GWT Reflected XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "potential i reflected xss all clients": {
        "title": "Potential I Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "potential io reflected xss all clients": {
        "title": "Potential IO Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "potential ldap injection": {
        "title": "Potential LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code."
    },
    "potential o reflected xss all clients": {
        "title": "Potential O Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "potential resource injection": {
        "title": "Potential Resource Injection",
        "desc": "The application allocates a resource based on user input, enabling an attacker to control it.",
        "impact": "The impact of resource injection is highly implementation dependent. By allowing attackers to control server-side resource I/O, such as network, storage or memory, an attacker may reroute these resources to expose them, generate multiple instances to exhaust the resource, or create a resource in a manner that would block other I/O operations.",
        "mitigation": "* Do not allow a user or untrusted data to define parameters of I/O, such as network sockets, storage access or other resource configurations."
    },
    "potential sql injection": {
        "title": "Potential SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nThe attacker may be able to exploit this vulnerability by tampering with the input fields sent to the Struts Action method or properties.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using an ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others."
    },
    "potential utf7 xss": {
        "title": "Potential UTF7 XSS",
        "desc": "Application code sets the response header for charset to UTF-7, indicating to older browsers to decode UTF-7 characters. These UTF-7 characters could be decoded into HTML meta-characters, resulting in XSS.",
        "impact": "UTF-7 encoding is a form of encoding for special characters using ASCII characters. However, the way with which UTF-7 represents certain HTML characters is using normal non-meta-characters, which could allow bypassing HTML encoding and performing an XSS attack on the web-page.\n\n\nFor example, consider the following UTF-7 string:\n+ADw-script+AD4- alert(123)+ADw-/script+AD4-\n\n\nThis string, under UTF-7 encoding, will indicate to the browser to decode it as `<script>alert(123)</script>` , which would result in an XSS on browsers that support it.",
        "mitigation": "Avoid using UTF-7 as a web-page character-set encoding."
    },
    "potential xpath injection": {
        "title": "Potential XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code.\n* Input sanitization, while not preferred, can be done safely when required with OWASP's\u00a0`ESAPI`\u00a0library, using\u00a0`Encoder.encodeForXPath()`. Additional libraries may also provide similar functionality.\n* Prefer parameterized XPath queries over data sanitization, to fully separate the input from the expression. Precompile the XPath query using\u00a0`XPath.compile()`, after defining the variable resolution mechanism using\u00a0`XPath.setXPathVariableResolver()`\u00a0and a custom\u00a0`XPathVariableResolver`\u00a0class. Afterwards the variables can be provided to the\u00a0`XPathVariableResolver`, and evaluated using the resulting\u00a0`XPathExpression.evaluate()`."
    },
    "escape false": {
        "title": "Escape False",
        "desc": "The application explicitly disables HTML escaping or encoding on an output field. If that output field processes tainted user input, it may leave that field potentially vulnerable cross-site scripting (XSS).",
        "impact": "Outputting potentially tainted values into HTML content without proper sanitization may allow attackers to inject Javascript content, resulting in Cross-Site Scripting (XSS). A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.",
        "mitigation": "* Where dynamic HTML is required, never create this HTML from user input\n\t+ If user-provided HTML is required, consider adding utilizing HTML markdown, so that user-provided HTML content is always generated from trusted HTML building-blocks\n* Fully encode all dynamic data, regardless of source, before embedding it in output; conversely, never disable automatic output encoding, as there are usually more secure alternatives to disabling security mechanisms\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the HTTPOnly flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "potential parameter tampering": {
        "title": "Potential Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "potential stored xss": {
        "title": "Potential Stored XSS",
        "desc": "The application creates web pages that include data from the application\u2019s database. The data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. This data may have originated in input from another user. If the data includes HTML fragments or Javascript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary database data without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use legitimate access to the application to submit engineered data to the application\u2019s database. When another user subsequently accesses this data, web pages may be rewritten and malicious scripts may be activated.",
        "mitigation": "1. Validate all dynamic data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in output. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML attribute encoding for data output to attribute values\n\t* Javascript encoding for server-generated Javascript.\n3. Consider using either the ESAPI encoding library, or its built-in functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n4. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n5. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "spring defaulthtmlescape not true": {
        "title": "Spring defaultHtmlEscape Not True",
        "desc": "A configuration in web.xml globally disables HtmlEscape for all fields, and requires explicitly enabling this attribute.",
        "impact": "Disabling HTML escaping in Spring in web.xml may leave the application vulnerable to Cross-Site Scripting, by allowing attackers to inject values into these fields that would reflect as HTML or Javascript content.",
        "mitigation": "* Never disable HtmlEscape\n\t+ If dynamic elements are required, construct them programmatically, rather than inserting raw HTML strings into web-pages"
    },
    "not using a random iv with cbc mode": {
        "title": "Not Using a Random IV with CBC Mode",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values (e.g. by creating a few individual sessions, and collecting the sessionids), it would be possible for an attacker to calculate another sessionid.\u00a0  \n\nSpecifically, if this pseudo-random value is used in any security context, such as passwords, keys, or secret identifiers, an attacker would be able to predict the next numbers generated, or previously generated values.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from guessing a value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values. This could enable the attacker to hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "Generic Guidance:\n\n* Whenever unpredicatable numbers are required in a security context, use a cryptographically strong random number generator, instead of a statistical pseudo-random generator.\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, to make brute-force attacks unfeasible.\n\n\nSpecific Recommendations:\n\n* Do not use the statistical pseudo-random number generator, use the cryptorandom generator instead. In Java, this is the SecureRandom class.\n* Use a random IV when encrypting CBC"
    },
    "stored command injection": {
        "title": "Stored Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application reads the command from the database, and passes it as a string to the Operating System. The attacker may be able to load the malicious payload into the database fields beforehand, causing the application to load that command.\u00a0This unvalidated data is then executed by the OS as a system command, running with the same system privileges as the application.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege.\n* If absolutely necessary to call a system command or execute an external program with untrusted data, use only the safe form of the\u00a0`ProcessBuilder`\u00a0class, using a hardcoded system command or executable as the first parameter.\n* Do not directly execute any shell or command interpreters, such as\u00a0`bash`,\u00a0`cmd`, or\u00a0`make`, with any untrusted data that can be potentially controlled by an attacker."
    },
    "stored relative path traversal": {
        "title": "Stored Relative Path Traversal",
        "desc": "The application relies on data from storage\u00a0to determine the file path for accessing files on the application server\u2019s local disk. If this data can be tainted by user input, an attacker may store their own value to perform path traversal via the vulnerable method.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "toctou": {
        "title": "TOCTOU",
        "desc": "Race Conditions occur when a public, single instance of a resource is used by multiple concurrent logical processes. If the these logical processes attempt to retrieve and update the resource without a timely management system, such as a lock, a Race Condition will occur.\n\n\nAn example for when a Race Condition occurs is a resource that may return a certain value to a process for further editing, and then updated by a second\u00a0process, resulting in the original process' data no longer being valid. Once the original process edits and updates the incorrect value back into the resource, the second process' update has been overwritten and lost.",
        "impact": "At best, a Race Condition may\u00a0cause errors in accuracy, overidden values or unexpected behavior that may result in denial-of-service. At worst, it may allow attackers to retrieve data or bypass security processes by replaying a controllable Race Condition until it plays out in their favor.",
        "mitigation": "When sharing resources between concurrent processes across the application ensure that these resources are\u00a0either thread-safe, or implement a locking mechanism to ensure expected concurrent activity."
    },
    "use of native language": {
        "title": "Use of Native Language",
        "desc": "Applications often use the JNI framework to call methods in native libraries, instead of implementing directly in Java. Native code does not have the various security protections offered to Java applications, and thus can be vulnerable to several classes of attacks that are not typically relevant for Java applications. This, in turn,\u00a0can make the application\u00a0itself vulnerable to several classes of attacks which would not otherwise apply.",
        "impact": "Libraries developed in native code do not enjoy many security mechanisms provided by the Java Virtual Machine (JVM) and Runtime Environment (JRE), such as strong typing, managed memory, and array bounds validation. Calling these native libraries can enable an attacker to bypass all these built-in security mechanisms, and exploit additional vulnerabilities in the native library, such as buffer overflows.\n\n\nThis could in turn allow the attacker to corrupt system memory, modify values, crash the application, or even execute arbitrary code.",
        "mitigation": "- Avoid using native libraries, if at all possible.\u00a0\n\u00a0- Rearchitect the application to enable required functionality to be developed using safer Java APIs, instead of native code.\u00a0\n\u00a0- Do not use JNI calls to an untrusted native library. Explicitly review the native code in depth for potential security flaws and incongruent developer expectations.\u00a0\n\u00a0- Perform data validation on all input before passing to a JNI function call, as appropriate to the specific parameter context; perform validation on any result returned by the function.\u00a0\n\u00a0- Implement error handling around the JNI call, to catch any exceptions that may be caused by the native code."
    },
    "client side redos": {
        "title": "Client Side ReDoS",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "client side injection": {
        "title": "Client Side Injection",
        "desc": "The app communicates with its local storage by calling methods on the storage classes, e.g.\u00a0`SqLiteDataBase.query()`, and passing selection variables to these methods. These classes internally create a\u00a0textual SQL query, including the parameters that were passed in.\u00a0Since these variables are based on untrusted input, and are\u00a0neither checked for data validity nor sanitized, the input could contain SQL commands that would be interpreted as such by the database.",
        "impact": "A remote attacker could access all of the app's data indirectly, by poisoning various methods of data input sent to the app (e.g. by sending an SMS or editing text fields). This could include\u00a0stealing any sensitive information stored by the app, such as personal user details or credit cards, and possibly even change or erase existing data.",
        "mitigation": "Generic Guidance\n\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In particular, all data validation should be performed after canonicalization, i.e. after the data has been decoded and simplified.\n* Do not concatenate untrusted input into the SQL query, instead only use parameterized queries and object bindings.\n\n\nSpecific Recommendations\n\n* Perform input sanitization after the decoding.\n* Do not send input (even indirectly) to injectable parameters, such as `whereClause` and `selection`; instead, use parameterized queries and submit the input to the database methods via the designated parameters, e.g. `whereArgs` and `selectionArgs`."
    },
    "failure to implement least privilege": {
        "title": "Failure To Implement Least Privilege",
        "desc": "The principle of least privilege dictates that for any service, code library or application - the privilege rights they receive never exceeds the bare minimum required for them to function as intended. A privilege is being requested by the application but is never actively used in code, implying granted privileges exceed required privileges.\n\n\nIn Android applications, permissions are specified in AndroidManifest.xml files, via the\u00a0`<uses-permission>`\u00a0tag.",
        "impact": "Privileges that are requested but never used provide an additional attack surface on both the privileged services and the application itself, without serving any purpose in application functionality.",
        "mitigation": "Review privileges requested by the application to ensure that they are all required for the application to function as intended. Remove any unnecessary privileges."
    },
    "insecure data storage": {
        "title": "Insecure Data Storage",
        "desc": "The application saves user provided data in a public storage mechanism, without any form of encryption.",
        "impact": "Data used plain-text without any encryption that is stored in public storage without any encryption may be retrieved by malicious applications, or tampered by other applications. The confidentiality and integrity of this data cannot be relied upon.",
        "mitigation": "* Always consider against storing data in a public file location; use explicit intents to transmit data across trusted applications instead\n* When storing data in a public storage container, consider encrypting it using a robust encryption algorithm, such as AES with GCM\n* Symmetric encryption is used to protect sensitive data you need to store securely. To prevent against a number of attacks, your implementation should follow these rules:\n\t+ The key must be securely derived from a secure source\n\t+ The initialization vector (or nonce) must be generated using a cryptographically-secure pseudo-random number generator\n\t+ To prevent tampering, the ciphertext should be authenticated (preferably by using authenticated encryption cipher modes)"
    },
    "insufficient sensitive transport layer": {
        "title": "Insufficient Sensitive Transport Layer",
        "desc": "The app handles various forms of sensitive data, and communicates with the remote application server. However,\u00a0the app connects using an \"`http://`\" URL, which will cause the underlying channel to use straight HTTP, without securing it with SSL/TLS.",
        "impact": "Sending data over the network is inherently risky, unless the communication channel is protected using a secured protocol. This is\u00a0especially true for mobile devices that are often connected to non-secure networks and\u00a0untrusted hotspots. An attacker can easily eavesdrop on the information\u00a0being sent over the air, and even manipulate the data in some scenarios.\n\n\nThus, an attacker could steal any personal or secret data sent over unencrypted HTTP, such as passwords, credit card details, social security numbers, and other forms of PII (Personally Identifiable Information), leading to identity theft and other forms of fraud. Additionally, it may be possible for an active attacker to alter the data and inject false or malicious data, causing further damage to the application server or the client app.",
        "mitigation": "Always use secure protocol by connecting to \"`https://`\" URLs. Never send sensitive data to an \"`http://`\" URL."
    },
    "insufficient transport layer protect": {
        "title": "Insufficient Transport Layer Protect",
        "desc": "The app handles various forms of sensitive data, and communicates with the remote application server. However,\u00a0the app connects using an \"`http://`\" URL, which will cause the underlying channel to use straight HTTP, without securing it with SSL/TLS.",
        "impact": "Sending data over the network is inherently risky, unless the communication channel is protected using a secured protocol. This is\u00a0especially true for mobile devices that are often connected to non-secure networks and\u00a0untrusted hotspots. An attacker can easily eavesdrop on the information\u00a0being sent over the air, and even manipulate the data in some scenarios.\n\n\nThus, an attacker could steal any personal or secret data sent over unencrypted HTTP, such as passwords, credit card details, social security numbers, and other forms of PII (Personally Identifiable Information), leading to identity theft and other forms of fraud. Additionally, it may be possible for an active attacker to alter the data and inject false or malicious data, causing further damage to the application server or the client app.",
        "mitigation": "Always use secure protocol by connecting to \"`https://`\" URLs. Never send sensitive data to an \"`http://`\" URL."
    },
    "poor authorization and authentication": {
        "title": "Poor Authorization and Authentication",
        "desc": "The mobile app collects device-specific identifiers, such as IMEI, and sends this to the app server. This is often used as a sole device identifier, serving as a proxy for user authentication.\n\n\nHowever, these details are not reliable, and can sometimes return bogus information. For example, mobile devices without a telephony component (e.g. tablet) would not have this type of identifier; some phones contain bugs wherein this data is not uniquely deterministic, and can return junk data or identical values for all devices of the same model. Additionally,\u00a0this hardware identifier might survive device resets, causing mis-identification if a user wipes his mobile device and passes it to another user.\u00a0\n\n\nMoreover, if the app server collects and correlates device-specific PII, e.g. IMEI, this will be considered a privacy violation.\u00a0\n\n\nFinally, reading this data will typically require elevated privileges for the mobile app, e.g. `READ_PHONE_STATE` on Android.",
        "impact": "If a device hardware identifier is being used to identify the mobile device, and by extension the users themselves, this could be abused or bypassed in various ways. In general, this is a weak form of authentication and can allow an attacker to impersonate another device, and\u00a0even lead to accidental cases of mistaken identity.\u00a0\n\n\nFurthermore, depending on the specific usage scenario, this could be considered a leak of personally identifiable information (PII) or other private data, such as IMEI of users' mobile devices.",
        "mitigation": "* Avoid collecting and tracking hardware-specific identifiers, or any other form of PII.\n* If appropriate, implement strong user-specific authentication instead of device authentication, for example user passwords.\n* If it is required to identify the device,\u00a0prefer app-specific (or installation-specific) identifiers over global device identifiers such as IMEI. In particular, use an app-generated UUID during installation."
    },
    "side channel data leakage": {
        "title": "Side Channel Data Leakage",
        "desc": "The application writes personal information, such as passwords or account information, to external media such as an SD card or to a log file, or, the application sends contacts or GPS location outside the device (over HTTP, email, or SMS). This can expose sensitive information.",
        "impact": "Sensitive information could be exposed, or malware could steal the information.",
        "mitigation": "1. Ideally, don\u2019t send contacts or GPS location out of the phone at all. If it is necessary to do so, send it over an encrypted channel such as HTTPS.\n2. Ideally, don\u2019t write sensitive data to log files or to external media. If it is necessary to do so, the data should be encrypted first."
    },
    "array declared public final and static": {
        "title": "Array Declared Public Final and Static",
        "desc": "The program declares an array as public, final, and static, which is not enough to prevent the array's contents from being modified.",
        "impact": "Because arrays are mutable objects, the `final` modifier enforces that the array itself is assigned only once, but makes no guarantees about the values of the array elements. Declaring the array as public, allows a malicious program can change the values stored in the array. As such, in most cases an array declared public, final and static may lead to unintended behaviour.",
        "mitigation": "Reduce the accessibility of the field or by changing the return type to an immutable type.\n\n\nUse appropriate collection type. By using a collection, the user control whether updates are allowed, since all updates go through methods. User can prevent updates by wrapping collections using `Collections.unmodifiableList()`. Even though the collection is immutable, the user must also be sure that the types stored in it are also immutable, or the risk of unsolicited changes on a supposed constant will reappear."
    },
    "dead code": {
        "title": "Dead Code",
        "desc": "Dead code can be caused by code after a return, private methods that are never invoked, catches associated to empty tries and unreachable switch cases.",
        "impact": "This can lead to quality degradation and difficulties in maintability of the source code.",
        "mitigation": "Remove dead code before deploying the application."
    },
    "use of obsolete functions": {
        "title": "Use of Obsolete Functions",
        "desc": "The application references code elements that have been declared as deprecated. This could include classes, functions, methods, properties, modules, or obsolete\u00a0library versions that are either out of date by version, or have been entirely deprecated. It is likely that the code that references the obsolete element was developed before it was declared as obsolete, and in the meantime the referenced code was updated.",
        "impact": "Referencing deprecated modules can cause an application to be exposed to known vulnerabilities, that have been publicly reported and already fixed. A common attack technique is to scan applications for these known vulnerabilities, and then exploit the application through these deprecated versions. However, even if deprecated code is used in a way that is completely secure, its very use and inclusion in the code base would encourage developers to re-use the deprecated element in the future, potentially leaving the application vulnerable to attack, which is why deprecated code should be eliminated from the code-base as a matter of practice.\n\n\nNote that the actual\u00a0risk involved depends on the specifics of any known vulnerabilities in older versions.",
        "mitigation": "* Always prefer to use the most updated versions of libraries, packages, and other dependancies.\n* Do not use or reference any class, method, function, property, or other element that has been declared deprecated."
    },
    "authorization bypass through user controlled sql primarykey": {
        "title": "Authorization Bypass Through User Controlled SQL PrimaryKey",
        "desc": "The application retrieves specific data records from the database, based on the value of the id provided by the user. However, the code does not enforce access control or other constraints on this value, and does not check that the requesting user has permission to access the specified record. This id value can be easily modified by the user, to some other arbitrary value that points to a record for which the user does not have permission.",
        "impact": "If the application allows the external user to control the data identifier, and by extension the specific data record, then a malicious user could easily access unauthorized records. This could include reading private data of other users, writing records they are not authorized for, or even deleting another user's information.",
        "mitigation": "* Always perform access checks before responding to requests, both on the type of requested operation, and the specific records requested. In particular, verify the user has permission to perform the operation on the requested id.\n* Avoid exposing the internal primary key to the external interface. Prefer implementing a surrogate pointer, e.g. \"this user's second account\". Always ensure the user has access to the set of referenced records."
    },
    "channel accessible by nonendpoint": {
        "title": "Channel Accessible by NonEndpoint",
        "desc": "The app handles various forms of sensitive data, and communicates with the remote application server using an unecrypted socket, which transports data in plain-text.",
        "impact": "Sending data over the network is inherently risky, unless the communication channel is protected using a secured protocol. An attacker could steal any personal or secret data sent over an unencrypted connection, or retrieve it from a cache that may store it. Additionally, it may be possible for an active attacker to alter the data and inject false or malicious data, causing further damage to the application server or the client app. Reading and/or manipulating data in transit is known as a \"Man-in-the-Middle\" attack.",
        "mitigation": "* When communicating with a remote server via HTTP, always use a TLS certificate\n* When communicating with a remote server via a socket, always opt for an encrypted socket that offers TLS\n* Always ensure the implementation of an encrypted socket being used properly validates TLS certificates\n\t+ Do not suppress any validation mechanism for TLS certificates"
    },
    "collapse of data into unsafe value": {
        "title": "Collapse of Data into Unsafe Value",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nBy replacing sub-strings in data during this flow, an attacker may provide data which intentionally contains these sub-strings. Once replaced by code, it could bypass defense mechanisms which filter out malicious characters or keywords (web-application firewalls, regular expressions and other server-side validation); this data would then be decoded after the checks verify data validity, evading defenses, and result in a Cross-Site Scripting (XSS) attack.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* If a replace operation is required, ensure it does not allow circumventing any additional security mechanisms, by crafting a string that intentionally contains a sub-string that would be replaced.\n\t+ Never use replace to sanitize inputs, as this is very likely a blacklist approach; whitelist allowed characters, instead. If absolutely required, implement a markdown to insert allowed words from a white-list."
    },
    "divide by zero": {
        "title": "Divide By Zero",
        "desc": "The program receives an unexpected value, and uses it for division without filtering, validation, or verifying that the value is not zero. The application\u00a0does not explicitly handle this error or prevent division by zero from occuring.",
        "impact": "When a program divides a number by zero, an exception will be raised. If this exception is not handled by the application, unexpected results may occur, including crashing the application. This can be considered a DoS (Denial of Service) attack, if an external user has control of the value of the denominator or can cause this error to occur.",
        "mitigation": "* Before dividing by an unknown value, validate the number and explicitly ensure it does not evaluate to zero.\n* Validate all untrusted input from all sources, in particular verifying that it is not zero before dividing with it.\n* Verify output of methods, calculations, dictionary lookups, and so on, and ensure it is not zero before dividing with the result.\n* Ensure divide-by-zero errors are caught and handled appropriately."
    },
    "exposure of system data": {
        "title": "Exposure of System Data",
        "desc": "System data is read and subsequently exposed where it might be read by untrusted entities.",
        "impact": "System data can provide attackers with valuable insights on systems and services they are targeting - any type of system data, from service version to operating system fingerprints, can assist\u00a0attackers to hone their attack, correlate data with known vulnerabilities or focus efforts\u00a0on developing new attacks against specific technologies.",
        "mitigation": "Consider the implications of exposure of the specified input,\u00a0and expected level of access to the specified output. If not required, consider removing this code, or modifying exposed information to exclude potentially sensitive system data."
    },
    "improper resource locking": {
        "title": "Improper Resource Locking",
        "desc": "Most modern environments, and web in particular, require a high level of concurrent actions, invoking many instances of an object, or a singleton object multiple times, using an internal scheduler that decides which thread should be operating at the moment. This scheduler is often out of a developer's control, and may halt and resume concurrent threads. These threads often operate over shared resources, which are part of a functionality that is being invoked simultaneously across multiple logic flows; for example - static member variables are shared across all instances of an object type, while in singleton objects (such as servlets) any member variable is shared across all calls to the singleton.\n\n\nWhen working in an environment with concurrency, failure to ensure all operations on a shared resource are done atomically and in a synchronized manner may result in threads or processes overriding each other's actions or outputs, often contradicting intended logic. For example, consider the \"Time of Check, Time of Use\" problem (TOCTOU) - if two threads attempt to increment the same counter, thread 1 reads the value n, and is then halted by the scheduler, thread 2 will read the value n, and then both threads will attempt to update the value to n+1, where logic would dictate that it would be n+2. Had this counter been properly synchronized, thread 2 would have to wait for thread 1 to complete its entire atomic operation of checking and updating its value.",
        "impact": "A\u00a0race condition can cause erratic or unexpected application behavior. Additionally, if a race condition\u00a0can be influenced directly by users, an attacker may choose to replay a race condition until they obtain a desired\u00a0result, allowing them to induce certain application behavior that is not part of its intentional design.",
        "mitigation": "* Consider allocating independent\u00a0resources\u00a0for concurrent logical processes, unless required.\n* Where resource sharing is required, utilize a locking mechanism when handling shared resources to ensure that actions are performed atomically by the current process, so that these logical processes\u00a0are not overridden or disrupted by any other concurrent process.\n* When dealing with static member variables - always consider that these are shared across all instances of an object\n* When dealing with singleton objects (such as servlets) being invoked by multiple concurrent logical processes - always synchronize either the entire singleton or its member variables; otherwise any thread processing the singleton's static methods may cause TOCTOU issues"
    },
    "information leak through comments": {
        "title": "Information Leak Through Comments",
        "desc": "Internal information may be considered sensitive - this may include library names, versions, usernames, passwords, internal hostnames, IPs, developer plans, intentions or missing functionality and more. This information should not be included in code comments that would be visible to attackers.\n\n\nWhen these comments are inserted by the server into web-content, they will be visible to anyone who views the web-page.",
        "impact": "Sensitive internal information that is leaked to attackers via any means, may be used to further understand their target, and craft more advanced and precise attacks.",
        "mitigation": "* Never store sensitive information in code comments.\n* When crafting client-side code, consider stripping away all comments.\n* Always document missing, broken or WIP functionality in a dedicated support system, rather than in the code itself."
    },
    "information exposure through debug log": {
        "title": "Information Exposure Through Debug Log",
        "desc": "The application logs sensitive user data retrieved from the user's session, such as the user's session identifier, and writes this directly to the logging mechanism.\n\n\nThis logging mechanism is the debug log, usually used for diagnostics or for tracking errors and exceptional situations.",
        "impact": "Exposing sensitive details about users or their activity could enable a privileged attacker to impersonate a user, or violate their privacy by tracking their actions in the application.",
        "mitigation": "* Do not write sensitive or private data to the standard logging mechanism, without properly sanitizing or encrypting first.\n* In some situations, it may be best to refrain from logging the session Id. Instead, consider logging a salted hash of the session Id instead, so as to enable session correlation without leaking sensitive user data."
    },
    "information exposure through server log": {
        "title": "Information Exposure Through Server Log",
        "desc": "The application logs sensitive user data retrieved from the user's session, such as the user's session identifier, and writes this directly to the logging mechanism.\n\n\nThis logging mechanism is used throughout the application to track user activity or history, and may be exposed or used during regular service requests.",
        "impact": "Exposing sensitive details about users or their activity could enable a privileged attacker to impersonate a user, or violate their privacy by tracking their actions in the application.",
        "mitigation": "* Do not write sensitive or private data to the standard logging mechanism, without properly sanitizing or encrypting first.\n* In some situations, it may be best to refrain from logging the session Id. Instead, consider logging a salted hash of the session Id instead, so as to enable session correlation without leaking sensitive user data."
    },
    "information leak through shell error message": {
        "title": "Information Leak Through Shell Error Message",
        "desc": "Console output, which is sometimes used for debugging or ad-hoc logging, is often mistaken for a safe output stream. However, it may also redirect its content unexpected output streams - for example, console output may write to the actual console, but simultaenously also log these outputs in a file. Additionally, the contents and history of a console can be read by other processes. As such, a console should be considered an exposed form of output, and should not have any sensitive data written to it.",
        "impact": "Sensitive data written out to console may leak to logs, errors messages and more.",
        "mitigation": "* Refrain from writing any sensitive data to the console, as the contents of a console may leak elsewhere."
    },
    "insufficient session expiration": {
        "title": "Insufficient Session Expiration",
        "desc": "An active session that does not properly expire will remain in the system for a prolonged amount of time, if not indefinitely, which could unneccessarily increase its exposure in the long run. This exposure could allow attackers the opportunity to obtain these session tokens, and impersonate authenticated users.",
        "impact": "Insufficient session expiration increases the exposure for attackers to execute session hijacking attacks, which will allow attackers to reuse a valid session and impersonate an authenticated user in the application.",
        "mitigation": "* Always set a reasonable idle session-timeout, depending on application's requirement\n* Make sure that all sessions timeout eventually. Refine and fine-tine session expiration to the minimal value for a session-timeout."
    },
    "integer overflow": {
        "title": "Integer Overflow",
        "desc": "All numeric data-types have a bit-wise representation. If, after an arithmetic operation, a value exceeds its bit-wise representation's amount of bits, then the most significant numbers that are being added will simply be truncated, with the value that remains after this truncation being the leftover from the wraparound action - this is known as an \"Arithmetic Overflow\", or its common misnomer - \"Integer Overflow\", which is misleading, since this applies to many other types. If data-types that can overflow drop below their minimum value, they will wraparound negatively in what is commonly referred to as an underflow.\n\n\nFor example, if an unsigned 32bit integer is set to\u00a04,294,967,295 and 1 is added, it will overflow and wraparound to 0. If it were a signed 32bit integer with the value\u00a02,147,483,647 and 1 is added, it will overflow and wraparound to -2,147,483,648.\n\n\nTo ensure code correctness, checks must be made that values are within expected bounds so that the result of arithmetic operations will not overflow or underflow.",
        "impact": "An arithmetic overflow will\u00a0lead to undefined behavior and unintentional effects, such as data corruption (e.g. value wraparound, wherein maximum values become minimum values); system crashes; infinite loops; logic errors, such as bypassing of security mechanisms; truncation or loss of data; or even buffer overflows leading to arbitrary code execution, when performing memory operations with an overflowed numeric value.",
        "mitigation": "* When performing arithmetic operations on data that may contain any value, consider adding a check to ensure that this data is within bounds where the product of those operations would not result in an overflow nor an underflow.\n* Consider creating wrappers for all arithmetic operations that would have specific handling for exceptional conditions; for example, by throwing an exception if checks show an overflow had or would have occurred."
    },
    "integer underflow": {
        "title": "Integer Underflow",
        "desc": "All numeric data-types have a bit-wise representation. If, after an arithmetic operation, a value exceeds its bit-wise representation's amount of bits, then the most significant numbers that are being added will simply be truncated, with the value that remains after this truncation being the leftover from the wraparound action - this is known as an \"Arithmetic Overflow\", or its common misnomer - \"Integer Overflow\", which is misleading, since this applies to many other types. If data-types that can overflow drop below their minimum value, they will wraparound negatively in what is commonly referred to as an underflow.\n\n\nFor example, if an unsigned 32bit integer is set to\u00a04,294,967,295 and 1 is added, it will overflow and wraparound to 0. If it were a signed 32bit integer with the value\u00a02,147,483,647 and 1 is added, it will overflow and wraparound to -2,147,483,648.\n\n\nTo ensure code correctness, checks must be made that values are within expected bounds so that the result of arithmetic operations will not overflow or underflow.",
        "impact": "An arithmetic overflow will\u00a0lead to undefined behavior and unintentional effects, such as data corruption (e.g. value wraparound, wherein maximum values become minimum values); system crashes; infinite loops; logic errors, such as bypassing of security mechanisms; truncation or loss of data; or even buffer overflows leading to arbitrary code execution, when performing memory operations with an overflowed numeric value.",
        "mitigation": "* When performing arithmetic operations on data that may contain any value, consider adding a check to ensure that this data is within bounds where the product of those operations would not result in an overflow nor an underflow.\n* Consider creating wrappers for all arithmetic operations that would have specific handling for exceptional conditions; for example, by throwing an exception if checks show an overflow had or would have occurred."
    },
    "logic time bomb": {
        "title": "Logic Time Bomb",
        "desc": "Some application functionality is pending a global timer, which may trigger malicious, untested or unexpected behavior. Once the time elapses, this functionality will execute.",
        "impact": "Time bombs may hide unexpected, untested or undesired functionality behind a timed operation; the impact of this functionality depends on its implementation.",
        "mitigation": "Review logic to ensure that this functionality is intended and thoroughly tested, as any other application code."
    },
    "missing password field masking": {
        "title": "Missing Password Field Masking",
        "desc": "A password field should always hide the password being typed to prevent any on-lookers or surveillance from observing the password on the device's screen. To that end, password masking, the process of converting passwords into blank characters (such as asterisks) is employed to provide users with feedback that a value is being typed, but without disclosing this value.",
        "impact": "Password fields that do not impose masking may leave the password visible to anyone looking at the user's screen.",
        "mitigation": "Always employ masking on sensitive data as it is being typed, to prevent it from leaking to any observers."
    },
    "object hijack": {
        "title": "Object Hijack",
        "desc": "Declaring an object that implements the Cloneable interface allows setting an explicit method of cloning a new object, while allowing developers to implement any additional logic or checks; this is particularly useful when a set of objects must adhere to certain constraints. For example, if a new object requires all of an existing object's properties, with the exception of a unique identifier, this type of logic can be implemented into the cloning method. However, this can be bypassed in code - if the cloneable object is inherited by a new object, the new type of object can trivially override clone(), overriding the parent class' clone() logic and cause completely unexpected behavior around this new object type.",
        "impact": "A cloned object can be created without using its constructor, but also without going through its clone method's logic. Objects created without logic or checks may result in unexpected behavior, bypass of logical checks and more, depending on implementation and object usage.",
        "mitigation": "When defining a Cloneable object, always set its clone() method implementation to \"final\" to prevent any implementations or extensions of this object from overriding clone() and replacing its logic."
    },
    "off by one error": {
        "title": "Off by One Error",
        "desc": "The iterator used to access a data set uses an incorrect arithmetic comparator, resulting in an incorrect iteration count and an off-by-one error.",
        "impact": "Off by one errors often lead to unexpected behavior, depending on implementation. The most common risk of Off-by-One errors are unhandled exceptions.",
        "mitigation": "When using arithmetic operators as a stop condition, always consider that the size of a data-set is always larger than the data-set itself by one, as a data-set's 0th element is also occupied. Therefore, the final cell of a data-set is often minus one its actual size."
    },
    "plaintext storage in a cookie": {
        "title": "Plaintext Storage in a Cookie",
        "desc": "The application sets a cookie with user-provided data.",
        "impact": "The application stores data in plain-text in a cookie. If this data is sensitive, setting it in plain-text as the contents of a cookie will increase its exposure significantly, by ensuring it is transmitted back-and-forth as part of every request made. If the cookie is then used by the application in additional contexts, it may allow further attack depending on implementation.",
        "mitigation": "* Do not rely on user-input to craft cookie content\n* Never store sensitive data in cookies"
    },
    "public static final references mutable object": {
        "title": "Public Static Final References Mutable Object",
        "desc": "While any final object cannot be reassigned, a mutable object cannot be truly final, as its attributes can still be altered. As such, the only way to prevent it from being altered by external packages is by setting its protection level to private.",
        "impact": "A mutable object, when declared with the \"public\" and \"final\" attributes, can still be altered by external packages, which would likely result in unexpected behavior.",
        "mitigation": "Never set mutable objects with \"public final\", unless they're explicitly intended to be changed by external packages."
    },
    "relative path traversal": {
        "title": "Relative Path Traversal",
        "desc": "The application uses user input in the file path for accessing files on the application server\u2019s local disk.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "reversible one way hash": {
        "title": "Reversible One Way Hash",
        "desc": "There are issues in cryptography-related functionality of the application.\n\n\nThe application is using a weak hashing primitive. MD4, MD5, SHA-1, etc. have been found to have collisions and other weaknesses that make them unsuitable for current deployments.",
        "impact": "Applications depend on cryptography in order to protect secrets and other sensitive or personally identifiable data. When there is a flaw in a cryptographic implementation, it may compromise the integrity, authenticity or confidentiality of the application's data.\n\n\nHashing functions are used for several purposes in cryptography, but mainly they are linked with key derivation functions and signatures. When hashing functions are used in an insecure manner, the integrity and confidentiality of the password hash or signature can be at stake.\n\n\nWhen applications rely on weak or broken hash functions to perform cryptographic operations to provide integrity or authentication features, attackers can leverage the known attacks against them to break signatures or passwords hashes. This could result in loss of confidentiality, integrity and authenticity of data.",
        "mitigation": "Update the hashing function to a safer alternative, like:\n\n* BLAKE2B (modern, fast in software, safe against length-extension attacks)\n* SHA-2 Family hashes (SHA-256,SHA-384,SHA-512)\n* SHA-3 Family hashes (SHA3-224, SHA3-256, SHA3-384, SHA3-512)"
    },
    "serializable class containing sensitive data": {
        "title": "Serializable Class Containing Sensitive Data",
        "desc": "Serialization is the process of converting an object in memory into a serialized form, such as bytestreams, XMLs, JSONs and more. It is intended for either transmission or storage, which would likely expose its contents at some point. It is discouraged to save any sensitive data into Serialized objects, as by their very definition it is implicit that they will, at some point, store or transmit this data in a recoverable and possibly readable format.",
        "impact": "Sensitive data may leak via a Serializable object.",
        "mitigation": "* Do not store sensitive data inside serialized objects\n* If absolutely required - do not store or transmit serialized objects containing sensitive data in a way that may jeopardize their contents. Always consider data-at-rest and data-in-transit principles when handling serialized objects containing sensitive data"
    },
    "creation of temp file in dir with incorrect permissions": {
        "title": "Creation of Temp File in Dir with Incorrect Permissions",
        "desc": "A file or directory is created with dangerous permissions, either by setting these permissions explicitly or relying on unsafe default permissions.",
        "impact": "Files with implicit or dangerous permissions may allow attackers to retrieve sensitive data from the contents of these files, tamper their contents or potentially execute them.",
        "mitigation": "* Always create files with permissions being set explicitly\n* Never set dangerous permissions on files\n\t+ Always consider the principle of least privilege when determining who may read, write or execute a file, if these permissions are to be granted at all"
    },
    "creation of temp file with insecure permissions": {
        "title": "Creation of Temp File With Insecure Permissions",
        "desc": "A file or directory is created with dangerous permissions, either by setting these permissions explicitly or relying on unsafe default permissions.",
        "impact": "Files with implicit or dangerous permissions may allow attackers to retrieve sensitive data from the contents of these files, tamper their contents or potentially execute them.",
        "mitigation": "* Always create files with permissions being set explicitly\n* Never set dangerous permissions on files\n\t+ Always consider the principle of least privilege when determining who may read, write or execute a file, if these permissions are to be granted at all"
    },
    "uncaught exception": {
        "title": "Uncaught Exception",
        "desc": "An exception may be thrown, but is never properly caught, causing it to percolate up the method call tree.",
        "impact": "An uncaught exception may cause unexpected behavior:\n\n* Breaking flow away from required operations, such as transaction commits, resource releases, data validation and more\n* Denial-of-Service if the unhandled exception crashes the application\n* Where systems, such as web frameworks, disclose exception stack traces, class names and other such information in errors, an uncaught exception may leak sensitive internal information regarding the structure of code, libraries used and software versions to an attacker",
        "mitigation": "* Always catch and handle exceptions\n* When handling exceptions, always handle each individual exception by its type to ensure each individual edge case is well handled, as well as to not lose granularity when logging exceptions for the purposes of troubleshooting"
    },
    "uncontrolled memory allocation": {
        "title": "Uncontrolled Memory Allocation",
        "desc": "The application declares and instantiates a large object, representing a data structure containing a collection of a given type of object. The size of the collection, and the number of elements contained in it, is initially set when constructing the object. However, the application sets the initial capacity based on external, untrusted user input, e.g. via the size of data or even as an explicit value.",
        "impact": "Allowing an untrusted user to control the amount of memory allocated in the application could allow an attacker to increase memory consumption arbitrarily, eventually causing out-of-memory errors in the application or possibly even crashing the server, causing a DoS (Denial of Service) attack.",
        "mitigation": "- Do not allow untrusted users to control memory allocation.\u00a0\n\u00a0- Avoid instantiating collection objects based on external user input, if possible.\u00a0\n\u00a0- If necessary, validate all input before instantiating a collection based on the value or size of data.\u00a0\n\u00a0- In particular, constrain the maximum size of the initial capacity of the collection to a sane default.\u00a0\n\u00a0- Ensure the application fails securely even in limited memory scenarios."
    },
    "unsynchronized access to shared data": {
        "title": "Unsynchronized Access To Shared Data",
        "desc": "Most modern environments, and web in particular, require a high level of concurrent actions, invoking many instances of an object, or a singleton object multiple times, using an internal scheduler that decides which thread should be operating at the moment. This scheduler is often out of a developer's control, and may halt and resume concurrent threads. These threads often operate over shared resources, which are part of a functionality that is being invoked simultaneously across multiple logic flows; for example - static member variables are shared across all instances of an object type, while in singleton objects (such as servlets) any member variable is shared across all calls to the singleton.\n\n\nWhen working in an environment with concurrency, failure to ensure all operations on a shared resource are done atomically and in a synchronized manner may result in threads or processes overriding each other's actions or outputs, often contradicting intended logic. For example, consider the \"Time of Check, Time of Use\" problem (TOCTOU) - if two threads attempt to increment the same counter, thread 1 reads the value n, and is then halted by the scheduler, thread 2 will read the value n, and then both threads will attempt to update the value to n+1, where logic would dictate that it would be n+2. Had this counter been properly synchronized, thread 2 would have to wait for thread 1 to complete its entire atomic operation of checking and updating its value.",
        "impact": "A\u00a0race condition can cause erratic or unexpected application behavior. Additionally, if a race condition\u00a0can be influenced directly by users, an attacker may choose to replay a race condition until they obtain a desired\u00a0result, allowing them to induce certain application behavior that is not part of its intentional design.",
        "mitigation": "* Consider allocating independent\u00a0resources\u00a0for concurrent logical processes, unless required.\n* Where resource sharing is required, utilize a locking mechanism when handling shared resources to ensure that actions are performed atomically by the current process, so that these logical processes\u00a0are not overridden or disrupted by any other concurrent process.\n* When dealing with static member variables - always consider that these are shared across all instances of an object\n* When dealing with singleton objects (such as servlets) being invoked by multiple concurrent logical processes - always synchronize either the entire singleton or its member variables; otherwise any thread processing the singleton's static methods may cause TOCTOU issues"
    },
    "use of client side authentication": {
        "title": "Use of Client Side Authentication",
        "desc": "Client-side code performs verification on credentials, indicating some checks are conducted on the client rather than server.",
        "impact": "Since all client-side code resides on the browser, any logic and checks it implements can be trivially bypassed by either modifying server-bound traffic using a web-proxy, or by tampering the code within the client.",
        "mitigation": "* Do not authenticate or validate user identity on the client\n* For every client-side check of server-bound data, always ensure and equivalent and identical check is conducted on the server, as traffic can be tampered with a basic web-proxy to bypass any and all client-side checks."
    },
    "using referer field for authentication": {
        "title": "Using Referer Field for Authentication",
        "desc": "An application that checks that value of a Referer header in order to validate that a request came from a trusted domain and an intended URL could be bypassed easily, since this header is part of the request, and can therefore be trivially manipulated using a web-proxy or a custom client. An attacker could spoof an expected or trusted value.",
        "impact": "A Referer header is part of an HTTP request; as such, it can be tampered to bypass any logic that relies on the authenticity of its contents.",
        "mitigation": "* Never use a Referer header as a defensive measure\n* Never use a Referer header as an authentication mecanism"
    },
    "absolute path traversal": {
        "title": "Absolute Path Traversal",
        "desc": "The application uses user input in the file path for accessing files on the application server\u2019s local disk.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "cleartext submission of sensitive information": {
        "title": "Cleartext Submission of Sensitive Information",
        "desc": "The application handles sensitive and private information\u00a0in several ways. At a certain point, this secret data is sent over the network, however the application does not use SSL/TLS, or any other secure protocol, and does not ensure the data is encrypted before sending it over the unprotected channel.",
        "impact": "Sensitive and personal details, such as passwords, social security numbers, credit card data, and other forms of PII (Personally Identifiable Information), must always be protected when being transmitted over the network. Sending this private data over the unencrypted network, without using SSL/TLS or other form of encryption, can reveal the users' secret information, and expose them\u00a0to risks of impersonation, identity theft, and financial fraud.\u00a0\n\n\nIf the SSL/TLS channel is terminated on a front-end webserver, reverse proxy, or the like, this issue can be ignored.",
        "mitigation": "Generic Guidance:\n\n* Always protect all PII and other sensitive data, especially when it is being sent over the network.\n* Use SSL/TLS whenever transmitting sensitive data. Alternatively, other encrypted protocols, such as IPsec or SSH, can also be used.\n* Reconsider if the application absolutely requires these personal details. Data that is not received cannot be exposed.\n\n\nSpecific Recommendations:\n\n* In web applications, do not output personal info directly to the response without verifying the channel is secured with SSL.\n* Do not write personal info directly to a standard socket either. Instead, always use SSLSocket to ensure your channel makes use of SSL/TLS."
    },
    "external control of critical state data": {
        "title": "External Control of Critical State Data",
        "desc": "The application receives unvalidated input from the user, and directly sets that value to the application configuration or environment settings, without properly sanitizing or constraining the input.",
        "impact": "If an external user can control the application configuration or environment settings, she can disrupt application service, or cause the application to behave unexpectedly, possibly creating\u00a0additional vulnerabilities in the application, or even causing the application to perform malicious actions.",
        "mitigation": "* Do not allow user\u00a0input,\u00a0or otherwise untrusted data, to control sensitive values, particularly configuration or environment settings.\n* Always validate data received from users, before using it for any internal use."
    },
    "multiple binds to the same port": {
        "title": "Multiple Binds to the Same Port",
        "desc": "A dynamically allocated interface on the same port is being created by application code.",
        "impact": "If two sockets are bound to the same port, this may lead to confusion and result in unexpected behavior. If this occurs because of user provided inputs, an attacker may bind an unexpected interface, hijacking the connection, the contents of the session created and any sensitive information broadcast during that session.",
        "mitigation": "Avoid using variable interface names when binding ports; use constants or configurations to bind the appropriate ports instead. Specifically - never rely on user inputs for the purpose of binding a port to avoid hijacking."
    },
    "plaintext storage of a password": {
        "title": "Plaintext Storage of a Password",
        "desc": "A password was stored in plaintext, outside of a secure container such as a password hashing algorithm or data encryption.",
        "impact": "Passwords that are stored in plaintext outside of a secure container would be trivial to read, if retrieved by an attacker. Leaked passwords could then be used to authenticate to other sensitive resources, to perform actions and retrieve additional information.",
        "mitigation": "Generic Guidance:\n\n* Always use strong, modern algorithms for encryption, hashing, and so on.\n* Do not use weak, outdated, or obsolete algorithms.\n* Ensure you select the correct cryptographic mechanism according to the specific requirements.\n* Passwords should be protected with a dedicated password protection scheme, such as bcrypt, scrypt, PBKDF2, or Argon2.\n\n\nSpecific Recommendations:\n\n* Do not use SHA-1, MD5, or any other weak hash algorithm to protect passwords or personal data. Instead, use a stronger hash such as SHA-256 when a secure hash is required.\n* Do not use DES, 3DES, RC2, or any other weak encryption algorithm to protect passwords or personal data. Instead, use a stronger encryption algorithm such as AES to protect personal data.\n* Do not use weak encryption modes such as ECB, or rely on insecure defaults. Explicitly specify a stronger encryption mode, such as GCM.\n* For symmetric encryption, use a key length of at least 256 bits."
    },
    "process control": {
        "title": "Process Control",
        "desc": "Process control vulnerabilities occur when a library is dynamically loaded from code, and either:\n\n* An attacker can replace the library being loaded, they will be able to introduce their own code into the application, potentially compromising it.\n* An attacker can affect which library is being loaded, potentially allowing them to load unsafe libraries",
        "impact": "If an attacker can directly affect which libraries are dynamically loaded, either by tampering with the invocation or by manipulating the library being dynamically loaded, they may introduce their own code, taking over the executing process and, potentially, the system it is running on.",
        "mitigation": "* Libraries that are loaded should come from a trusted source.\u00a0If the library does not come from a trusted source, review its\u00a0source code.\n* All native libraries should be validated to determine if the application requires the use of the library.\n* Run the application with the least-privilege principle in order to reduce the impact in case of a successful attack.\n* Sanitize all inputs which influence the library calls in order to avoid malicious content.\n* Use absolute path when calling the library in order to avoid calls to unwanted libraries.\n* When loading libraries that utilize native calls, validate all inputs to avoid buffer overflows.\n* If loading libraries dynamically is required, consider avoiding the use of System.loadLibrary - this method is ambiguous, and will attempt to load a library from any directory available in the Java path; an attacker may be able to exploit this ambiguity to inject their own file"
    },
    "reliance on cookies without validation": {
        "title": "Reliance on Cookies without Validation",
        "desc": "Cookie values are usually set by the server, via the Set-Cookie header, or via client-side code - thereby resulting in these values not being transparent to end-users. However, tampering with the values of these cookies is trivial, and therefore their contents should be treated as potentially malicious or tainted inputs.",
        "impact": "Cookie values are used in making a decision without validating their contents - this may allow users to tamper with these cookies thus affecting the outcome of this decision, despite not being authorized to do so. This may lead to authorization and authentication bypasses, whose exploitation may lead to\u00a0account theft,\u00a0elevation of privilege and more, depending on implementation.",
        "mitigation": "For any session-related\u00a0decisions, never rely on user inputs alone - always validate user authority and authenticity from trusted credentials, such as a session variable, before relying on cookie values in a decision."
    },
    "same seed in prng": {
        "title": "Same Seed in PRNG",
        "desc": "There are issues in cryptography-related functionality of the application. PRNG is a deterministic algorithm, that means that given the same initial seed, the generator will always produce the same output sequence.",
        "impact": "Applications depend on cryptography in order to protect secrets and other sensitive or personally identifiable data. When there is a flaw in a cryptographic implementation, it may compromise the integrity, authenticity or confidentiality of the application's data.\u00a0\n\n\nIf the application uses the same seed for encryption, i\n\n\nf the attacker could guess the seed, they may be able to determine the random numbers that will be produced from the PRNG and eventually decrypt sensitive data.",
        "mitigation": "* Refrain from using the same initial seed.\n* Always use a cryptographically secured PRNG algorithm."
    },
    "stored ldap injection": {
        "title": "Stored LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code."
    },
    "uncontrolled format string": {
        "title": "Uncontrolled Format String",
        "desc": "The application allows user input to influence the string argument used for formatted print functions. This family of functions expects the first argument to designate the relative format of dynamically constructed output string, including how to represent each of the other arguments.\n\n\nIf the provided format string is malformed, or if it references more arguments than were passed to the function, then an exception is thrown. If this exception is not caught by the application code, the entire process might crash. Alternatively, if the exception is caught by a generic exception handler further up the stack, then only the current method will be subverted, possibly bypassing other security checks, such as a logging mechanism.",
        "impact": "In certain languages, a mismatch between the amount of provided values or their types will result in an unhandled exception being thrown, which may result in unexpected behavior. If an attacker can control the format string, they may trigger such an event at will.",
        "mitigation": "Generic Guidance:\n\n* Do not allow user input or any other external data to influence the format strings.\n* Ensure that all string format functions are called with a static string as the format parameter, and that the correct number of arguments are passed to the function, according to the static format string.\n* Alternatively, validate all user input before using it in the format string parameter to print format functions, and ensure formatting tokens are not included in the input.\n\n\nSpecific Recommendations:\n\n* Do not include user input directly in the format string parameter (often the first or second argument) to formatting functions.\n* Alternatively, use controlled information derived from the input, such as size or length, in the format string - but not the actual contents of the input itself."
    },
    "use of cryptographically weak prng": {
        "title": "Use of Cryptographically Weak PRNG",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values, it would be possible for an attacker to calculate past or future values.  \n\nSpecifically, if this pseudo-random value is used in any security context, such as one-time passwords, keys, secret identifiers or salts - an attacker would likely be able to predict the next value generated and steal it, or guess a previously generated value and spoof its original intent.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from knowing or predicting a given value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values, based on sources often used to derive certain randomness; however, while they may seem random, large statistical samples would demonstrate that they are insufficiently random, producing a much smaller space of possible \"random\" values than a truly random sample would. This could enable an attacker to derive or guess this value, and thus hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "* Always use a cryptographically secure pseudo-random number generator, instead of basic random methods, particularly when dealing with a security context\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, thus making brute-force attacks unfeasible."
    },
    "use of insufficiently random values": {
        "title": "Use of Insufficiently Random Values",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values, it would be possible for an attacker to calculate past or future values.  \n\nSpecifically, if this pseudo-random value is used in any security context, such as one-time passwords, keys, secret identifiers or salts - an attacker would likely be able to predict the next value generated and steal it, or guess a previously generated value and spoof its original intent.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from knowing or predicting a given value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values, based on sources often used to derive certain randomness; however, while they may seem random, large statistical samples would demonstrate that they are insufficiently random, producing a much smaller space of possible \"random\" values than a truly random sample would. This could enable an attacker to derive or guess this value, and thus hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "* Always use a cryptographically secure pseudo-random number generator, instead of basic random methods, particularly when dealing with a security context\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, thus making brute-force attacks unfeasible."
    },
    "use of a one way hash with a predictable salt": {
        "title": "Use of a One Way Hash with a Predictable Salt",
        "desc": "Typical cryptographic hashes, such as SHA-1 and MD5, are incredibly fast. Combined with attack techniques such as precomputed Rainbow Tables, it is relatively easy for attackers to reverse the hashes, and discover the original passwords. Lack of a unique, random salt added to the password makes brute force attacks even simpler.",
        "impact": "If an attacker gains access to the hashed passwords, she would likely be able to reverse the hash due to this weakness, and retrieve the original password. Once the passwords are discovered, the attacker can impersonate the users, and take full advantage of their privileges and access their personal data. Furthermore, this would likely not be discovered, as the attacker is being identified solely by the victims' credentials.",
        "mitigation": "Generic Guidance:\n\u00a0- Always use strong, modern algorithms for encryption, hashing, and so on.\u00a0\n\u00a0- Do not use weak, outdated, or obsolete algorithms.\u00a0\n\u00a0-\u00a0Ensure you select the correct cryptographic mechanism according to the specific requirements.\u00a0\n\n\nSpecific Recommendations:\u00a0\n\u00a0- Passwords should be protected using a password hashing algorithm, instead of a general cryptographic hash. This includes adaptive hashes such as bcrypt, scrypt, PBKDF2 and Argon2.\u00a0\n\u00a0- Tune the work factor, or cost, of the adaptive hash function according to the designated environment and risk profile.\u00a0\n\u00a0- Do not use a regular cryptographic hash, such as SHA-1 or MD5,\u00a0to protect passwords, as these are too fast.\u00a0\n\u00a0- If it is necessary to use a common hash to protect passwords, add several bytes of unique, random data (\"salt\") to the password before hashing it. Store the salt with the hashed password, and do not reuse the same salt for multiple passwords."
    },
    "use of a one way hash without a salt": {
        "title": "Use of a One Way Hash without a Salt",
        "desc": "Typical cryptographic hashes, such as SHA-1 and MD5, are incredibly fast. Combined with attack techniques such as precomputed Rainbow Tables, it is relatively easy for attackers to reverse the hashes, and discover the original passwords. Lack of a unique, random salt added to the password makes brute force attacks even simpler.",
        "impact": "If an attacker gains access to the hashed passwords, she would likely be able to reverse the hash due to this weakness, and retrieve the original password. Once the passwords are discovered, the attacker can impersonate the users, and take full advantage of their privileges and access their personal data. Furthermore, this would likely not be discovered, as the attacker is being identified solely by the victims' credentials.",
        "mitigation": "Generic Guidance:\n\u00a0- Always use strong, modern algorithms for encryption, hashing, and so on.\u00a0\n\u00a0- Do not use weak, outdated, or obsolete algorithms.\u00a0\n\u00a0-\u00a0Ensure you select the correct cryptographic mechanism according to the specific requirements.\u00a0\n\n\nSpecific Recommendations:\u00a0\n\u00a0- Passwords should be protected using a password hashing algorithm, instead of a general cryptographic hash. This includes adaptive hashes such as bcrypt, scrypt, PBKDF2 and Argon2.\u00a0\n\u00a0- Tune the work factor, or cost, of the adaptive hash function according to the designated environment and risk profile.\u00a0\n\u00a0- Do not use a regular cryptographic hash, such as SHA-1 or MD5,\u00a0to protect passwords, as these are too fast.\u00a0\n\u00a0- If it is necessary to use a common hash to protect passwords, add several bytes of unique, random data (\"salt\") to the password before hashing it. Store the salt with the hashed password, and do not reuse the same salt for multiple passwords."
    },
    "stored code injection": {
        "title": "Stored Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* If dynamic execution is necessary, run all dynamic code in an external `Process`, and pass the untrusted data as a parameter to the process using `ProcessBuilder`.\n* Alternatively, it is possible to perform dynamic execution of code in an isolated sandbox running on a separate thread, by implementing a custom `SecurityManager` to implement a restrictive `Policy`, and a custom `ClassLoader` to allow loading of only permitted classes, from pre-defined sandboxed locations. Note that this can never provide complete protection from sandbox exploits, and all dynamic execution should be avoided if possible."
    },
    "stored http response splitting": {
        "title": "Stored HTTP Response Splitting",
        "desc": "Since user input is being used in an HTTP response header, an attacker could include NewLine characters to make the header look like multiple headers with engineered content, potentially making the response look like multiple responses (for example, by engineering duplicate content-length headers). This can cause an organizational proxy server to provide the second, engineered response to a victim\u2019s subsequent request; or, if the proxy server also performs response caching, the attacker can send an immediate subsequent request to another site, causing the proxy server to cache the engineered response as a response from this second site and to later serve the response to other users.\n\n\nMany modern web frameworks mitigate this issue, by offering sanitization for new line characters in strings inserted into headers by default. However, since many older versions of web frameworks fail to automatically mitigate this issue, manual sanitization of input may be required.",
        "impact": "If the header setting code is of a vulnerable version, an attacker could:\n\n* Arbitrarily change the application server\u2019s response header to a victim\u2019s HTTP request by manipulating headers\n* Arbitrarily change the application server\u2019s response body by injecting two consecutive line breaks, which may result in Cross-Site Scripting (XSS) attacks\n* Cause cache poisoning, potentially controlling any site\u2019s HTTP responses going through the same proxy as this application.",
        "mitigation": "1. Validate all input, regardless of source (including cookies). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Additionally, remove or URL-encode all special (non-alphanumeric) user input before including it in the response header.\n3. Make sure to use an up-to-date framework."
    },
    "stored open redirect": {
        "title": "Stored Open Redirect",
        "desc": "The application redirects the user\u2019s browser to a URL provided by a tainted input, without first ensuring that URL leads to a trusted destination, and without warning users that they are being redirected outside of the current site. An attacker could use social engineering to get a victim to click a link to the application with a parameter defining another site to which the application will redirect the user\u2019s browser. Since the user may not be aware of the redirection, they may be under the misconception that the website they are currently browsing can be trusted.",
        "impact": "An attacker could use social engineering to get a victim to click a link to the application, so that the user will be immediately redirected to another site of the attacker's choice. An attacker can then craft a destination website to fool the victim; for example - they may craft a phishing website with an identical looking UI as the previous website's login page, and with a similar looking URL, convincing the user to submit their access credentials in the attacker's website. Another example would be a phishing website with an identical UI as that of a popular payment service, convincing the user to submit their payment information.",
        "mitigation": "1. Ideally, do not allow arbitrary URLs for redirection. Instead, create a mapping from user-provided parameter values to legitimate URLs.\n2. If it is necessary to allow arbitrary URLs:\n\t* For URLs inside the application site, first filter and encode the user-provided parameter, and then either:\n\t\t+ Create a white-list of allowed URLs inside the application\n\t\t+ Use variables as a relative URL as an absolute one, by prefixing it with the application site domain - this will ensure all redirection will occur inside the domain\n\t* For URLs outside the application (if necessary), either:\n\t\t+ White-list redirection to allowed external domains by first filtering URLs with trusted prefixes. Prefixes must be tested up to the third slash [/] - `scheme://my.trusted.domain.com/,` to prevent evasion. For example, if the third slash [/] is not validated and scheme://my.trusted.domain.com is trusted, the URL scheme://my.trusted.domain.com.evildomain.com would be valid under this filter, but the domain actually being browsed is evildomain.com, not domain.com.\n\t\t+ For fully dynamic open redirection, use an intermediate disclaimer page to provide users with a clear warning that they are leaving the site."
    },
    "stored xpath injection": {
        "title": "Stored XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code.\n* Data sanitization, while not preferred, can be done safely when required with OWASP's\u00a0`ESAPI`\u00a0library, using\u00a0`Encoder.encodeForXPath()`. Additional libraries may also provide similar functionality.\n* Prefer parameterized XPath queries over data sanitization, to fully separate the data from the expression. Precompile the XPath query using\u00a0`XPath.compile()`, after defining the variable resolution mechanism using\u00a0`XPath.setXPathVariableResolver()`\u00a0and a custom\u00a0`XPathVariableResolver`\u00a0class. Afterwards the variables can be provided to the\u00a0`XPathVariableResolver`, and evaluated using the resulting\u00a0`XPathExpression.evaluate()`."
    },
    "stored absolute path traversal": {
        "title": "Stored Absolute Path Traversal",
        "desc": "The application relies on data from storage\u00a0to determine the file path for accessing files on the application server\u2019s local disk. If this data can be tainted by user input, an attacker may store their own value to perform path traversal via the vulnerable method.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "storing passwords in a recoverable format": {
        "title": "Storing Passwords in a Recoverable Format",
        "desc": "The application sets a cookie with user-provided data.",
        "impact": "The application stores data in plain-text in a cookie. If this data is sensitive, setting it in plain-text as the contents of a cookie will increase its exposure significantly, by ensuring it is transmitted back-and-forth as part of every request made. If the cookie is then used by the application in additional contexts, it may allow further attack depending on implementation.",
        "mitigation": "* Do not rely on user-input to craft cookie content\n* Never store sensitive data in cookies"
    },
    "unchecked return value to null pointer dereference": {
        "title": "Unchecked Return Value to NULL Pointer Dereference",
        "desc": "The application calls a function, but does not check the result of this function's return values. The application simply ignores the result value, using it or passing it on with ensuring it is correct and desired, first.",
        "impact": "A program that does not check function return values could cause the application to enter an undefined state. This could lead to unexpected behavior and unintended consequences, including inconsistent data, system crashes or other error-based exploits.",
        "mitigation": "* Always check the result of any called function that returns a value, and verify the result is an expected value.\n* Ensure the calling function responds to all possible return values.\n* Expect runtime errors and handle them gracefully. Explicitly define a mechanism for handling unexpected errors."
    },
    "direct use of unsafe jni": {
        "title": "Direct Use of Unsafe JNI",
        "desc": "Applications often use the JNI framework to call methods in native libraries, instead of implementing directly in Java. Native code does not have the various security protections offered to Java applications, and thus can be vulnerable to several classes of attacks that are not typically relevant for Java applications. This, in turn,\u00a0can make the application\u00a0itself vulnerable to several classes of attacks which would not otherwise apply.",
        "impact": "Libraries developed in native code do not enjoy many security mechanisms provided by the Java Virtual Machine (JVM) and Runtime Environment (JRE), such as strong typing, managed memory, and array bounds validation. Calling these native libraries can enable an attacker to bypass all these built-in security mechanisms, and exploit additional vulnerabilities in the native library, such as buffer overflows.\n\n\nThis could in turn allow the attacker to corrupt system memory, modify values, crash the application, or even execute arbitrary code.",
        "mitigation": "- Avoid using native libraries, if at all possible.\u00a0\n\u00a0- Rearchitect the application to enable required functionality to be developed using safer Java APIs, instead of native code.\u00a0\n\u00a0- Do not use JNI calls to an untrusted native library. Explicitly review the native code in depth for potential security flaws and incongruent developer expectations.\u00a0\n\u00a0- Perform data validation on all input before passing to a JNI function call, as appropriate to the specific parameter context; perform validation on any result returned by the function.\u00a0\n\u00a0- Implement error handling around the JNI call, to catch any exceptions that may be caused by the native code."
    },
    "unchecked input for loop condition": {
        "title": "Unchecked Input for Loop Condition",
        "desc": "The application performs some repetitive task in a loop, and defines the number of times to perform the loop according to user input. A very high value could cause the application to get stuck in the loop and to be unable to continue to other operations.",
        "impact": "An attacker could input a very high value, potentially causing a denial of service (DoS).",
        "mitigation": "Ideally, don\u2019t base a loop on user-provided data. If it is necessary to do so, the user input must be first validated and its range should be limited."
    },
    "struts duplicate form bean": {
        "title": "Struts Duplicate Form Bean",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple `<form-bean>` elements with the same name will cause the Struts framework to misbehave.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove the duplicate `<form-bean>` elements, and ensure that no further duplicate form settings are added."
    },
    "struts mapping to missing form bean": {
        "title": "Struts Mapping to Missing Form Bean",
        "desc": "An action element is defined with a name attribute; however, this name attribute is not associated with a corresponding form-bean element, indicating that this mapping is either missing or is no longer correct.",
        "impact": "Failure to map an action to a corresponding form may result in unhandled exceptions or unexpected application behavior.",
        "mitigation": "Ensure Struts actions are correctly mapped to their corresponding forms."
    },
    "esapi banned api": {
        "title": "ESAPI Banned API",
        "desc": "EASPI is a free ,open source and web application security control library that makes it easier for programmers to use more secured libraries.\n\n\nUse of banned calls is forbidden as it leave the application vulnerable and it is highly recommended to replace with a secured replacement from ESAPI.",
        "impact": "Use of deprecated and unsafe libraries may leave the program vulnerable to exploitation.",
        "mitigation": "When possible prefer to use ESAPI libraries instead of unsafe and deprecated libraries.\n\n\n\n\n| ID | Banned Call | ESAPI Replacement |\n| --- | --- | --- |\n| BAN001 | System.out.println() | Logger.* |\n| BAN002 | Throwable.printStackTrace() | Logger.* |\n| BAN003 | Runtime.exec() | Executor.safeExec() |\n| BAN004 | Session.getId() | Randomizer.getRandomString (better not to use at all) |\n| BAN005 | ServletRequest.getUserPrincipal() | Authenticator.getCurrentUser() |\n| BAN006 | ServletRequest.isUserInRole() | AccessController.isAuthorized*() |\n| BAN007 | Session.invalidate() | Authenticator.logout() |\n| BAN008 | Math.Random.* | Randomizer.* |\n| BAN009 | File.createTempFile() | Randomizer.getRandomFilename() |\n| BAN010 | ServletResponse.setContentType() | HTTPUtilities.setContentType() |\n| BAN011 | ServletResponse.sendRedirect() | HTTPUtilities.safeSendRedirect() |\n| BAN012 | RequestDispatcher.forward() | HTTPUtilities.safeSendForward() |\n| BAN013 | ServletResponse.addHeader() | HTTPUtilities.safeSetHeader()/safeSetHeader() |\n| BAN014 | ServletResponse.addCookie() | HTTPUtilities.safeAddCookie() |\n| BAN015 | ServletRequest.isSecure() | HTTPUtilties.isSecureChannel() |\n| BAN016 | Properties.* | EncryptedProperties.* |\n| BAN017 | ServletContext.log() | Logger.* |\n| BAN018 | java.security and javax.crypto | Encryptor.* |\n| BAN019 | java.net.URLEncoder/Decoder | Encoder.encodeForURL()/decodeForURL() |\n| BAN020 | java.sql.Statement.execute | PreparedStatement.execute |\n| BAN021 | ServletResponse.encodeURL | HTTPUtilities.safeEncodeURL() (better not to use at all) |\n| BAN022 | ServletResponse.encodeRedirectURL | HTTPUtilities.safeEncodeRedirectURL() (better not to use at all) |"
    },
    "esapi same password repeats twice": {
        "title": "ESAPI Same Password Repeats Twice",
        "desc": "ESAPI encourages developers, by design, to supply two distinct password fields to the user creation method, ensuring the user typed their password twice. Both password form fields should be retrieved from distinct variables and used in the createUser() method to ensure password correctness. Using the same password variable for both password fields completely bypasses this design.",
        "impact": "Passing only a single form field value will result with a redundant password field, that will also bypass the password confirmation mechanism.",
        "mitigation": "* When using interactive inputs, make sure to retrieve password and password confirmation to two separate variables and use them both in Authenticator.createUser()\n* When a password is generated locally, for example by Authenticator.generateStringPassword(), usage of this password within both method parameters is valid"
    },
    "reliance on cookies in a decision": {
        "title": "Reliance on Cookies in a Decision",
        "desc": "Cookie values are usually set by the server, via the Set-Cookie header, or via client-side code - thereby resulting in these values not being transparent to end-users. However, tampering with the values of these cookies is trivial, and therefore their contents should be treated as potentially malicious or tainted inputs.",
        "impact": "Cookie values are used in making a decision without validating their contents - this may allow users to tamper with these cookies thus affecting the outcome of this decision, despite not being authorized to do so. This may lead to authorization and authentication bypasses, whose exploitation may lead to\u00a0account theft,\u00a0elevation of privilege and more, depending on implementation.",
        "mitigation": "For any session-related\u00a0decisions, never rely on user inputs alone - always validate user authority and authenticity from trusted credentials, such as a session variable, before relying on cookie values in a decision."
    },
    "reliance on dns lookups in a decision": {
        "title": "Reliance on DNS Lookups in a Decision",
        "desc": "The application performs a reverse DNS resolution, based on the remote IP address, and performs a security check based on the returned hostname. However, it is relatively easy to spoof DNS names, or cause them to be misreported, depending on the context of the specific environment. If the remote server is controlled by the attacker, it can be configured to report a bogus hostname. Additionally, the attacker could also spoof the hostname if she controls the associated DNS server, or by attacking the legitimate DNS server, or by poisoning the server's DNS cache, or by modifying unprotected DNS traffic to the server. Regardless of the vector, a remote attacker can alter the detected network address, faking\u00a0the authentication details.",
        "impact": "Relying on reverse DNS records, without verifying domain ownership via cryptographic certificates or protocols, is not a sufficient authentication mechanism. Basing\u00a0any\u00a0security decisions on the registered hostname\u00a0could allow an external attacker to control the application flow. The attacker could possibly perform restricted operations, bypass access controls, and\u00a0even spoof the user's identity, inject a bogus hostname into the security log, and possibly other logic attacks.",
        "mitigation": "* Do not rely on DNS records, network addresses, or system hostnames as a form of authentication, or any other security-related decision.\n* Do not perform reverse DNS resolution over an unprotected protocol without record validation.\n* Implement a proper authentication mechanism, such as passwords, cryptographic certificates, or public key digital signatures.\n* Consider using proposed protocol\u00a0extensions to cryptographically protect DNS, e.g. DNSSEC (though note the limited support and other drawbacks)."
    },
    "use of rsa algorithm without oaep": {
        "title": "Use of RSA Algorithm without OAEP",
        "desc": "There are issues in cryptography-related functionality of the application.\n\n\nThe use of RSA with an insecure padding scheme allows attackers to perform an adaptive chosen-ciphertext attack on a decryption oracle. This means that a passive attacker that captured a victim's encrypted message, can then use an active attack to attempt to decipher the intercepted messages. By making slight adjustments to a valid message, the attacker can iteratively narrow down the possibility space for each message by sending these modified messages to the decryption oracle and listening for an \"Invalid padding\" error. The adaptive CCA method can efficiently decrypt messages with only tens of thousands of calls to the oracle.",
        "impact": "Applications depend on cryptography in order to protect secrets and other sensitive or personally identifiable data. When there is a flaw in a cryptographic implementation, it may compromise the integrity, authenticity or confidentiality of the application's data.\n\n\nThe application is using RSA encryption with an insecure padding scheme. Using a weak padding with RSA can allow attackers to decrypt captured ciphertexts. For exploitation to succeed, the application must leak that the ciphertext decryption failed due to invalid padding. This is also known as the Bleichenbacher attack.",
        "mitigation": "With RSA encryption, ensure that the padding scheme used is OAEP. While PKCSv1.5 may be default for several libraries, frameworks or languages, it is known to be weak and should not be used."
    },
    "session fixation": {
        "title": "Session Fixation",
        "desc": "The application authenticates users without terminating existing sessions. As a result, an attacker could get a victim to log in to the application during the attacker\u2019s session (for example, by getting the victim to click on a link including a session ID), and the application would authenticate the attacker\u2019s session as the victim\u2019s user account.",
        "impact": "An attacker could get a user to log in using the attacker\u2019s session. The attacker could then do anything that the other user has permissions for, such as accessing that user\u2019s confidential information and performing transaction in that user\u2019s name.",
        "mitigation": "The application should terminate any existing sessions upon user authentication and create a new session for that user."
    },
    "improper build of sql mapping": {
        "title": "Improper Build Of Sql Mapping",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* When inserting user provided values into Ibatis queries:\n\t+ Never use the ${} notation to encapsulate user-provided inputs, as that would inject the string into the raw query, similar to a concatenated string or a format string, which would lead to an SQL injection\n\t+ Use the #{} notation - this usage is equivalent to a parameterized query, ensuring data encapsulation within SQL syntax"
    },
    "dangerous file inclusion": {
        "title": "Dangerous File Inclusion",
        "desc": "The application uses untrusted data to specify the library or code file, without proper sanitization. This causes the application to load any arbitrary code, as specified. The loaded code will then be executed.\n\n\nThe reference to the target library is received via user input, allowing an external attacker to cause the application to even download and execute remote code files hosted on a remote server.",
        "impact": "If an attacker can select the name of the library, or the location of the code file that is loaded by the application, they would be able to cause the application to execute arbitrary code. This effectively allows the attacker to control the code run by the application.\n\n\nThis can include executing system commands, and possibly even enabling complete server takeover.\u00a0In particular, this vulnerability may even enable the attacker to retrieve and load a remote library completely under the control of the attacker.",
        "mitigation": "* Do not dynamically load code libraries, especially not based on user input.\n* If it is necessary to use untrusted data to select the library to be loaded,\u00a0verify the selected library name matches a predefined\u00a0set of whitelisted library names. Alternatively, use the value as an identifier to select from the whitelisted libraries.\n* Validate any untrusted data used to load or process libraries or code files by performing an integrity check on the requested resource.\n* In particular, never\u00a0load arbitrary code from a remote server.\n* Prefer loading local code files over remote code wherever possible, as a general rule.\n* Never include files using anonymously relative paths, instead using either an absolute path or root relative path."
    },
    "dynamic file inclusion": {
        "title": "Dynamic File Inclusion",
        "desc": "The application uses untrusted data to specify the library or code file, without proper sanitization. This causes the application to load any arbitrary code, as specified. The loaded code will then be executed.",
        "impact": "If an attacker can select the name of the library, or the location of the code file that is loaded by the application, they would be able to cause the application to execute arbitrary code. This effectively allows the attacker to control the code run by the application.",
        "mitigation": "* Do not dynamically load code libraries, especially not based on user input.\n* If it is necessary to use untrusted data to select the library to be loaded,\u00a0verify the selected library name matches a predefined\u00a0set of whitelisted library names. Alternatively, use the value as an identifier to select from the whitelisted libraries.\n* Validate any untrusted data used to load or process libraries or code files by performing an integrity check on the requested resource."
    },
    "struts2 action field without validator": {
        "title": "Struts2 Action Field Without Validator",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThis `Action` implementation class defines form fields that can be filled out and submitted by a user. However, some of these fields do not have automatic validation configured in the Validator configuration, `*-validation.xml`, and thus will not be automatically enforced by the framework.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.\n\n\nIt is possible that even a single unvalidated form field may be sufficient for an attacker to find an exploitable entry point to enable injection attacks.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Ensure that every field of every `Action` implementation class in the application will have a corresponding validation property in the Validator configuration, even when implementing custom validation logic in an overridden `validate()` method."
    },
    "struts2 duplicate action field validators": {
        "title": "Struts2 Duplicate Action Field Validators",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple `<field-validator>` elements, defined of the same validator type and applied to the same `<field>`, will cause the Validator framework to misbehave.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.\n\n\nIn the worst case, the Validator framework may use the wrong input validation settings, allowing an attacker to bypass protections against attacks.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove or merge the duplicate `<field-validator>` elements, and ensure that no further duplicate field validators are added."
    },
    "struts2 duplicate validators": {
        "title": "Struts2 Duplicate Validators",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple `<field>` elements defined with the same name will cause the Validator framework to misbehave.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.\n\n\nIn the worst case, the Validator framework may use the wrong input validation settings, allowing an attacker to bypass protections against attacks.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove or merge the duplicate `<field>` elements, and ensure that no further duplicate field validators are added."
    },
    "struts unused validation form": {
        "title": "Struts Unused Validation Form",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThe Struts Validator configuration, `validation.xml`, contains validation `<form>` elements that refer to `ValidatorForm` classes that no longer exist. This is likely due to changing requirements and code refactoring, however this indicates that the validation logic is not updated in step with the code.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.\n\n\nIf the validation configuration is out of date and includes ActionForm classes that no longer exist in the code, it is possible that additional new forms have been added to the code, yet are not validated automatically because the validation is not synchronized with the code logic.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Remove the unused Validation form information from validation.xml.\n* Always update the `Validator` configuration together with the code of the `ActionForm` classes."
    },
    "httponlycookies": {
        "title": "HttpOnlyCookies",
        "desc": "The web application framework, by default, does not set the \"httpOnly\" flag for the application's sessionid cookie and other sensitive application cookies. Likewise, the application does not explicitly use the \"httpOnly\" cookie flag, thus allowing client scripts to access the cookies by default.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, are typically accessible by client-side scripts, such as JavaScript. Unless the web application explicitly prevents this using the \"httpOnly\" cookie flag, these cookies could be read and accessed by malicious client scripts, such as Cross-Site Scripting (XSS). This flag would mitigate the damage done in case XSS vulnerabilities are discovered, according to Defense in Depth.",
        "mitigation": "- Always set the \"httpOnly\" flag for any sensitive server-side cookie.\n\u00a0- It is highly recommended to implement HTTP Strict Transport Security (HSTS) in order to ensure that the cookie will be sent over a secured channel.\n\u00a0- Explicitly set the \"httpOnly\" flag for each cookie set by the application.\n\u00a0- In particular, explicitly call the `Cookie.setHttpOnly()` method, on any cookie being added to the response.\u00a0\n\u00a0- Consider configuring the web application framework to automatically set httpOnly to all cookies, by\u00a0adding `<http-only>true</http-only>` under the `<cookie-config>` element, in your application's web.xml configuration file.\u00a0\n\u00a0- If the cookie is set to the response via the `.setHeader()` method with the `\"Set-Cookie\"` header name, append `\";httpOnly;\"` to the end of the cookie value."
    },
    "httponlycookies in config": {
        "title": "HttpOnlyCookies In Config",
        "desc": "The web application framework, by default, does not set the \"httpOnly\" flag for the application's sessionid cookie and other sensitive application cookies. Likewise, the application does not explicitly use the \"httpOnly\" cookie flag, thus allowing client scripts to access the cookies by default.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, are typically accessible by client-side scripts, such as JavaScript. Unless the web application explicitly prevents this using the \"httpOnly\" cookie flag, these cookies could be read and accessed by malicious client scripts, such as Cross-Site Scripting (XSS). This flag would mitigate the damage done in case XSS vulnerabilities are discovered, according to Defense in Depth.",
        "mitigation": "- Always set the \"httpOnly\" flag for any sensitive server-side cookie.\n\u00a0- It is highly recommended to implement HTTP Strict Transport Security (HSTS) in order to ensure that the cookie will be sent over a secured channel.\n\u00a0- Configure the application to always use \"httpOnly\" cookies in the site-wide configuration file.\n\u00a0- In your application's web.xml configuration file, add `<http-only>true</http-only>` under\u00a0the `<cookie-config>` element, in the `<session-config>` element."
    },
    "unvalidated forwards": {
        "title": "Unvalidated Forwards",
        "desc": "The application uses forwards to route requests between different parts of the site. In particular,\u00a0some pages use a request parameter to indicate which server method should be executed after the initial processing.\u00a0\n\n\nThe attacker could craft a URL that will pass the application\u2019s access control check, and then be forwarded by the application to sensitive\u00a0functionality for which the attacker is not authorized.",
        "impact": "Unvalidated\u00a0forwarding may allow an attacker to bypass access control mechanisms. By simply changing the name of the target method in the request, an attacker may be able to cause the application to execute a different method after\u00a0performing access checks based on the original value, thus performing some action to which the attacker is not authorized.",
        "mitigation": "Generic Guidance:\n\n* If possible, avoid using forwards at all.\n* If it is necessary to use forwarding, do not\u00a0base\u00a0the target destination on user input.\n* If user input is required to calculate the target, receive a destination code, instead of the method name itself, and map this code on the server to the actual URL.\n* If it is absolutely necessary to allow the user to provide an arbitrary method name (very rare), ensure that the provided\u00a0value is valid, and\u00a0that the user is authorized to invoke this method.\n\n\nSpecific Recommendations:\n\n* If possible, avoid using server side forwarding at all.\n* In any event,\u00a0do not forward server execution to a\u00a0target destination based on user input."
    },
    "android improper resource shutdown or release": {
        "title": "Android Improper Resource Shutdown or Release",
        "desc": "The application code allocates resource objects, but does not ensure these are always closed and released in a timely manner. This can include database connections, file handles, network sockets, or any other resource that needs to be released.\u00a0In some cases,\u00a0these might be released - but only if everything works as planned; if there is any runtime exception during the normal course of system operations, resources start to leak.\u00a0\n\n\nNote that even in managed-memory languages such as Java, these resources must be explicitly released. Many types of resource are not released even when the Garbage Collector runs; and even if the the object would eventually release the resource, we have no control over when the Garbage Collector does\u00a0run.",
        "impact": "Unreleased resources can cause a drain of those available for system use, eventually causing general reliability and availability problems, such as performance degradation, process bloat, and system instability. If a resource leak\u00a0can be intentionally exploited by an attacker, it may be possible to cause a widespread DoS (Denial of Service) attack. This might even expose sensitive information between unprivileged users, if the resource continues to retain\u00a0data or user id\u00a0between subsequent allocations.",
        "mitigation": "* Always close and release all resources.\n* Ensure resources are released (along with\u00a0any other necessary cleanup) in a `finally { }` block. Do not close resources in a `catch { }` block, since this is not ensured to be called.\n* Explicitly call .close() on any instance of a class that implements the `Closable` or `AutoClosable` interfaces.\n* Alternatively, an even better solution is to use the try-with-resources idiom, in order to automatically close any defined\u00a0`AutoClosable`\u00a0instances."
    },
    "stored boundary violation": {
        "title": "Stored Boundary Violation",
        "desc": "Server-side Session variables, or objects, are values assigned to a specific session, which is associated with a specific user. Often, they hold data relevant to that user's session, such as specific identifiers, user-type, authorization, authentication information and more. As such, the paradigm often associated to the Session object is that its contents can be trusted, as users cannot generally set these values themselves.\u00a0\n\n\nThe application places user input, which is untrusted data, in the server-side Session object, which is considered a trusted location. This could lead developers to treat untrusted data as trusted.",
        "impact": "Code that reads from Session variables may trust them as server-side variables, but they may have been tainted by user inputs. This can lead to tampering with parameters used to authenticate or authorize users. Further, tainted Session variables offer an additional attack surface against the application - if untrusted data taints a Session variable, and that Session variable\u00a0 is then used elsewhere without sanitization as if it were trusted, it could lead to further attacks such as Cross-Site Scripting, SQL Injection and more.",
        "mitigation": "1. Validate and sanitize all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Don\u2019t mix untrusted user input with trusted data."
    },
    "use of getenv": {
        "title": "Use Of getenv",
        "desc": "The application obtains environment variables and relies on their contents.",
        "impact": "Environment variables may not be set, causing unexpected behavior. The may also be set by other applications or users, which could provide an attack surface on the application.",
        "mitigation": "* Consider obtaining required information elsewhere, rather than trust that it was set as an environment variable. For example - system properties can provide system and user information, configuration files can provide a reasonable data store and allow read-only with the appropriate permissions and more\n* If use of environment variables is required, always validate environment variables are properly set, have valid contents, and sanitize these contents for any malicious values, by context they will be used in, as if they were untrusted user inputs"
    },
    "exposure of resource to other applications": {
        "title": "Exposure Of Resource To Other Applications",
        "desc": "The AndroidManifest.xml file indicates to the application it may expose resources by:\n\n\n\u00b7Explictly, by enabling resource exportation with the \"android:exported\" attribute.\n\n\n\u00b7Implictly, by not stating the \"android:targetSdkVersion\", which then defaults to \"1\", or setting the value to less than 17. The SDK exposes\u00a0Content Provider resources for SDK versions lower than 17.",
        "impact": "Resources exposed\u00a0by the application are vulnerable to exploitation and compromise of confidentiality by potentially malicious applications that co-inhabit the Android device.",
        "mitigation": "\u00b7Review AndroidManifest.xml and set\u00a0\"android:exported\" to \"false' for any resources that are not intended to be exposed to other applications. If required, consider changing approach to a more granular one, where specific permissions are explicitly set for specific resources as dictated by business requirements.\u00a0\n\n\n\u00b7 If\u00a0applicable, set the android:targetSdkVersion to values higher than 17 to prevent default exposure of content providers."
    },
    "improper verification of intent by broadcast receiver": {
        "title": "Improper Verification Of Intent By Broadcast Receiver",
        "desc": "Any applications may broadcast intents to a broadcast receiver. If this receiver does not verify the action it receives, it may potentially allow malicious applications to trigger the broadcast receiver's logic for an unintended action.",
        "impact": "Depending on implementation behind a broadcast receiver, a malicious app may broadcast an intent that would be received by the broadcast receiver, which would, without proper verification, execute an incorrect or potentially dangerous action.",
        "mitigation": "* Always validate the action of an intent"
    },
    "non encrypted data storage": {
        "title": "Non Encrypted Data Storage",
        "desc": "The application saves user provided data in a public storage mechanism, without any form of encryption.",
        "impact": "Data used plain-text without any encryption that is stored in public storage without any encryption may be retrieved by malicious applications, or tampered by other applications. The confidentiality and integrity of this data cannot be relied upon.",
        "mitigation": "* Always consider against storing data in a public file location; use explicit intents to transmit data across trusted applications instead\n* When storing data in a public storage container, consider encrypting it using a robust encryption algorithm, such as AES with GCM\n* Symmetric encryption is used to protect sensitive data you need to store securely. To prevent against a number of attacks, your implementation should follow these rules:\n\t+ The key must be securely derived from a secure source\n\t+ The initialization vector (or nonce) must be generated using a cryptographically-secure pseudo-random number generator\n\t+ To prevent tampering, the ciphertext should be authenticated (preferably by using authenticated encryption cipher modes)"
    },
    "passing non encrypted data between activities": {
        "title": "Passing Non Encrypted Data Between Activities",
        "desc": "Intents are used to pass data between activities. There are two types of intents - explicit intents and implicit intents. Unlike explicit intents, implicit intents do not set a specific component for the data to be sent, all they require for an application to have a specific permission, such as SEND\\_SMS, in order to be able to receive and handle the transported data. Therefore, a malicious application will be able to receive the data if it got the required permission.",
        "impact": "Passing data in plain-text is always a risk that one takes as it may lead to exposure of such data. Malicious applications could eavesdrop and obtain sensitive information while it is passing via intents.",
        "mitigation": "* If the data passed to a component within the same application, then usage of an explicit intent is required with the specific component name.\n* If an external component is required, that does not reside in the application, then usage of intent-filter is required, thus reducing the allowed components to respond to only certain kind on implicit intents.\n* Always make sure that sensitive information is encrypted before transporting it"
    },
    "use of implicit intent for sensitive communication": {
        "title": "Use Of Implicit Intent For Sensitive Communication",
        "desc": "An intent is a mechanism for sharing and invoking activities within an application, or across applications. An intent can be cast implicitly, affecting listeners currently waiting for the intent's action, which would allow the ecosystem to choose the appropriate consumer for the intent. However, if a malicious app is able to establish itself as the intent's consumer, and that intent contains sensitive information, that information would leak to the malicious app.",
        "impact": "A malicious application may hijack the implicit intent, compromising any sensitive information within it.",
        "mitigation": "* Consider the need to share sensitive information with other applications\n* Do not use implicit intents to share sensitive information with other applications - consider using more secure containers, such as ContentProviders"
    },
    "db control of system or config setting": {
        "title": "DB Control of System or Config Setting",
        "desc": "The application receives unvalidated input from the user, and directly sets that value to the application configuration or environment settings, without properly sanitizing or constraining the input.",
        "impact": "If an external user can control the application configuration or environment settings, she can disrupt application service, or cause the application to behave unexpectedly, possibly creating\u00a0additional vulnerabilities in the application, or even causing the application to perform malicious actions.",
        "mitigation": "* Do not allow user\u00a0input,\u00a0or otherwise untrusted data, to control sensitive values, particularly configuration or environment settings.\n* Always validate data received from users, before using it for any internal use."
    },
    "race condition": {
        "title": "Race Condition",
        "desc": "Most modern environments, and web in particular, require a high level of concurrent actions, invoking many instances of an object, or a singleton object multiple times, using an internal scheduler that decides which thread should be operating at the moment. This scheduler is often out of a developer's control, and may halt and resume concurrent threads. These threads often operate over shared resources, which are part of a functionality that is being invoked simultaneously across multiple logic flows; for example - static member variables are shared across all instances of an object type, while in singleton objects (such as servlets) any member variable is shared across all calls to the singleton.\n\n\nWhen working in an environment with concurrency, failure to ensure all operations on a shared resource are done atomically and in a synchronized manner may result in threads or processes overriding each other's actions or outputs, often contradicting intended logic. For example, consider the \"Time of Check, Time of Use\" problem (TOCTOU) - if two threads attempt to increment the same counter, thread 1 reads the value n, and is then halted by the scheduler, thread 2 will read the value n, and then both threads will attempt to update the value to n+1, where logic would dictate that it would be n+2. Had this counter been properly synchronized, thread 2 would have to wait for thread 1 to complete its entire atomic operation of checking and updating its value.",
        "impact": "A\u00a0race condition can cause erratic or unexpected application behavior. Additionally, if a race condition\u00a0can be influenced directly by users, an attacker may choose to replay a race condition until they obtain a desired\u00a0result, allowing them to induce certain application behavior that is not part of its intentional design.",
        "mitigation": "* Consider allocating independent\u00a0resources\u00a0for concurrent logical processes, unless required.\n* Where resource sharing is required, utilize a locking mechanism when handling shared resources to ensure that actions are performed atomically by the current process, so that these logical processes\u00a0are not overridden or disrupted by any other concurrent process.\n* When dealing with static member variables - always consider that these are shared across all instances of an object\n* When dealing with singleton objects (such as servlets) being invoked by multiple concurrent logical processes - always synchronize either the entire singleton or its member variables; otherwise any thread processing the singleton's static methods may cause TOCTOU issues"
    },
    "race condition format flaw": {
        "title": "Race Condition Format Flaw",
        "desc": "Race Conditions occur when a public, single instance of a resource is used by multiple concurrent logical processes. If the these logical processes attempt to retrieve and update the resource without a timely management system, such as a lock, a Race Condition will occur.\n\n\nAn example for when a Race Condition occurs is a resource that may return a certain value to a process for further editing, and then updated by a second\u00a0process, resulting in the original process' data no longer being valid. Once the original process edits and updates the incorrect value back into the resource, the second process' update has been overwritten and lost.",
        "impact": "At best, a Race Condition may\u00a0cause errors in accuracy, overidden values or unexpected behavior that may result in denial-of-service. At worst, it may allow attackers to retrieve data or bypass security processes by replaying a controllable Race Condition until it plays out in their favor.",
        "mitigation": "When sharing resources between concurrent processes across the application ensure that these resources are\u00a0either thread-safe, or implement a locking mechanism to ensure expected concurrent activity."
    },
    "json hijacking": {
        "title": "JSON Hijacking",
        "desc": "The following is required for the application to be vulnerable:\n\n* The application must be using cookie-based authentication\n* The application responds in an authenticated manner to simple GET request\n* This sensitive data is returned as a JSON, specifically in array form (enclosed in square [] brackets), and containing objects inside within the array\n\n\nBy returning a JSON array, an attacker may create a malicious website, which incorporates a `<script>` tag in their page in the following manner:\n\n\n`<script src=\"https://example.com/path/to/vulnerable/page\"></script>`\n\n\nThe browser will interpret the returned value as an object, causing it to temporarily exist in the malicious web-page's DOM; however since this object it is not assigned or referenced, it will be ephemeral, and would normally be immediately discarded. This is similar to any other declaration or return value without an assignment, and the malicious web-page would be unable to reference it in any way.\n\n\nTo actually exploit this issue in a vulnerable browser, an attacker would have to be able to override the prototype function for setters, which is normally restricted. If the browser is vulnerable and does allow overwriting certain core prototypes for setters in Javascript within the web-page context, they could craft a Javascript that, once a vulnerable page is included with the method, an object will initiate construction, trigger the overridden setter prototypes with the JSON object's contents as values, and an attacker would then be able to access these values in the context of their malicious web-page. From that point on - accessing them would be trivial.",
        "impact": "An attacker may craft a malicious web-page and, via social engineering, get a user to access it. If that user uses an outdated browser, and is logged in to the vulnerable application, the attacker may retrieve the contents of JSON objects, bypassing SOP and reading these objects' contents, and any sensitive information therein. Note that, while this issue generally applies to outdated, legacy and obsolete browsers, JSON hijacking issues also periodically arise in more modern browsers.",
        "mitigation": "There are multiple methods to address this issue:\n\n* Do not respond with JSON arrays as they are wrapped with square brackets, which immediately get evaluated as objects; if required, wrap the array with an external object (e.g. {\"array\":[]}) or add some sort of prefix to prevent this issue\n* If required, respond with JSON arrays only to POST request; ensure no sensitive information is ever returned as an array to a GET request\n* Prefix the JSON object with either JavaScript (`for(;;);`) or an unparseable JSON (`{};`) , and, before processing it on the client, strip this prefix; the latter will cause importation to fail, and the former will cause importation to hang forever - either way, this will prevent an attacker from importing a JSON object as a script"
    },
    "missing x frame options": {
        "title": "Missing X Frame Options",
        "desc": "Failure to utilize the \"X-FRAME-OPTIONS\" header will likely allow attackers to perform Clickjacking attacks. Properly utilizing the \"X-FRAME-OPTIONS\" header would indicate to the browser to disallow embedding the web-page within a frame, mitigating this risk, if the browser supports this header. All modern browsers support this header by default.",
        "impact": "Allowing setting of web-pages inside of a frame in an untrusted web-page will leave these web-pages vulnerable to Clickjacking, otherwise known as a redress attack. This may allow an attacker to redress a vulnerable web-page by setting it inside a frame within a malicious web-page. By crafting a convincing malicious web-page, the attacker can then use the overlayed redress to convince the user to click a certain area of the screen, unknowingly clicking inside the frame containing the vulnerable web-page, and thus performing actions within the user's context on the attacker's behalf.",
        "mitigation": "Utilize the \"X-FRAME-OPTIONS\" header flags according to business requirements to restrict browsers that support this header from allowing embedding web-pages in a frame:\n\n\n\u00b7 \"X-Frame-Options: DENY\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame, including the current web-site.\n\n\n\u00b7 \"X-Frame-Options: SAMEORIGIN\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame,\u00a0excluding the current web-site.\n\n\n\u00b7 \"X-Frame-Options: ALLOW-FROM https://example.com/\" will indicate to the browser to disallow embedding any web-page inside a frame,\u00a0excluding\u00a0the web-site listed after the ALLOW-FROM parameter."
    },
    "cookie overly broad path": {
        "title": "Cookie Overly Broad Path",
        "desc": "Cookie configurations allow setting an intended path for cookies, which refer to\u00a0which subdirectories within the application to whom a cookie should be served. Setting this path to \"/\" will allow any path within the application to read the contents of the cookie.",
        "impact": "Cookies often contain sensitive information, such as session tokens or CSRF tokens; failure to ensure their exposure is minimized to their intended scope of operations via a granular path may put its content at risk.",
        "mitigation": "Review cookie configurations to ensure a sensitive cookie is only ever submitted under its intended path, unless otherwise required."
    },
    "empty password in connection string": {
        "title": "Empty Password In Connection String",
        "desc": "The set password is empty, indicating that it is both hardcoded into the application, and can be easily guessed by anyone attempting to access the account\u00a0this password belongs to.",
        "impact": "For services that allow an empty password, an empty password would be the first guess an attacker would make. Failure to ensure robust authentication criteria can expose sensitive services, information and systems to compromise with minimal effort.",
        "mitigation": "* Disallow use of an empty password to any accounts for accessing systems, services or information, both by policy and by technical means available.\n* Do not hardcode any secret data in source code, especially not passwords.\n* In particular, user passwords should be stored in a database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2). Do not compare user passwords with a hardcoded value.\n* Sytem passwords should be stored in a configuration file or the database, and protected with strong encryption (e.g. AES-256). Encryption keys should be securely managed, and not hardcoded."
    },
    "improper restriction of xxe ref": {
        "title": "Improper Restriction of XXE Ref",
        "desc": "An attacker could upload an XML document that contains a DTD declaration, in particular an entity defintion that refers to a local file on the server's disk, e.g. `<!ENTITY xxe SYSTEM \"file:///c:/boot.ini\">`. The attacker would then include an XML entity reference that refers back to that entity definition, e.g. `<div>&xxe;</div>` . If the parsed XML document is then returned to the user, the result will include the contents of the sensitive system file.\u00a0\n\n\nThis is caused by the XML parser, which is configured to automatically parse DTD declarations and resolve entity references, instead of disabling both DTD and external references altogether.",
        "impact": "An\u00a0application that will parse and replace DTD entity references, in an XML document that the user controls, can allow an attacker to craft an XML document to read arbitrary server files. This XML document could contain an XML entity reference, which refers to an embedded DTD entity definition that points to any local file. This would enable the attacker to retrieve any arbitrary system file on the server.",
        "mitigation": "Generic Guidance:\n\n* Avoid processing user input directly, where possible.\n* If necessary to receive XML from the user, ensure the XML parser is restricted and constrained.\n* In particular, disable DTD parsing and resolving of entities. Apply a strict XML schema on the server, and validate the input XML accordingly.\n\n\nSpecific Recommendations:\n\n* Use safe XML parsers, and disable DTD parsing and entity resolving.\n* Do not enable DTD parsing or entity resolving."
    },
    "potential xxe injection": {
        "title": "Potential XXE Injection",
        "desc": "An attacker could upload an XML document that contains a DTD declaration, in particular an entity defintion that refers to a local file on the server's disk, e.g. `<!ENTITY xxe SYSTEM \"file:///c:/boot.ini\">`. The attacker would then include an XML entity reference that refers back to that entity definition, e.g. `<div>&xxe;</div>` . If the parsed XML document is then returned to the user, the result will include the contents of the sensitive system file.\u00a0\n\n\nThis is caused by the XML parser, which is configured to automatically parse DTD declarations and resolve entity references, instead of disabling both DTD and external references altogether.",
        "impact": "An\u00a0application that will parse and replace DTD entity references, in an XML document that the user controls, can allow an attacker to craft an XML document to read arbitrary server files. This XML document could contain an XML entity reference, which refers to an embedded DTD entity definition that points to any local file. This would enable the attacker to retrieve any arbitrary system file on the server.",
        "mitigation": "Generic Guidance:\n\n* Avoid processing user input directly, where possible.\n* If necessary to receive XML from the user, ensure the XML parser is restricted and constrained.\n* In particular, disable DTD parsing and resolving of entities. Apply a strict XML schema on the server, and validate the input XML accordingly.\n\n\nSpecific Recommendations:\n\n* Use safe XML parsers, and disable DTD parsing and entity resolving.\n* Do not enable DTD parsing or entity resolving."
    },
    "accessible content provider": {
        "title": "Accessible Content Provider",
        "desc": "A content provider is exported by the Android manifest file.",
        "impact": "An accessible content provider may expose the application to attack. If the content provider itself is vulnerable, exporting it will expose this vulnerability to external applications as an attack surface.",
        "mitigation": "* Review this content provider to ensure its exposure to external applications is required\n* If it is not, remove its exportation to reduce the application's attack surface\n* If the SDK version declared in the manifest file is lower than 17, update it to a later version"
    },
    "exported service without permissions": {
        "title": "Exported Service Without Permissions",
        "desc": "An Android\u00a0service or activity can be exported either explicitly, using the ``android:exported=\"true\"`` attribute, or implicitly by defining an intent filter for the service. An ``android:permission`` attribute must be explicitly declared for each exported service or activity, otherwise the service / activity are globally accessbile.",
        "impact": "An exported service, activity, or content provider can be directly accessed by any other application running on the Android device. If specific\u00a0access restrictions are not explicitly defined, any installed app can bypass the security sandbox and directly start or bind to this service, performing unauthorized actions or access disallowed user data.",
        "mitigation": "* Do not export services, activities, or content providers unless your application is specifically\u00a0intended to do so.\n* Do not define intent filters for your service or activity unless you allow it to be called via implicit intents.\n* If you are exporting a service, activity, etc, ensure you set a particular permission that clients must have in order to launch the service/activity, bind to it, or otherwise get it to respond to an intent."
    },
    "implicit intent with read write permissions": {
        "title": "Implicit Intent With Read Write Permissions",
        "desc": "Implicit intents don't define which component should respond to the action, any component that satisfies the required action will be able to respond. Explicit intents define a specific component to respond, a trusted component - However, using an implicit component will allow to untrusted components to respond, intercept sensitive information and tamper data.",
        "impact": "Using an implicit intent means that every service that could satisfy the required action would be eligible to respond, even unwanted applications.",
        "mitigation": "* Always use explicit intents over implicit intents when starting a service and do not declare intent filters, this way the intent will be explicit and the responding component would be an expected and trusted one."
    },
    "insecure webview usage": {
        "title": "Insecure WebView Usage",
        "desc": "A webview with Javascript enabled receives user input as a URL, potentially allowing malicious applications to manipulate the webview.",
        "impact": "A malicious application may be able to create a local public file, and force the application's webview to process it. With Javascript enabled, this may allow an attacker to access application resources and web scope, which could contain sensitive data, or be manipulated to fool users into providing sensitive data.",
        "mitigation": "* Avoid using inputs in webview URLs\n* If using inputs in a URL is a requirement, use a whitelist approach to ensure only specifically allowed URLs, domains, directories or files are allowed"
    },
    "weak encryption": {
        "title": "Weak Encryption",
        "desc": "The application uses a weak algorithm, that is considered obselete since it is relatively easy to break. These obselete algorithms are vulnerable to several different kinds of attacks, including brute force.",
        "impact": "Using weak or outdated cryptography does not provide sufficient protection for sensitive data. An attacker that gains access to the encrypted data would likely be able to break the encryption, using either cryptanalysis or brute force attacks. Thus, the attacker would be able to steal user passwords and other personal data. This could lead to user impersonation or identity theft.",
        "mitigation": "Generic Guidance:\n\n* Always use strong, modern algorithms for encryption, hashing, and so on.\n* Do not use weak, outdated, or obsolete algorithms.\n* Ensure you select the correct cryptographic mechanism according to the specific requirements.\n* Passwords should be protected with a dedicated password protection scheme, such as bcrypt, scrypt, PBKDF2, or Argon2.\n\n\nSpecific Recommendations:\n\n* Do not use SHA-1, MD5, or any other weak hash algorithm to protect passwords or personal data. Instead, use a stronger hash such as SHA-256\u00a0when a secure hash is required.\n* Do not use DES, 3DES, RC2, or any other weak\u00a0encryption algorithm\u00a0to protect passwords or personal data. Instead, use a stronger encryption algorithm\u00a0such as AES\u00a0to protect personal data.\n* Do not use weak encryption modes such as ECB, or rely on insecure defaults. Explicitly specify a stronger encryption mode, such as GCM.\n* For symmetric encryption, use\u00a0a key length\u00a0of\u00a0at least 256 bits."
    },
    "input path not canonicalized": {
        "title": "Input Path Not Canonicalized",
        "desc": "The application uses user input in the file path for accessing files on the application server\u2019s local disk.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "client state saving method jsf": {
        "title": "Client State Saving Method JSF",
        "desc": "ViewStates are used to maintain the current state of the user interface, whose values are associated to repopulate the view and give statefulness to the user interface. The ViewState itself is an encoded (and sometimes encrypted) serialized object, which is parsed by server code, which then performs a repopulation of the view. If saved on the server, users submit a token that associates their current state with the appropriate ViewState; however, if this ViewState is actually configured to be provided by clients, it would be vulnerable to tampering which, depending on the way its values are handled, may expose the server to various attacks, or could leak sensitive information to the client.",
        "impact": "ViewState values, variables and serialized objects are processed by the server. Depending on implementation and use of this ViewState, this may lead to validation bypasses, unauthorized activity, cross-site scripting attacks, sensitive information leaks or remote code execution.",
        "mitigation": "Set the value of \"javax.faces.STATE\\_SAVING\\_METHOD\" to \"server\", unless explicitly required.\n\n\nEnsure ViewState values and contents are treated as untrusted inputs to ensure poisoning of the ViewState cannot be used to attack the server or application users."
    },
    "heap inspection": {
        "title": "Heap Inspection",
        "desc": "String variables are immutable - in other words, once a string variable is assigned, its value cannot be changed or removed. Thus, these strings may remain\u00a0around in memory, possibly in multiple locations, for an indefinite period of time until the garbage collector happens to remove it. Sensitive data, such as passwords, will remain exposed in memory as plaintext with no control over their lifetime.\n\n\nWhile it may still be possible to retrieve data from memory, even if it uses a mutable container that is cleared, or retrieve a decryption key and decrypt sensitive data from memory - layering sensitive data with these types of protection would significantly increase the required effort to do so. By setting a high bar for retrieving sensitive data from memory, and reducing the amount and exposure of sensitive data in memory, an adversary is significantly less likely to succeed in obtaining valuable data.",
        "impact": "All variables stored by the application in unencrypted memory can potentially be retrieved by an unauthorized user, with privileged access to the\u00a0machine. For example, a privileged attacker could attach a debugger to the running process, or retrieve the process's memory from the swapfile or crash dump file.\u00a0Once the attacker\u00a0finds the user passwords in memory, these can be reused to easily impersonate the user to the system.",
        "mitigation": "When it comes to avoiding Heap Inspection, it is important to note that, given any read access to memory or a memory dump of an application, it is always likely to disclose some sensitive data to an adversary - these suggestions are part of defense-in-depth principles for protection of sensitive data in cases where such memory read access is successfully obtained. These recommendations will enable significant reduction in the lifespan and exposure of sensitive data in memory; however - given enough time, effort and unlimited access to memory, they will only go so far in protecting sensitive data being used by the application. The only way to handle Heap Inspection issues is to minimize and reduce data exposure, and obscure it in memory wherever possible.\n\n* Do not store sensitive data, such as passwords or encryption keys, in memory in plain-text, even for a short period of time.\n* Prefer to use specialized classes that store\u00a0encrypted data in memory to ensure it cannot be trivially retrieved from memory.\n* When required to use sensitive data in its raw form, temporarily store it in mutable data types, such as byte arrays, to reduce readability from memory, and then promptly zeroize the\u00a0memory locations, to reduce exposure duration of this data while in memory.\n* Ensure that memory dumps are not exchanged with untrusted parties, as even by ensuring all of the above - it may still be possible to reverse-engineer encrypted containers, or retrieve bytes of sensitive data from memory and rebuild it.\n* In Java, do not store passwords in immutable strings - prefer using an encrypted memory\u00a0object, such as SealedObject."
    },
    "inadequate encryption strength": {
        "title": "Inadequate Encryption Strength",
        "desc": "The application uses a weak algorithm, that is considered obselete since it is relatively easy to break. These obselete algorithms are vulnerable to several different kinds of attacks, including brute force.",
        "impact": "Using weak or outdated cryptography does not provide sufficient protection for sensitive data. An attacker that gains access to the encrypted data would likely be able to break the encryption, using either cryptanalysis or brute force attacks. Thus, the attacker would be able to steal user passwords and other personal data. This could lead to user impersonation or identity theft.",
        "mitigation": "Generic Guidance:\n\n* Always use strong, modern algorithms for encryption, hashing, and so on.\n* Do not use weak, outdated, or obsolete algorithms.\n* Ensure you select the correct cryptographic mechanism according to the specific requirements.\n* Passwords should be protected with a dedicated password protection scheme, such as bcrypt, scrypt, PBKDF2, or Argon2.\n\n\nSpecific Recommendations:\n\n* Do not use SHA-1, MD5, or any other weak hash algorithm to protect passwords or personal data. Instead, use a stronger hash such as SHA-256\u00a0when a secure hash is required.\n* Do not use DES, 3DES, RC2, or any other weak\u00a0encryption algorithm\u00a0to protect passwords or personal data. Instead, use a stronger encryption algorithm\u00a0such as AES\u00a0to protect personal data.\n* Do not use weak encryption modes such as ECB, or rely on insecure defaults. Explicitly specify a stronger encryption mode, such as GCM.\n* For symmetric encryption, use\u00a0a key length\u00a0of\u00a0at least 256 bits."
    },
    "public data assigned to private array": {
        "title": "Public Data Assigned to Private Array",
        "desc": "The caller of a setter method will still hold a reference to the mutable object that has been set. Once the object has been set by the setter, the calling method can still alter the reference it holds; this implies that, if the setter method has any sort of validation logic, a calling method can pass a reference that will be successfully validated and assigned to the private member, and then alter it to contain invalid values, bypassing validation altogether, bypassing the private member's protection level.",
        "impact": "Allowing an external entity to influence an object's internal private data member may have an impact on application's flow control, leak internal information and more.",
        "mitigation": "* Make sure to use an intermediate cloned object to copy the values from the source to the internal private data member"
    },
    "reliance on untrusted inputs in security decision": {
        "title": "Reliance On Untrusted Inputs In Security Decision",
        "desc": "Attackers can bypass the security decision to access whatever is being protected. The consequences will depend on the associated functionality, but they can range from granting additional privileges to untrusted users to bypassing important security checks. Ultimately, this weakness may lead to exposure or modification of sensitive data, system crash, or execution of arbitrary code.",
        "impact": "Whenever input is accepted from the user or the outside environment, it should be validated for type, length, format, and range before it is used. Until properly validated, the data is said to be tainted.\nWhen security decisions such as authentication and authorization are made based on the values of tainted data, attackers can bypass the security of the software. Without sufficient encryption, integrity checking, or other mechanism, any input that originates from an outsider cannot be trusted.",
        "mitigation": "Any input should be validated with encryption, integrity checking, or other mechanism such as checking type, length, format, and range before it is used."
    },
    "private array returned from a public method": {
        "title": "Private Array Returned From A Public Method",
        "desc": "Array type field is a mutable object, which means it is possible to overwrite it. Java returns a reference to the private array type field via the public method. Any modification done on the returned reference will affect the private field.",
        "impact": "Returning a private array type field via a public method allows modification to be done on that private field. Such modification could affect application's flow control, cause data leakage, allow overwriting of unintended variables etc.",
        "mitigation": "* Make sure to return a cloned object of a private array type field"
    },
    "incorrect permission assignment for critical resources": {
        "title": "Incorrect Permission Assignment For Critical Resources",
        "desc": "A file or directory is created with dangerous permissions, either by setting these permissions explicitly or relying on unsafe default permissions.",
        "impact": "Files with implicit or dangerous permissions may allow attackers to retrieve sensitive data from the contents of these files, tamper their contents or potentially execute them.",
        "mitigation": "* Always create files with permissions being set explicitly\n* Never set dangerous permissions on files\n\t+ Always consider the principle of least privilege when determining who may read, write or execute a file, if these permissions are to be granted at all"
    },
    "xquery injection": {
        "title": "XQuery Injection",
        "desc": "The application stores and manages data in XMLs, and processes it by submitting an XQuery, which is a query language for processing data in XML forms, to an XML processor engine. The application creates a dynamic query by using simple string concatenation, embedding untrusted data in the body of an XQuery. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain XQuery syntax.",
        "impact": "An attacker could directly access data available in XMLs within the system, or manipulate logic flow. The attacker would likely be able to steal any sensitive information stored by the system in XML files, including private user information, credit card details, proprietary business data, and any other secret data.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values"
    },
    "improper resource access authorization": {
        "title": "Improper Resource Access Authorization",
        "desc": "A logic flow in code triggers I/O and is not authorized. If an attacker can trigger it, it may leave it vulnerable to attack.",
        "impact": "Unauthorized actions may allow attackers to write malicious content or code to files, databases and other I\\Os or read sensitive I\\O contents. Impact of this issue varies, depending on implementation, but may allow:\n\n* Remote code execution, in case an attacker is able to inject malicious data into a writable I\\O, which would then be interpreted or compiled as code\n* Overwriting or leaking of configuration files\n* Compromising confidentiality or integrity of stored data",
        "mitigation": "When logic flows are affected by user input or behavior, always ensure the user is authorized to trigger them."
    },
    "unrestricted file upload": {
        "title": "Unrestricted File Upload",
        "desc": "Application code does not validate file size before saving files uploaded by users to storage, potentially allowing upload of files of any size.",
        "impact": "Allowing users to save files of unrestricted size may allow attackers to fill file storage with junk, or conduct long writing operations which would strain systems conducting the saving operation. Exhausting this storage space or constraining it to the point where it is unavailable will result in denial of service.",
        "mitigation": "Constrain intended file size in code to prevent attackers from uploading files of arbitrary sizes by performing size checks. Do not rely on client-side size checks or any size parameters provided by users; evaluate the size of the file on the server, instead."
    },
    "download of code without integrity check": {
        "title": "Download of Code Without Integrity Check",
        "desc": "Integrity signatures, as derived from any data set, can allow a recepient to identify that the received data set is the one they intended to obtain. For externally loaded code this is particularly important, as such code can be compromised via access to local storage, Man-in-the-Middle attacks and more.",
        "impact": "At best, code that fails an integrity check may be damaged, altered or may not match the intended code that it originally was, resulting in unexpected behavior. At worst, attackers who are able to compromise the loaded code, such as locally or via a Man-in-the-Middle attack, may alter the loaded code either at storage or in transit, which may result in malicious code execution and significant system compromise.",
        "mitigation": "Perform strict integrity checks to ensure code obtained from external sources\u00a0is verified, and has a known and trusted signature."
    },
    "suspected xss": {
        "title": "Suspected XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn attacker could use legitimate access to the application to submit modified data to the application\u2019s data-store. This would then be used to construct the returned web page, triggering the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "use of webview addjavascriptinterface": {
        "title": "Use of WebView AddJavascriptInterface",
        "desc": "The WebView component in Android prior to version 4.2.2 allows privilege escalation by allowing Javascript to invoke application code.\n\n\nAny Application that makes use of the vulnerable WebView component and has registered an interface could be vulnerable to malicious Javascript. The malicious Javascript is capable of accessing the functionality exposed by the interface.\n\n\nThis is especially dangerous in the Android version 4.1.2 since the default browser application has \u201caddJavascriptInterface\u201d registered, which enables injecting Java objects and thereby causing Remote Code Execution.",
        "impact": "Exposing application functionality in WebView may result in exposing this functionality to a remote attack, if an attacker can control the contents of the WebView, or leakage of internal application information, if the added application interface exposes such functionality.",
        "mitigation": "Make sure that only the intended resources are loaded into the WebView. If there are additional resources need to be loaded then it is advised to open a new Intent without a JavaScriptInterface."
    },
    "ssrf": {
        "title": "SSRF",
        "desc": "The application accepts a URL (or other data) from the user, and uses this to make a request to another remote server.\n\n\nHowever, the attacker can inject an arbitrary URL into the request, causing the application to connect to any server the attacker wants. Thus, the attacker can abuse the application to gain access to services that would not otherwise be accessable, and cause the request to ostensibly originate from the application server.",
        "impact": "An attacker can abuse this flaw to make arbitrary requests, originating from the application server. This can be exploited to\u00a0scan internal services; proxy attacks into a protected network; bypass network controls; download unauthorized files; access internal services and management interfaces; and possibly control the contents of requests and even steal server credentials.",
        "mitigation": "* Do not connect to arbitrary services based on user input.\n* If possible, the application should have the user's browser retrieve the desired information directly.\n* If it is necessary for the\u00a0application to proxy the request on the server, explicitly whitelist the allowed target URLs, and do not include any sensitive server information."
    },
    "stored log forging": {
        "title": "Stored Log Forging",
        "desc": "The application writes audit logs upon security-sensitive actions. Since the audit log includes user input that is neither checked for data type validity nor subsequently sanitized, the input could contain false information made to look like legitimate audit log data,",
        "impact": "An attacker could engineer audit logs of security-sensitive actions and lay a false audit trail, potentially implicating an innocent user or hiding an incident.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in logs.\n3. Use a secure logging mechanism."
    },
    "portability flaw locale dependent comparison": {
        "title": "Portability Flaw Locale Dependent Comparison",
        "desc": "Many classes and methods perform locale-sensitive operations, including formatting numbers, dates, and strings according to the specific language and region.\u00a0Many\u00a0of these methods\u00a0\n\n\nallow the caller to ignore the locale or character set, and apply formatting and language rules based on the default locale settings for the current environment.\u00a0\n\n\nHowever, depending on the default settings, this could result in unexpected results. As an example, using the Turkish locale to transform a string to uppercase will turn a lowercase \"i\" into\u00a0\"LATIN CAPITAL LETTER I WITH DOT ABOVE\" (Unicode codepoint 0130). Clearly, this is not the expected result, and a comparison with a proper uppercase \"I\" would fail.",
        "impact": "Performing string manipulations and comparisons without regard to the locale, can result in unexpected results. This can lead to bypass of input validation, format string attacks,\u00a0\n\n\nand possibly other string-based attacks such as Cross-Site Scripting (XSS), SQL Injection, and even Denial of Service (DoS).",
        "mitigation": "* Always use locale-sensitive functions for comparing and manipulating specific strings, that are intended to have a particular value.\n* In Java, prefer to use the `Locale.ROOT` locale as a neutral locale."
    },
    "improper restriction of stored xxe ref": {
        "title": "Improper Restriction of Stored XXE Ref",
        "desc": "An attacker could upload an XML document that contains a DTD declaration, in particular an entity defintion that refers to a local file on the server's disk, e.g. `<!ENTITY xxe SYSTEM \"file:///c:/boot.ini\">`. The attacker would then include an XML entity reference that refers back to that entity definition, e.g. `<div>&xxe;</div>` . If the parsed XML document is then returned to the user, the result will include the contents of the sensitive system file.\u00a0\n\n\nThis is caused by the XML parser, which is configured to automatically parse DTD declarations and resolve entity references, instead of disabling both DTD and external references altogether.",
        "impact": "An\u00a0application that will parse and replace DTD entity references, in an XML document that the user controls, can allow an attacker to craft an XML document to read arbitrary server files. This XML document could contain an XML entity reference, which refers to an embedded DTD entity definition that points to any local file. This would enable the attacker to retrieve any arbitrary system file on the server.",
        "mitigation": "Generic Guidance:\n\n* Avoid processing user input directly, where possible.\n* If necessary to receive XML from the user, ensure the XML parser is restricted and constrained.\n* In particular, disable DTD parsing and resolving of entities. Apply a strict XML schema on the server, and validate the input XML accordingly.\n\n\nSpecific Recommendations:\n\n* Use safe XML parsers, and disable DTD parsing and entity resolving.\n* Do not enable DTD parsing or entity resolving."
    },
    "password in comment": {
        "title": "Password In Comment",
        "desc": "A well-developed application will have it's source code well commented. Often, programmers\u00a0will\u00a0leave deployment information in comments, or\u00a0retain debugging data that was used during development. These comments often contain secret data, such as passwords. These password comments are stored in the source code in perpetuity, and are not protected.",
        "impact": "It is often possible to\u00a0retrieve and view the application source code.\u00a0For web applications, it is even simpler to \"`View Source`\" in the user's browser. Thus, a malicious user can steal these passwords, and use them to impersonate whoever they belong to. It is not known if these are valid, current passwords, nor if they are user passwords or for backend systems, like a database.",
        "mitigation": "Do not store secrets, such as passwords, in source code comments."
    },
    "frameable login page": {
        "title": "Frameable Login Page",
        "desc": "Failure to utilize the \"X-FRAME-OPTIONS\" header will likely allow attackers to perform Clickjacking attacks. Properly utilizing the \"X-FRAME-OPTIONS\" header would indicate to the browser to disallow embedding the web-page within a frame, mitigating this risk, if the browser supports this header. All modern browsers support this header by default.",
        "impact": "Allowing setting of web-pages inside of a frame in an untrusted web-page will leave these web-pages vulnerable to Clickjacking, otherwise known as a redress attack. This may allow an attacker to redress a vulnerable web-page by setting it inside a frame within a malicious web-page. By crafting a convincing malicious web-page, the attacker can then use the overlayed redress to convince the user to click a certain area of the screen, unknowingly clicking inside the frame containing the vulnerable web-page, and thus performing actions within the user's context on the attacker's behalf.",
        "mitigation": "Utilize the \"X-FRAME-OPTIONS\" header flags according to business requirements to restrict browsers that support this header from allowing embedding web-pages in a frame:\n\n\n\u00b7 \"X-Frame-Options: DENY\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame, including the current web-site.\n\n\n\u00b7 \"X-Frame-Options: SAMEORIGIN\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame,\u00a0excluding the current web-site.\n\n\n\u00b7 \"X-Frame-Options: ALLOW-FROM https://example.com/\" will indicate to the browser to disallow embedding any web-page inside a frame,\u00a0excluding\u00a0the web-site listed after the ALLOW-FROM parameter."
    },
    "deserialization of untrusted data": {
        "title": "Deserialization of Untrusted Data",
        "desc": "Object serialization and deserialization is integral to the process of remoting, wherein objects are passed between code instances over an intermediary medium, such as over a network. During deserialization, a new object is constructed from a serialized object provided over the medium; however, if the object being deserialized is untrusted, an unexpected and potentially dangerous object can be provided.",
        "impact": "Deserialization of untrusted data may allow attackers to craft and provide a malicious object to the deserializing code. If a dangerous object is unsecurely deserialized, it may result in execution of code or operating system commands, by invoking classes or methods potentially available to the object during the deserialization process.\n\n\nAdditionally, deserialization may bypass logical object validation. Since deserialization often uses its own means of constructing a new object from the serialized data, it may bypass checks enforced in constructors or setters, which would allow attackers to deserialize an object whose properties are not validated, incorrect or outright malicious. This may lead to unexpected behavior, affecting logic in ways that are entirely dependent on implementation.\n\n\nIn Java, deserialized classes may often borrow classes from the general namespace, allowing compound deserialized objects (\"Gadgets\") to deserialize and invoke dangerous built in types, such as java.lang.Runtime, which is capable of executing operating system commands.",
        "mitigation": "* Where possible, do not pass serialized object between remote instances. Instead, consider passing value primitives between instances and use these values to populate a newly constructed object.\n* If required, use a whitelist approach to passed objects. Always ensure the passed object is known, trusted and expected. Do not dynamically construct an object from any source unless the object has been verified and is of a trusted, known type, and may not contain untrusted objects within it.\n* When choosing a serializer - always consult vendor documentation, best practices and even known exploitation techniques to ensure that the serializer chosen and deployed is defensible, securely configured, and does not allow any potentially dangerous objects."
    },
    "webview cache information leak": {
        "title": "WebView Cache Information Leak",
        "desc": "Resources are stored in application's local cache diretory in order to improve performance\u00a0and experience for users.\n\n\nForm data such as user, password and email are also stored by default when using Webviews.",
        "impact": "Webview cache folder inside the application may retain sensitive information, which could leak if an attacker gains access to the local file system. This may include the contents of browsed web-sites, images, filled forms and more.",
        "mitigation": "* Always clear the cache if the application accesses any sensitive data\n* Server-side headers such as no-cache can be used to indicate that an application should not cache particular pages\n* Disable caching for specific fields with sensitive data via Webview settings"
    },
    "allowed backup": {
        "title": "Allowed Backup",
        "desc": "The `android:allowBackup` attribute is enabled, either by being set explicitly to true or by omission and default behavior.",
        "impact": "Backups may contain sensitive information; if an attacker can retrieve them, they may be able to extract this data from the content.",
        "mitigation": "Set `android:allowBackup=false`\u00a0in the AndroidManifest.XML file to disallow back-ups of this application from being made."
    },
    "hardcoded password in gradle": {
        "title": "Hardcoded Password In Gradle",
        "desc": "The application codebase\u00a0has string literal passwords embedded in the source code. This hardcoded value is used either to compare to user-provided credentials, or to authenticate downstream to a remote system (such as a database or a remote web service). \u00a0\n\n\nAn attacker only needs to gain access to the source code to reveal the hardcoded password. Likewise, the attacker can reverse engineer the compiled application binaries, and easily retrieve the embedded password. Once found, the attacker can easily use the password in impersonation attacks, either directly on the application or to the remote system.\u00a0\n\n\nFurthermore, once stolen, this password cannot be easily changed to prevent further misuse, unless a new version of the application is compiled. Moreover, if this application is distributed to numerous systems, stealing the password from one system automatically allows a class break in to all the deployed systems.",
        "impact": "Hardcoded passwords expose the application to password leakage. If an attacker gains access to the source code, she will be able to steal the embedded passwords, and use them to impersonate a valid user. This could include impersonating end users to the application, or impersonating the application to a remote system, such as a database or a remote web service.\u00a0\n\n\nOnce the attacker succeeds in impersonating the user or application, she will have full access to the system, and be able to do anything the impersonated identity could do.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not passwords.\n* Do not hardcode secret data, passwords and tokens in build.gradle\n* Use variables in build.gradle file linked to a local.properties file"
    },
    "proguard obfuscation not in use": {
        "title": "ProGuard Obfuscation Not In Use",
        "desc": "Obfuscating the code will\u00a0change the names and make not make them meaningful, therefore make much harder to read the source code and steal intelectual property (IP).",
        "impact": "All android applications are possible to reverse engineer, which will allow users to see the source code of the program.",
        "mitigation": "It is recommended to use ProGuard in order to obfuscate the source code:\n1. Make it harder to read the source code and IP.\n2. Shrinks the size of the application and increases average performance."
    },
    "keyboard cache information leak": {
        "title": "Keyboard Cache Information Leak",
        "desc": "The suggestion dictionary, often referred to as auto-complete, is built upon a preset dictionary as well as user inputs. This dictionary is available to applications on the device to provide users with ease-of-use for commonly typed words or phrases. However, failure to restrict sensitive\u00a0text fields will cause their contents to be joined into this dictionary as well, exposing them to potentially untrusted applications that co-inhabit the device.",
        "impact": "The suggestions dictionary, derived from user keyboard inputs, is globally accessible to other applications on the device. If sensitive information is cached within this dictionary, it can be stolen\u00a0by an untrusted application.",
        "mitigation": "Configure text field whose contents are sensitive to explicitly not be cached into the suggestions dictionary."
    },
    "no installer verification implemented": {
        "title": "No Installer Verification Implemented",
        "desc": "Lack of tampering detection will allow attackers to change the source code to do whatever they want, while no suspicions is arised from the developers.",
        "impact": "Tampering the source code may allow malicious users to re-write the source code and use steal users' data, credentials, credit card etc. without any suspicion.",
        "mitigation": "It is highly recommended to use tampering detection in order to prevent a release of a tampered application."
    },
    "unsafe permission check": {
        "title": "Unsafe Permission Check",
        "desc": "An insecure method of runtime permission check when accessing resources or URI in the context of inter-process communication (IPC) is called.\n\n\nThe checkCallingOrSelfPermission() and checkCallingOrSelfUriPermission() methods return PERMISSION\\_GRANTED if either the caller or the called application has the required permission. Improper use of these methods can lead to privilege escalation (confused deputy attack). Malicious applications can use the features of these methods and, in case of their misuse, access certain resources or the URI without the required permission, if the vulnerable application that provides an interface to its resources through IPC has the required permission.",
        "impact": "Malicious software could access certain resources or the URI without the required permission.",
        "mitigation": "For safe permission checks in the interprocess communication use checkCallingPermission() and checkCallingUriPermission() methods."
    },
    "copy paste buffer caching": {
        "title": "Copy Paste Buffer Caching",
        "desc": "The clipboard is a public domain that every application can access and read its content. Therefore, everything that is\u00a0copied to the clipboard in a way vulnurable and possible to be stolen by an attacker if a malicious application is installed on the device.",
        "impact": "Mobile users tend to copy and paste\u00a0usually due to space limitation on the mobile screen. If\u00a0a user copies sensitive information such as passowrds, credit cards etc. to the clipboard, then an attacker will be able to read it with a 3rd party application running on the device",
        "mitigation": "Text fields containing sensitive information should not be stored in clipboard.\n1. EditText field with inputType textPassword is considered to be a safe input.\u00a0\n2. Regular EditText fields -\u00a0The cursor handling should be disabled.\n3. Define\u00a0custom selection callbacks that prevents the action mode (Select All, Cut, Copy, Paste) from being started"
    },
    "missing device lock verification": {
        "title": "Missing Device Lock Verification",
        "desc": "The device does not implement any device lock verification checks.",
        "impact": "Given the option, many users would opt to not lock their device. If they choose not to lock the device, and the application does not enforce device locking, information stored in the application may be left vulnerable, if the device is physically accessed.",
        "mitigation": "Perform strict device lock checks at application startup to ensure users are forced to lock their devices."
    },
    "unvalidated self signed certificate": {
        "title": "Unvalidated Self Signed Certificate",
        "desc": "The custom class that implements the X509TrustManager or SSLSocketFactory interface can contain trivial methods. This can lead to a loss of confidentiality of the data transferred via SSL/TLS protocol.\n\n\nWithin the establishing of a protected connection (handshake) server sends its public key and certificate, which are a cryptographic proof that the public key belongs to the owner of the server, to the client. The authenticity of certificates is provided by a Certificate Authority.\n\n\nIf it is necessary for the application functioning to take the certificate that is not signed by a recognized certification authority (for example, a self-signed certificate), then developers create a class that implements the X509TrustManager or SSLSocketFactory interface. Often methods of this class are trivial (accepting all certificates), which makes the application vulnerable to man in the middle (MITM) attacks. By providing a valid self-signed certificate an attacker can violate the confidentiality of the connection and get an access to valuable data.\n\n\nEven if the methods of the redefined class are not trivial, their implementation is likely to contain mistakes leading to the same consequences.\n\n\nA possible attack scenario:\n1) The attacker enters the user's WLAN and redirects user's traffic through the attacker's server (for example, via DNS cache poisoning).\n2) The user initiates a connection to https://safeserver.example.com via an SSL/TLS protocol through the application.\n3) The attacker sends his/her own public key and a self-signed certificate generated by him/herself for the https://saveserver.example.com domain to the application.\n4) The application verifies that the received certificate matches the requested domain, ignoring the fact that the received certificate is self-signed.\n\n\nInsufficient use of means of information security at the transport level takes the third place in the \u201cOWASP Mobile Top 2014\u201d mobile platforms vulnerabilities ranking.",
        "impact": "Some applications use custom implementation of SSL interface. If custom implementation does not work properly, an attacker can violate the confidentiality of the connection and get an access to valuable data by providing a valid self-signed certificate.",
        "mitigation": "Make sure your X509TrustManager or SSLSocketFactory interface implementation trusts only those certificates which you want to be trusted.\n\n\nHow to avoid it\n1) Check the validity of the certificate each time when establishing a connection via a SSL/TLS protocol\n2) Use standard implementations of X509TrustManager.\n3) If accepting self-signed certificates is necessary, generate your own X509TrustManager implementation using KeyStore. Explicitly specify the certificates that should be taken and reject all others."
    },
    "unvalidated ssl certificate hostname": {
        "title": "Unvalidated SSL Certificate Hostname",
        "desc": "The verify method defined in a class that implements the HostnameVerifier interface always returns true. The application does not check the authenticity of the domain when establishing a secure connection.\n\n\nIn order to protect confidentiality and integrity of data transferred between a client and a server, the SSL / TLS protocol is used. As one of the first steps of the protocol handshake, the server sends to the client a public key and a certificate, which is a cryptographic proof that the public key belongs to the owner of the server. The authenticity of certificates is guaranteed by a Certification Authority.\n\n\nThe correspondence between the certificate and the public key transferred to the client within the handshake does not guarantee the security of the connection. The client must make sure that the public key and the certificate come from the intended domain. Such check is not provided at the protocol level. In its absence at the application level, the attacker can violate the connection confidentiality by redirecting the user traffic through the attacker's server and presenting a certificate that is valid for the attacker's domain (man-in-the-middle attack).\n\n\nTo check whether the requested domain matches the received certificate, Android applications must use a class implementing the HostnameVerifier interface. The developer can use one of the existing implementations of this interface (StrictHostnameVerifier, X509HostnameVerifier) or create their own. It is assumed that the verify method of the class that implements HostnameVerifier returns true if the connection to this host is allowed within the current connection and returns false otherwise. The verify method always returning true means that the application trusts all owners of all valid certificates, regardless of the domain for which they were obtained.\n\n\nA possible attack scenario:\n1. \u00a0\u00a0\u00a0\u00a0\u00a0The attacker enters the user's WLAN and redirects user's traffic through the attacker's server (for example, via a DNS cache poisoning attack).\n2. \u00a0\u00a0\u00a0\u00a0\u00a0The user initiates a connection to https://safeserver.example.com via an SSL / TLS protocol.\n3. \u00a0\u00a0\u00a0\u00a0\u00a0Instead of the https://safeserver.example.com public key an attacker sends the application their own public key and a valid certificate issued by a certification authority for the https://hackedserver.example.com domain.\n4. \u00a0\u00a0\u00a0\u00a0\u00a0The app makes sure that the resulting certificate is valid (for https://hackedserver.example.com), ignoring the fact that the certificate has been issued not for the domain, for which the connection was originally requested.\n5. \u00a0\u00a0\u00a0\u00a0\u00a0The attacker gets access to all traffic and can tamper with it.",
        "impact": "An attacker could intercept or tamper with all data transferred between the application and the server. Confidentiality of all transferred data might be lost.",
        "mitigation": "Check the authenticity of the certificate each time when establishing a connection via an SSL / TLS protocol.\n\n\n### **How to avoid it:**\n\n\n1. Do not use AllowAllHostnameVerifier.\n2. Use one of the standard classes that implement HostnameVerifier: BrowserCompatHostnameVerifier, StrictHostnameVerifier, X509HostnameVerifier."
    },
    "missing certificate pinning": {
        "title": "Missing Certificate Pinning",
        "desc": "When an application establishes an SSL connection, it automatically validates the correctness of the other side\u2019s certificate. This mechanism was created to prevent attackers from performing a man-in-the-middle attack, violating the confidentiality of the secure connection.\n\n\nThe validation is implemented via a so-called trust chain. A trust chain is a sequence of certificates, each one guaranteeing that the next one is trustworthy. Thus, if the application trusts the first certificate in the chain, it may well trust the last one (the leaf certificate), which is the very certificate whose correctness is being validated in the first place, i.e. the certificate of the other side of the SSL connection. The first certificate in the chain, called the root certificate, cannot be validated this way. To overcome this problem, most SSL implementations, including the one built into Android OS, store the certificates of several trusted central authorities (CAs) in a so-called trust store, and use them as root certificates for the trust chains.\n\n\nTo overcome this protection mechanism, an attacker could trick a user into adding attackers own certificate into the trust store. This could be achieved by using social engineering techniques. For instance, if the attacker provides the free Wi-Fi access via his/her router, he/she may suggest the user to permit the attacker\u2019s certificate installation. Most of the users are not familiar with information security threats, thus, they will give that permission. This will give the attacker access to the transmitted data.\n\n\nTo protect application data from this kind of attack, the application should use certificate pinning. In this case, the application will not trust all the certificates from the trust store, it will only trust the certificate specified by the developer. Effectively, the application implements its own trust store that cannot be modified. Thus, the data will not be compromised even if an attacker manages to install his/her certificate.",
        "impact": "If an attacker could trick the user into installing attacker\u2019s certificate, they would be able to violate the connection confidentiality with the application's server and allow man-in-the-middle attacks.",
        "mitigation": "Use certificate pinning whenever an SSL connection (e.g. an HTTPS request) is established.\n\n1. When making a request, make sure to verify that the certificate is pinned.\n2. If possible, pin to the root CA (central authority) certificate.\n3. Do not pin to the leaf certificate, because it\u2019s a subject to frequent changes.\n4. Pin to multiple certificates in order to have a backup plan in case something goes wrong with the main one (e.g. the private key is lost)."
    },
    "missing content security policy": {
        "title": "Missing Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are not explicitly defined, default browser behavior would allow\u00a0untrusted content.\n\n\nThe application creates web responses, but does not properly set a Content-Security-Policy header.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to\u00a0a strict\u00a0Content Security Policy, it is promptly rejected by the browser. Failure to define a policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Explicitly set the Content-Security-Policy headers for all applicable policy types (frame, script, form, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header\u00a0managed by\u00a0web-server configurations, or within `<meta>` tags in the HTML `<head>` section."
    },
    "reuse of cryptographic key": {
        "title": "Reuse Of Cryptographic Key",
        "desc": "The application uses a cryptographic key in multiple places, diminishing the cryptographic protection that can be provided by use of unique keys.",
        "impact": "A re-used cryptographic key may leave data vulnerable by making retrieving content of encrypted data easier, by only requiring attackers to gain or crack one cryptographic key to access multiple data sets.",
        "mitigation": "Always use unique cryptographic keys to ensure re-use of such a key does not diminish cryptographic defense on multiple cryptographic containers."
    },
    "insecure android sdk version": {
        "title": "Insecure Android SDK Version",
        "desc": "The Android SDK version has been identified as outdated.",
        "impact": "Support of vulnerable API versions enables running the application on an inherently vulnerable operating system, potentially exposing the application and its contents to attack.",
        "mitigation": "* Set minSdkVersion to 17 or above.\n* Periodically ensure that the Android minSdkVersion is not set below a known vulnerable version of the Android API; in this case, anything below 17 should not be allowed, in order to avoid potential API vulnerabilities."
    },
    "file permissions world readable": {
        "title": "File Permissions World Readable",
        "desc": "The world readable flag is being set on the file.",
        "impact": "The contents of world readable files can be accessed by anyone with file system access.",
        "mitigation": "Always set file permissions to the absolute lowest required. If possible, enforce granular access authorization to such files on a role or account basis."
    },
    "expression language injection ognl": {
        "title": "Expression Language Injection OGNL",
        "desc": "An expression language statement is evaluated from a string; this string contains potentially tainted user inputs, allowing attackers to inject their own expression language code into the evaluated string.\n\n\nIn Struts, OGNL can be invoked from OgnlContext objects, where a String is evaluated as an OGNL expression. However, OGNL expressions are also often invoked in contexts that are not explicit \"expression language\" execution methods, such as request.getAttribute(expression) and ValueStack.findValue(expression); the reasoning being that these are dictionaries which receive keys and return values, but in lieu of a valid key they are automatically evaluated as OGNL expressions for a key.",
        "impact": "An OGNL expression can call many libraries, including making static calls to Java Runtime, which would allow execution of arbitrary Java code and even OS commands.",
        "mitigation": "* Where possible, do not insert user inputs into expression language statements. If dynamic statements are required, consider a white-list of allowed statements, chosen by user inputs, that will be used as an expression language statement instead.\n* If required, construct an expression language statement that offers data encapsulation for user provided parameters, and sanitize user inputs to ensure they may not escape this data encapsulation, thus altering the expression language content of the statement itself.\n* Do not concatenate user inputs to OGNL expressions to avoid these strings from being evaluated as code\n* Do not supply dynamic user inputs as string arguments to dictionary methods that evaluate their inputs as OGNL expressions, such as request.getAttribute() and ValueStack.findValue()"
    },
    "confusing naming": {
        "title": "Confusing Naming",
        "desc": "The software does not follow certain coding rules for development, which can lead to resultant weaknesses or increase the severity of the associated vulnerabilities.",
        "impact": "Poor code quality leads to unpredictable behavior. From a user's perspective it often manifests itself as poor usability. For an attacker it provides an opportunity to stress the system in unexpected ways.",
        "mitigation": "Use naming conventions such as:\n\n* Underscore before the property name for variable/property/method `private` or `protected`;\n* Uppercase constants;\n* Capital first letter;\n* CamelCase vs under\\_score (there is no correct usage and both are acceptable);\n* Single Letter Prefixes - this is referred to as `Hungarian notation`. Example, in javascript the string type is declared with the \"s\" prefix."
    },
    "unchecked return value": {
        "title": "Unchecked Return Value",
        "desc": "The application calls a function, but does not check the result of this function's return values. The application simply ignores the result value, using it or passing it on with ensuring it is correct and desired, first.",
        "impact": "A program that does not check function return values could cause the application to enter an undefined state. This could lead to unexpected behavior and unintended consequences, including inconsistent data, system crashes or other error-based exploits.",
        "mitigation": "* Always check the result of any called function that returns a value, and verify the result is an expected value.\n* Ensure the calling function responds to all possible return values.\n* Expect runtime errors and handle them gracefully. Explicitly define a mechanism for handling unexpected errors."
    },
    "leftover debug code": {
        "title": "Leftover Debug Code",
        "desc": "During application development, it is common for programmers to implement specialized code, in order to ease debugging and testing. Often the programmer will even\u00a0enable the debug code to bypass security mechanisms, so as to focus the tests on the specific functionality and isolate it from the security architecture.\u00a0\n\n\nThis debug or test code is not removed from the codebase, and is then included in the software build and deployed to the production environment.",
        "impact": "Tests and debugging code are not intended to be deployed to the production environment, and can create unintended entry points, thus increasing the application's attack surface. Furthermore, this code is often not properly tested or maintained, and can retain historic vulnerabilities that were fixed in other parts of the codebase. Often, debug code will contain a functional \"back door\", by enabling the programmer to bypass operational security mechanisms, such as authentication or access controls.",
        "mitigation": "- Remove all debug code before deploying or building the application. Ensure the configuration settings are not defined to enable debug mode.\u00a0\n\u00a0- Implement all test code via a dedicated test framework, which can isolate the test case code from the rest of the application.\u00a0\n\u00a0- Avoid implementing special \"test code\", \"debugging-time\" functionality, or \"secret\" interfaces or parameters in the application code itself.\u00a0\n\u00a0- Define and implement a standard and automatic build / deployment process, using dedicated CI / CD tools, that can automatically configure the deployed application, exclude all temporary code, and include only intended application code."
    },
    "incorrect block delimitation": {
        "title": "Incorrect Block Delimitation",
        "desc": "The programmer indented a statement's block composed by more than one instruction, but, since there were no braces, only the first instruction was influenced by that statement.",
        "impact": "Since in some languages braces are optional for blocks, the code may not explicitly delimit a block that is intended to contain two or more instructions, creating a logic error. In some cases, the logic error can have security implications.",
        "mitigation": "Always use explicit block delimitation."
    },
    "missing rooted device check": {
        "title": "Missing Rooted Device Check",
        "desc": "The absence of proper device root check indicates that it would function normally on a rooted device.",
        "impact": "A rooted device can be vulnerable to multiple forms of attack, as applications, services and more may have significant access to privileged device operations. These operations include directly reading and writing memory, full file system access and more.\n\n\nWhile no checks for a rooted device are bulletproof, as a malicious application will almost assuredly be able to suppress any such checks, they are nonetheless recommended to protect application users from using it on a compromised device, for instances such as when a device has been rooted but not yet compromised.",
        "mitigation": "Conduct checks, preferably at startup, to ensure the device is not rooted. If it is rooted, warn the user, and consider preventing them from using the application altogether, to prevent compromise of sensitive information within the application."
    },
    "information leak through response caching": {
        "title": "Information Leak Through Response Caching",
        "desc": "HTTP responses are may be cached on any machine and server in order to reduce bandwidth, by caching HTTP contents. That means that any sensitive information that is part of an HTTP response may be stored in a cache on the device.",
        "impact": "Any information cached by the client can be retrieved by attackers with local file system access, potentially allowing it to be compromised.",
        "mitigation": "* If a response contains sensitive data it should never be cached by any mechanism, to avoid potential leakage\n* Always set the cache-control header according to the context of the data being processed"
    },
    "deserialization of untrusted data in jms": {
        "title": "Deserialization of Untrusted Data in JMS",
        "desc": "Object serialization and deserialization is integral to the process of remoting, wherein objects are passed between code instances over an intermediary medium, such as over a network. During deserialization, a new object is constructed from a serialized object provided over the medium; however, if the object being deserialized is untrusted, an unexpected and potentially dangerous object can be provided.\n\n\nIn case of using Java JMS, Messages may contain Java objects. If the Message handling is not done carefully, and a Message object is accessed without ensuring it is of a secure type or contains a trusted object, it may allow attackers to deserialize a malicious gadget which could lead to remote code execution.",
        "impact": "Deserialization of untrusted data may allow attackers to craft and provide a malicious object to the deserializing code. If a dangerous object is unsecurely deserialized, it may result in execution of code or operating system commands, by invoking classes or methods potentially available to the object during the deserialization process.\n\n\nAdditionally, deserialization may bypass logical object validation. Since deserialization often uses its own means of constructing a new object from the serialized data, it may bypass checks enforced in constructors or setters, which would allow attackers to deserialize an object whose properties are not validated, incorrect or outright malicious. This may lead to unexpected behavior, affecting logic in ways that are entirely dependent on implementation.\n\n\nIn Java, deserialized classes may often borrow classes from the general namespace, allowing compound deserialized objects (\"Gadgets\") to deserialize and invoke dangerous built in types, such as java.lang.Runtime, which is capable of executing operating system commands.",
        "mitigation": "* Where possible, do not pass serialized object between remote instances. Instead, consider passing value primitives between instances and use these values to populate a newly constructed object.\n* If required, use a whitelist approach to passed objects. Always ensure the passed object is known, trusted and expected. Do not dynamically construct an object from any source unless the object has been verified and is of a trusted, known type, and may not contain untrusted objects within it.\n* When choosing a serializer - always consult vendor documentation, best practices and even known exploitation techniques to ensure that the serializer chosen and deployed is defensible, securely configured, and does not allow any potentially dangerous objects.\n* When using JMS, always verify the received Message's data-type to ensure it is not an ObjectMessage, as ObjectMessages may contain malicious objects."
    },
    "exposure of resource to wrong sphere": {
        "title": "Exposure of Resource to Wrong Sphere",
        "desc": "One of the application's classes exposes an internal variable as a public field, without constraining access, by exposing it as a property. Alternatively, public fields can be exposed without allowing their values to be externally modified.",
        "impact": "If a\u00a0class exposes an internal variable as a public field, without constraining access, the variable can be modified in unexpected ways, allowing an external consumer of the class to set arbitrary, unallowed values to the field. This could cause\u00a0to unexpected behavior if the class (or other consumers) make assumptions about the value of that variable. This could even lead to additional vulnerabilities, depending on how this value is used.",
        "mitigation": "* Avoid exposing internal variables and specific implementation as public fields.\n* Prefer exposing data as properties, and implement data validation and control in the property code as needed.\n* When exposing\u00a0a public field, constrain the value to be readonly via use of `final` modifier."
    },
    "insecure data storage usage": {
        "title": "Insecure Data Storage Usage",
        "desc": "The application stores data publically on the device, allowing applications and other users of the device to retrieve it.",
        "impact": "Information written to a public storage can be retrieved, resulting in exposure of potentially sensitive information. It is also potentially malleable, which may result in further attack against the application, if the application fails to sanitize data read from storage, and using that data in an exploitable context.",
        "mitigation": "* Unless specifically intended to be shared with other applications or users, opt for a more robust container to store data.\n* Perform strict input validation or sanitization on all data retrieved from external storage before using it in code, as it can become tainted.\n* In Android, there are secure alternatives to writing in public folders, such as FileProvider, which allows file sharing between applications."
    },
    "overly permissive cross origin resource sharing policy": {
        "title": "Overly Permissive Cross Origin Resource Sharing Policy",
        "desc": "Modern browsers, by default, disallow resource sharing between different domains from accessing one another's DOM contents, cookie jars and other resources, specifically to prevent malicious web-applications from attacking legitimate web-applications and their users as part of the Same-Origin Policy (SOP). For example - website A cannot retrieve contents of website B by default, as that is a breach of the SOP. The Cross-Origin Resource Sharing (CORS) policy, defined by specific headers, allows loosening this strict default behavior to enable cross-site communications. However, when used incorrectly, CORS may enable\u00a0unintended and potentially malicious behavior by allowing an overly broad trust of web-applications that may submit requests and retrieve responses from the web-application.\n\n\nThe Access-Control-Allow-Origin is incorrectly set to an unsafe value in code.",
        "impact": "A Cross-Origin Resource Sharing (CORS) header,\u00a0\"Access-Control-Allow-Origin\", that is overly permissive may allow scripts from other web-sites to access, and often manipulate, resources on the affected web-application. These resources may include page contents, tokens and more, allowing potential Cross-Site Request Forgery (CSRF) or Cross-Site Scripting (XSS) attacks, performing actions on a user's behalf such as changing their password, or allow breach of user privacy.",
        "mitigation": "Where not explicitly required, do not set any CORS headers. Where required, consider business needs for setting these headers, and opt for the most restrictive configuration possible, such as white-listing trusted, secure and allowed domains access, while\u00a0utilizing other CORS headers to strictly provide required and expected functionality."
    },
    "missing hsts header": {
        "title": "Missing HSTS Header",
        "desc": "Many users browse to websites by simply typing the domain name into the address bar, without the protocol prefix. The browser will automatically assume that the user's intended protocol is HTTP, instead of the\u00a0encrypted HTTPS protocol.\n\n\nWhen this initial request is made, an attacker can perform a Man-in-the-Middle attack and manipulate it to redirect users to a malicious web-site of the attacker's choosing. To protect the user from such an occurence, the HTTP Strict Transport Security (HSTS) header instructs the user's browser to disallow use of an unsecure HTTP connection to the the domain associated with the HSTS header.\n\n\nOnce\u00a0a browser that supports the HSTS feature has visited a web-site and the header was set, it will no longer allow\u00a0communicating with the domain over an HTTP connection.\n\n\nOnce an HSTS header was issued for a specific website, the browser is also instructed\u00a0to prevent users from manually overriding and accepting an untrusted SSL certificate for as long as the \"max-age\" value still applies. The recommended \"max-age\" value is for at least one year in seconds, or 31536000.",
        "impact": "Failure to set an HSTS header and provide it with a reasonable \"max-age\" value of at least one year may leave users vulnerable to Man-in-the-Middle attacks.",
        "mitigation": "* Before setting the HSTS header - consider the implications it may have:\n\t+ Forcing HTTPS will prevent any future use of HTTP, which could hinder some testing\n\t+ Disabling HSTS is not trivial, as once it is disabled on the site, it must also be disabled on the browser\n* Set the HSTS header either explicitly within application code, or using web-server configurations.\n* Ensure the \"max-age\" value for HSTS headers is set to 31536000 to ensure HSTS is strictly enforced for at least one year.\n* Include the \"includeSubDomains\" to maximize HSTS coverage, and ensure HSTS is enforced on all sub-domains under the current domain\n\t+ Note that this may prevent secure browser access to any sub-domains that utilize HTTP; however, use of HTTP is very severe and highly discouraged, even for websites that do not contain any sensitive information, as their contents can still be tampered via Man-in-the-Middle attacks to phish users under the HTTP domain.\n* Once HSTS has been enforced, submit the web-application's\u00a0address to an HSTS preload list - this will ensure that, even if a client is accessing the web-application for the first time (implying HSTS has not yet been set by the web-application), a browser that respects the HSTS preload list would still treat the web-application as if it had already issued an HSTS header. Note that this requires the server to have a trusted SSL certificate, and issue an HSTS header with a maxAge of 1 year (31536000)\n* Note that\u00a0this query is designed to return one result per application. This means that if more than one vulnerable response without an HSTS header is identified, only the first identified instance of this issue will be highlighted as a result. If a misconfigured instance of HSTS is identified (has a short lifespan, or is missing the \"includeSubDomains\" flag), that result will be flagged. Since HSTS is required to be enforced across the entire application to be considered a secure deployment of HSTS functionality, fixing this issue only where the query highlights this result is likely to produce subsequent results in other sections of the application; therefore, when adding this header via code, ensure it is uniformly deployed across the entire application. If this header is added via configuration, ensure that this configuration applies to the entire application.\n* Note that misconfigured HSTS headers that do not contain the recommended max-age value of at least one year or the \"includeSubDomains\" flag will still return a result for a missing HSTS header."
    },
    "unsafe object binding": {
        "title": "Unsafe Object Binding",
        "desc": "Using object binding methods, built into MVC controllers, exposes all public setters to allow easily wiring values submitted by users in forms, to the objects and attributes they are intended to create or alter. This approach allows application code to skip the boilerplate code of having to parse requests for user values, and manually setting them individually into objects being created.\n\n\nHowever, this may also pose a significant risk to application logic and flow - naively mass binding objects in such a manner may also accidentally expose unintended objects or attributes, which could then be tampered with by an attacker.",
        "impact": "Unsafe binding of objects to requests may expose unintended setters to remote attackers, allowing them to directly access objects, attributes and even objects within objects via broadly binding setters to an incoming request.",
        "mitigation": "* Review all mass-assigned objects to ensure no unintended public setters or constructors are unintentionally exposed by this approach.\n* Ensure that, where required, access to attributes and objects is correctly restricted by application code.\n* Consider transitioning away from object binding methods to a more granular approach where values are only ever explicitly set, to prevent accidentally exposing unintended values to being implicitly altered."
    },
    "hardcoded aws credentials": {
        "title": "Hardcoded AWS Credentials",
        "desc": "The application codebase contains AWS credentials as string literals embedded in the source code. This hardcoded value is then passed as credentials to an AWS client.",
        "impact": "Hardcoded credentials expose the application to credential leakage. If an attacker gains access to the source code, they will be able to steal the embedded passwords, and use them to impersonate a valid user, compromising any access, data and functionality this account has with AWS.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not credentials of any kind.\n* In particular, user passwords should be stored in a database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2)."
    },
    "expression language injection spel": {
        "title": "Expression Language Injection SPEL",
        "desc": "An expression language statement is evaluated from a string; this string contains potentially tainted user inputs, allowing attackers to inject their own expression language code into the evaluated string.\n\n\nIn Spring, SPEL can be evaluated within Spring tags in a JSP context, or evaluated in Java context using certain Spring methods.",
        "impact": "An SPEL expression can call many libraries, including making static calls to Java Runtime, which would allow execution of arbitrary Java code and even OS commands.",
        "mitigation": "* Where possible, do not insert user inputs into expression language statements. If dynamic statements are required, consider a white-list of allowed statements, chosen by user inputs, that will be used as an expression language statement instead.\n* If required, construct an expression language statement that offers data encapsulation for user provided parameters, and sanitize user inputs to ensure they may not escape this data encapsulation, thus altering the expression language content of the statement itself.\n* Do not concatenate user inputs to SPEL expressions to avoid these strings from being evaluated as code"
    },
    "gwt dom xss": {
        "title": "GWT DOM XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nWhen a DOM XSS occurs, it is the client-side code itself that manipulates the local web-page's DOM, and introduces malicious content.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn additional risk with DOM XSS is that, unlike reflected or stored XSS, tainted values do not have to go through the server. Since the server is not involved in sanitization of these inputs, server-side validation is not likely to not be aware XSS attacks have been occurring, and any server-side security solutions, such as a WAF, are likely to be ineffective in DOM XSS mitigation.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "gwt reflected xss": {
        "title": "GWT Reflected XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "heuristic 2nd order sql injection": {
        "title": "Heuristic 2nd Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by updating fields in the database. Later, the application reads this data from the database, and embeds it within the SQL query, as SQL commands. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using\u00a0standard\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using a standard ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others, instead of a custom data wrapper."
    },
    "heuristic cgi stored xss": {
        "title": "Heuristic CGI Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into some data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use legitimate access to the application to submit modified data, which would be saved by the application to some data-store. This stored data would then be used to dynamically generate output to a generic output writer - in some scenarios, such as with CGI scripts, this output will be sent directly to the user's browser, which would trigger the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "heuristic db parameter tampering": {
        "title": "Heuristic DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "heuristic parameter tampering": {
        "title": "Heuristic Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "screen caching": {
        "title": "Screen Caching",
        "desc": "The application shows some sensitive data on a screen, such as a credit card numbers, using a regular UI element. The user presses the home button and sends the active application to the background. At the same moment, the system takes a screenshot of the application screen and saves the screenshot in a system folder. The screenshot is later used in an App Switcher to present open application screen previews. An attacker steals the mobile device, gets access to the screenshots folder, and steals the sensitive information.",
        "impact": "An attacker could get access to the application screenshots that were saved by the system. If sensitive data was presented in the screenshot, it could be leaked.",
        "mitigation": "* Ensure UI elements that contain sensitive data are hidden\n* Consider disabling all screen caching for activities that display sensitive data"
    },
    "heuristic sql injection": {
        "title": "Heuristic SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by way of altering the user input. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using standard\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using a standard ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others, instead of a custom data wrapper."
    },
    "permissive content security policy": {
        "title": "Permissive Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are\u00a0broadly defined, they are ineffective in blocking untrusted content.\n\n\nApplication code is used to set a Content-Security-Policy; however, it sets an overly permissive policy.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to a strict Content Security Policy, it is promptly rejected by the browser. Failure to enforce strict content behavior by\u00a0policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Set the Content-Security-Policy headers for all applicable policy types (frame, frame-ancestors, script, form-actions, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header managed by\u00a0web-server configurations, and within `<meta>` tags in HTML pages' `<head>` section."
    },
    "heuristic stored xss": {
        "title": "Heuristic Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn attacker could use legitimate access to the application to submit modified data to the application\u2019s data-store. This would then be used to construct the returned web page, triggering the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "heuristic xsrf": {
        "title": "Heuristic XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    },
    "code injection": {
        "title": "Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* If dynamic execution is necessary, run all dynamic code in an external `Process`, and pass the external data as a parameter to the process using `ProcessBuilder`.\n* Alternatively, it is possible to perform dynamic execution of code in an isolated sandbox running on a separate thread, by implementing a custom `SecurityManager` to implement a restrictive `Policy`, and a custom `ClassLoader` to allow loading of only permitted classes, from pre-defined sandboxed locations.\u00a0(Note that this can never provide complete protection from sandbox exploits, and all dynamic execution should be avoided if possible.)"
    },
    "use of hardcoded password in config": {
        "title": "Use Of Hardcoded Password In Config",
        "desc": "A password is stored in plain-text in a configuration file on the file system.",
        "impact": "Storing sensitive information in plain-text, such as in a configuration file, may allow anyone with local file access to trivially retrieve it.",
        "mitigation": "* Do not store passwords in plain-text\n* Use a secure storage solution, such as an encrypted container - ensure the key to this container is not stored, itself, in plain-text\n* Alternatively, use a different authentication mechanism, such as domain-based access-control and authentication"
    },
    "command injection": {
        "title": "Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application receives data from the user input, and passes it as a string to the Operating System. This unvalidated data is then executed by the OS as a system command, running with the same system privileges as the application.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege.\n* If absolutely necessary to call a system command or execute an external program with user input, use only the safe form of the `ProcessBuilder` class, using a hardcoded system command or executable as the first parameter.\n* Do not directly execute any shell or command interpreters, such as `bash`, `cmd`, or `make`, with user-controlled input."
    },
    "connection string injection": {
        "title": "Connection String Injection",
        "desc": "In order to communicate with the database, or with another external server (for example, Active Directory), the application dynamically constructs a connection string. This connection string includes untrusted data, which may be controlled by a malicious user. Since it is not constrained or properly sanitized, the untrusted data could be used to maliciously manipulate the connection string.",
        "impact": "If an attacker could manipulate the application\u2019s connection string to the database server, they might be able do any of the following:\n\n* Damage application performance (by increasing the MIN POOL SIZE)\n* Tamper with the network connection (for example, via TRUSTED CONNECTION)\n* Direct the application to the attacker\u2019s bogus database\n* Discover the password to the system account on the database (by a brute-force attack).",
        "mitigation": "* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Do not allow users to control the database connection string. Avoid dynamically building connection strings based on untrusted data, especially user input.\n* Store all connection strings in appropriate configuration mechanisms. If it is necessary to dynamically construct a connection string at runtime, do not include untrusted data directly in the connection string; instead, allow users to select from pre-defined connection strings."
    },
    "ldap injection": {
        "title": "LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code."
    },
    "reflected xss all clients": {
        "title": "Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "resource injection": {
        "title": "Resource Injection",
        "desc": "The application allocates a resource based on user input, enabling an attacker to control it.",
        "impact": "The impact of resource injection is highly implementation dependent. By allowing attackers to control server-side resource I/O, such as network, storage or memory, an attacker may reroute these resources to expose them, generate multiple instances to exhaust the resource, or create a resource in a manner that would block other I/O operations.",
        "mitigation": "* Do not allow a user or untrusted data to define parameters of I/O, such as network sockets, storage access or other resource configurations."
    },
    "second order sql injection": {
        "title": "Second Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the database, typically via forms on other web pages. Afterwards, the application reads this data from the database, and embeds it within the SQL query, as SQL commands.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using an ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others."
    },
    "sql injection": {
        "title": "SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using `PreparedStatement` for parameterizing the queries, or even better `CallableStatement`. Add dynamic data via the `.set*()` methods, instead of string concatenation.\n* Consider using an ORM package, such as `Hibernate`, `myBatis`, or others."
    },
    "stored xss": {
        "title": "Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn attacker could use legitimate access to the application to submit modified data to the application\u2019s data-store. This would then be used to construct the returned web page, triggering the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "xpath injection": {
        "title": "XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code.\n* Input sanitization, while not preferred, can be done safely when required with OWASP's `ESAPI` library, using `Encoder.encodeForXPath()`. Additional libraries may also provide similar functionality.\n* Prefer parameterized XPath queries over data sanitization, to fully separate the input from the expression. Precompile the XPath query using `XPath.compile()`, after defining the variable resolution mechanism using `XPath.setXPathVariableResolver()` and a custom\u00a0`XPathVariableResolver` class. Afterwards the variables can be provided to the `XPathVariableResolver`, and evaluated using the resulting\u00a0`XPathExpression.evaluate()`."
    },
    "blind sql injections": {
        "title": "Blind SQL Injections",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn this case, the attacker does not need to rely on the application returning data from the database. Instead, it is possible to leverage existing tools that perform a series of boolean tests based on varying user input, relying only on the existence of application errors to indicate server state. Thus, the full database content can gradually be obtained, one bit at a time.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nIn this case, while the actual exploit is constrained to single bit of information at a time, it is still possible to eventually retrieve all data from the system, though this process is more time consuming and would be rather noisy. Note that other consequences, such as data modification and creation, code execution, etc. are unaffected, and still equally exploitable.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Do not allow the user to dynamically provide the name of the queried table. Furthermore, if possible, completely avoid dynamically specifying table names.\n* Ensure that all exceptions are properly handled, without leaking information on the errors, server state, or that an error occurred at all.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using an ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others."
    },
    "sensitive cookie in https session without secure attribute": {
        "title": "Sensitive Cookie in HTTPS Session Without Secure Attribute",
        "desc": "The web application framework by default does not set the \"secure\" flag for the application's sessionID cookie, and other sensitive application cookies. Likewise, the application does not explicitly use the \"secure\" cookie flag, allowing them to be sent in plaintext over an insecure session.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, should be sent to the server over a secure network communication (HTTPS) in order to prevent attackers from sniffing the traffic and stealing those cookies. Unless the web application explicitly prevents this by using the \"secure\" cookie flag, these cookies will also be sent over insecure traffic, which can lead to session hijacking and impersonation.",
        "mitigation": "* Always set the \"secure\" flag for any sensitive server-side cookies.\n* If the application explicitly handles cookies directly in application code, set the \"secure\" flag for sensitive cookies set by the application.\n**Secure-Code Approach**\n* Configure the application to always use \"secure\" cookies, in the site-wide configuration file.\n* Enable the Secure flag or use the relevant Set-Secure API in the code."
    },
    "improper resource shutdown or release": {
        "title": "Improper Resource Shutdown or Release",
        "desc": "The application code allocates resource objects, but does not ensure these are always closed and released in a timely manner. This can include database connections, file handles, network sockets, or any other resource that needs to be released.\u00a0In some cases,\u00a0these might be released - but only if everything works as planned; if there is any runtime exception during the normal course of system operations, resources start to leak.\u00a0\n\n\nNote that even in managed-memory languages such as Java, these resources must be explicitly released. Many types of resource are not released even when the Garbage Collector runs; and even if the the object would eventually release the resource, we have no control over when the Garbage Collector does\u00a0run.",
        "impact": "Unreleased resources can cause a drain of those available for system use, eventually causing general reliability and availability problems, such as performance degradation, process bloat, and system instability. If a resource leak\u00a0can be intentionally exploited by an attacker, it may be possible to cause a widespread DoS (Denial of Service) attack. This might even expose sensitive information between unprivileged users, if the resource continues to retain\u00a0data or user id\u00a0between subsequent allocations.",
        "mitigation": "* Always close and release all resources.\n* Ensure resources are released (along with\u00a0any other necessary cleanup) in a `finally { }` block. Do not close resources in a `catch { }` block, since this is not ensured to be called.\n* Explicitly call .close() on any instance of a class that implements the `Closable` or `AutoClosable` interfaces.\n* Alternatively, an even better solution is to use the try-with-resources idiom, in order to automatically close any defined\u00a0`AutoClosable`\u00a0instances."
    },
    "unrestricted read s3": {
        "title": "Unrestricted Read S3",
        "desc": "The application's code directly relies on unvalidated user-supplied inputs as a key for retrieving and object from S3, whose contents are later returned to the user. If this S3 instance contains sensitive information, an attacker could provide a key to retrieve other objects that may contain other users' information or sensitive information not intended for external user consumption.",
        "impact": "If an attacker is allowed to determine what object is retrieved from the S3 instance and returned to them, they may retrieve arbitrary objects that were not intended to be available to users, disclosing potentially sensitive contents.",
        "mitigation": "* Do not rely on user inputs as literal keys for retrieval of S3 objects.\n* If dynamic retrieval is required on a per-user basis, store these keys in a container associated with the user, such as session variables or a database, and use them as required. Ensure such keys cannot be altered by the user."
    },
    "just one of equals and hash code defined": {
        "title": "Just One of Equals and Hash code Defined",
        "desc": "The general language contract for implementing classes requires the class to implement both `.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods (or neither). This requirement is important for hash tables and other data structures, and to ensure the class behavior is consistent between these methods. However, this class does in fact only implement one of these methods, but not the other, resulting in a broken object.",
        "impact": "If an application class explictly defines an override for only one of the\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, but not the other, this can negatively affect the application's integrity, and possibly cause inconsistent and unexpected results. This may also affect system performance, when using instances of this class in a hashtable or set.",
        "mitigation": "* Define overriding implementations for both\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, or not at all. If one is overridden, then both must be.\n* Note the general principle is: if `x.equals(y)`, then `x.hashCode()` must be equal to `y.hashCode()`.\n* Consider using the `EqualsBuilder` and `HashCodeBuilder` classes from the Apache Commons library."
    },
    "cleansing canonicalization and comparison errors": {
        "title": "Cleansing Canonicalization and Comparison Errors",
        "desc": "Filesystem paths and Internet URLs can be represented in an unlimited number of different ways, using various encodings, folder misdirection, and path obfuscation techniques. If a path or address is not properly sanitized and fully canonicalized into it's most basic, simplified form, it would be impossible to check all possible variants of this path. Hence, any decision based on a specific attributes of the path would likely be mistaken, and can be evaded by an active attacker.",
        "impact": "If a security decision, such as access control for example, is taken based on unsanitized, user-controlled data, it may be possible for\u00a0an attacker to manipulate the format of the data,\u00a0and thus obfuscate the actual\u00a0target. For example, if users are allowed to read any page that has\u00a0their user id in the URL, a user can request a URL with multiple user ids. Another example could be an administrative interface, wherein users are forbidden from accessing any page under the `/admin/` folder; an attacker can hide the actual target by sending a request to `/NOTEXISTS/../admin/`\u00a0. This would evade the check for URLs starting with \"admin/\", if the request URL is not canonicalized before checking.",
        "mitigation": "* Avoid performing security decisions based on untrusted, user-controlled input.\n* Always sanitize all user input.\n* Before making any decision based on a URL or path parameter, always transform it first into its canonical form, before making any decisions or doing any checks on it."
    },
    "hardcoded absolute path": {
        "title": "Hardcoded Absolute Path",
        "desc": "Hardcoded paths are less flexible, and do not allow the application to account for changes in the environment. For example, the program might be installed in a different directory than the default. Likewise, different system languages and OS architectures can change the names of the system folders; for example, in a Spanish Windows machine there could\u00a0be\u00a0\"`C:\\Archivos de programa (x86)\\`\" instead of \"`C:\\Program Files\\`\".\u00a0\n\n\nMoreover, on Windows by default all directories and files created outside of the system folders and outside the user's profile, will be allow full read and write access to any authenticated user. An unauthorized, malicious user could access any sensitive data in these folders, despite the application assuming they are protected. Even worse, an attacker\u00a0could overwrite existing programs in these unprotected folders and plant malicious code, which\u00a0will be activated by the application.",
        "impact": "Generally, hardcoding absolute paths makes the application brittle, and will prevent the program from operating properly in some environments that do not have the identical file system structure. This will also cause software maintenance problems in future versions of the application, if the design or requirements were to change.\u00a0\n\n\nAdditionally, if the application uses this path to read or write data, this can cause a breach of confidentiality or\u00a0allow malicious input into the program. In some situations, this vulnerability might even allow a malicious user to override the expected functionality, and cause the application to run any arbitrary program and execute any code the attacker deploys to the server.",
        "mitigation": "* Do not hardcode absolute paths into the application.\n* Instead, store the absolute paths in an external configuration file, that can be modified as required for each environment.\n* Alternatively, use paths relative to the current application, if the target file is in a subdirectory of the application's root.\n* Do not assume a specific file system structure, outside of the application's subdirectories. On Windows, use the built-in expandable variables, such as `%WINDIR%`, `%PROGRAMFILES%,` and `%TEMP%`.\n* On Linux and other OS where available, implement a system jail (chroot) for the application, and store\u00a0all programs and data files there only.\n* Prefer storing all executables under the protected program directory (under \"`C:\\Program Files\\`\" by default on Windows).\n* Do not store sensitive data or configuration files in arbitrary folders. Likewise, do not store data files in the program directory. Instead, use the designated folders as intended, i.e. `%PROGRAMDATA%` and `%APPDATA%`\u00a0on Windows, respectively.\n* Configure hardened permissions to the most restricted as possible, according to the Principle of Least Privilege. Consider implementing this automatically in the installation and setup routines."
    },
    "use of hardcoded password": {
        "title": "Use Of Hardcoded Password",
        "desc": "The application codebase\u00a0has string literal passwords embedded in the source code. This hardcoded value is used either to compare to user-provided credentials, or to authenticate downstream to a remote system (such as a database or a remote web service). \u00a0\n\n\nAn attacker only needs to gain access to the source code to reveal the hardcoded password. Likewise, the attacker can reverse engineer the compiled application binaries, and easily retrieve the embedded password. Once found, the attacker can easily use the password in impersonation attacks, either directly on the application or to the remote system.\u00a0\n\n\nFurthermore, once stolen, this password cannot be easily changed to prevent further misuse, unless a new version of the application is compiled. Moreover, if this application is distributed to numerous systems, stealing the password from one system automatically allows a class break in to all the deployed systems.",
        "impact": "Hardcoded passwords expose the application to password leakage. If an attacker gains access to the source code, she will be able to steal the embedded passwords, and use them to impersonate a valid user. This could include impersonating end users to the application, or impersonating the application to a remote system, such as a database or a remote web service.\u00a0\n\n\nOnce the attacker succeeds in impersonating the user or application, she will have full access to the system, and be able to do anything the impersonated identity could do.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not passwords.\n* In particular, user passwords should be stored in a\u00a0database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2). Do not compare user passwords with a hardcoded value.\n* Sytem passwords should be stored in a configuration file or the database, and protected with strong encryption (e.g. AES-256). Encryption keys should be securely managed, and not hardcoded."
    },
    "improper exception handling": {
        "title": "Improper Exception Handling",
        "desc": "The application performs some operation, such as database or file access, that could throw an exception. Since the application is not designed to properly handle the exception, the application could crash.",
        "impact": "An attacker could maliciously cause an exception that could crash the application, potentially resulting in a denial of service (DoS) or unexpected behavior under certain erroneous conditions. Exceptions may also occur without any malicious intervention, resulting in general instability.",
        "mitigation": "Any method that could cause an exception should be wrapped in a try-catch block that:\n\n* Explicitly handles expected exceptions\n* Includes a default solution to explicitly handle unexpected exceptions"
    },
    "improper session management": {
        "title": "Improper Session Management",
        "desc": "The application authenticates users without terminating existing sessions. As a result, an attacker could get a victim to log in to the application during the attacker\u2019s session (for example, by getting the victim to click on a link including a session ID), and the application would authenticate the attacker\u2019s session as the victim\u2019s user account.",
        "impact": "An attacker could get a user to log in using the attacker\u2019s session. The attacker could then do anything that the other user has permissions for, such as accessing that user\u2019s confidential information and performing transaction in that user\u2019s name.",
        "mitigation": "The application should terminate any existing sessions upon user authentication and create a new session for that user."
    },
    "improper transaction handling": {
        "title": "Improper Transaction Handling",
        "desc": "The application creates a connection to the database, and explicitly manages the database transaction by committing it when appropriate. However, the code does not explicitly roll back failed transactions, for example in the case of exceptions. This causes the application to rely on implementation-specific behavior, depending on the specific combination of technologies (such as the database server) and resultant configuration.",
        "impact": "Database transactions that are abandoned (if their associated connection is closed, before the transaction is committed or rolled back) can have several different results, depending on implementation and specific technologies in use. While in some scenarios the database will automatically roll back the transaction if the connection is closed, more often it will either automatically commit the transaction in its abortive state, or leave the transaction open indefinitely (depending on its configured timeout value).\u00a0\n\n\nIn the first case, a transaction that is committed after a runtime exception is likely to be in an inconsistent state, incompatible with the current runtime conditions. This would result in situation detrimental to the system's integrity and possibly even stability.\u00a0\n\n\nIn the second case, a transaction that is kept active\u00a0indefinitely would cause the database server to retain its locks on all records and tables affected by the transaction. This could cause general reliability and availability problems, leading to delays, degraded performance, or even deadlocks as one thread waits for the locks to be released.\u00a0\n\n\nIn either case this results in unexpected state, and is dependent on external factors such that the application is not controlling the result.",
        "mitigation": "* Always open database connections and begin transactions within a `try { }` block.\n* Ensure there are no active uncommitted transactions before closing a database connection.\n* Always rollback active transactions in the case of exceptions.\n* After handling the exception, ensure the transaction is rolled back in the `catch { }` block, or possibly in the `finally { }` block."
    },
    "leaving temporary file": {
        "title": "Leaving Temporary File",
        "desc": "It is very common for applications to use temporary files, as intermediate storage and to aid with processing large amounts of data or long-running calculations. Applications require such files so frequently that most operating systems allocate a dedicated area for temporary files, such as a TEMP directory, and several different mechanisms for creating them exist in most platforms. However, by default these temporary files are not deleted automatically, and will remain on disk indefinitely. If the program does not explicitly and proactively delete the temporary files when it is finished processing them, they might be accessbile to other users of the computer.",
        "impact": "Applications often create temporary files containing sensitive business data or personal information, in order to handle the file generation process in\u00a0several steps, or even as the output of an automatic process. These files, if left exposed\u00a0on disk for an indeterminate period of time, could leak the secret data to unauthorized users.",
        "mitigation": "* Always explicitly delete any temporary file created. Ensure temp file deletion will occur by wrapping it in a `finally { }` block, or call `File.deleteOnExit()` to ensure eventual deletion.\n* Additionally, to ensure that all temporary files will eventually be deleted, consider implementing additional functionality that will periodically scrape and delete all unused, existing temporary files.\n* Ensure all existing file handles or references are closed before attempting deletion."
    },
    "log forging": {
        "title": "Log Forging",
        "desc": "The application writes audit logs upon security-sensitive actions. Since the audit log includes user input that is neither checked for data type validity nor subsequently sanitized, the input could contain false information made to look like legitimate audit log data,",
        "impact": "An attacker could engineer audit logs of security-sensitive actions and lay a false audit trail, potentially implicating an innocent user or hiding an incident.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in logs.\n3. Use a secure logging mechanism."
    },
    "insufficiently protected credentials": {
        "title": "Insufficiently Protected Credentials",
        "desc": "A password was stored in plaintext, outside of a secure container such as a password hashing algorithm or data encryption.",
        "impact": "Passwords that are stored in plaintext outside of a secure container would be trivial to read, if retrieved by an attacker. Leaked passwords could then be used to authenticate to other sensitive resources, to perform actions and retrieve additional information.",
        "mitigation": "Generic Guidance:\n\n* Always use strong, modern algorithms for encryption, hashing, and so on.\n* Do not use weak, outdated, or obsolete algorithms.\n* Ensure you select the correct cryptographic mechanism according to the specific requirements.\n* Passwords should be protected with a dedicated password protection scheme, such as bcrypt, scrypt, PBKDF2, or Argon2.\n\n\nSpecific Recommendations:\n\n* Do not use SHA-1, MD5, or any other weak hash algorithm to protect passwords or personal data. Instead, use a stronger hash such as SHA-256 when a secure hash is required.\n* Do not use DES, 3DES, RC2, or any other weak encryption algorithm to protect passwords or personal data. Instead, use a stronger encryption algorithm such as AES to protect personal data.\n* Do not use weak encryption modes such as ECB, or rely on insecure defaults. Explicitly specify a stronger encryption mode, such as GCM.\n* For symmetric encryption, use a key length of at least 256 bits."
    },
    "information leak through persistent cookies": {
        "title": "Information Leak Through Persistent Cookies",
        "desc": "Cookies that are set with the \"expires\" or \"max-age\" attributes will indicate to the browser that these cookies are intended to persist through browser shut-down. This causes the browser to locally store\u00a0these cookies, which may contain sensitive data.",
        "impact": "Cookies often contain sensitive data, such as session tokens or CSRF tokens. Failure to ensure sensitive cookies are not cached may expose them to compromise from attackers with access to the local file-system, and increases their exposure to attack by keeping users logged in beyond their active session.",
        "mitigation": "Do not set the persistence attributes\u00a0\"expires\" or \"max-age\" on cookies that contain sensitive information to ensure they properly expire once the browser is closed.\n\n\nConfiguring the expiry attributes can be done either explicitly in code, or within web-server configurations."
    },
    "potential redos": {
        "title": "Potential ReDoS",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos by injection": {
        "title": "Potential ReDoS By Injection",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos in match": {
        "title": "Potential ReDoS In Match",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos in replace": {
        "title": "Potential ReDoS In Replace",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos in static field": {
        "title": "Potential ReDoS In Static Field",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "data leak between sessions": {
        "title": "Data Leak Between Sessions",
        "desc": "Most modern environments, and web in particular, require a high level of concurrent actions, invoking many instances of an object, or a singleton object multiple times, using an internal scheduler that decides which thread should be operating at the moment. This scheduler is often out of a developer's control, and may halt and resume concurrent threads. These threads often operate over shared resources, which are part of a functionality that is being invoked simultaneously across multiple logic flows; for example - static member variables are shared across all instances of an object type, while in singleton objects (such as servlets) any member variable is shared across all calls to the singleton.\n\n\nWhen working in an environment with concurrency, failure to ensure all operations on a shared resource are done atomically and in a synchronized manner may result in threads or processes overriding each other's actions or outputs, often contradicting intended logic. For example, consider the \"Time of Check, Time of Use\" problem (TOCTOU) - if two threads attempt to increment the same counter, thread 1 reads the value n, and is then halted by the scheduler, thread 2 will read the value n, and then both threads will attempt to update the value to n+1, where logic would dictate that it would be n+2. Had this counter been properly synchronized, thread 2 would have to wait for thread 1 to complete its entire atomic operation of checking and updating its value.",
        "impact": "A\u00a0race condition can cause erratic or unexpected application behavior. Additionally, if a race condition\u00a0can be influenced directly by users, an attacker may choose to replay a race condition until they obtain a desired\u00a0result, allowing them to induce certain application behavior that is not part of its intentional design.",
        "mitigation": "* Consider allocating independent\u00a0resources\u00a0for concurrent logical processes, unless required.\n* Where resource sharing is required, utilize a locking mechanism when handling shared resources to ensure that actions are performed atomically by the current process, so that these logical processes\u00a0are not overridden or disrupted by any other concurrent process.\n* When dealing with static member variables - always consider that these are shared across all instances of an object\n* When dealing with singleton objects (such as servlets) being invoked by multiple concurrent logical processes - always synchronize either the entire singleton or its member variables; otherwise any thread processing the singleton's static methods may cause TOCTOU issues"
    },
    "use of non cryptographic random": {
        "title": "Use of Non Cryptographic Random",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values, it would be possible for an attacker to calculate past or future values.  \n\nSpecifically, if this pseudo-random value is used in any security context, such as one-time passwords, keys, secret identifiers or salts - an attacker would likely be able to predict the next value generated and steal it, or guess a previously generated value and spoof its original intent.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from knowing or predicting a given value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values, based on sources often used to derive certain randomness; however, while they may seem random, large statistical samples would demonstrate that they are insufficiently random, producing a much smaller space of possible \"random\" values than a truly random sample would. This could enable an attacker to derive or guess this value, and thus hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "* Always use a cryptographically secure pseudo-random number generator, instead of basic random methods, particularly when dealing with a security context\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, thus making brute-force attacks unfeasible."
    },
    "open redirect": {
        "title": "Open Redirect",
        "desc": "The application redirects the user\u2019s browser to a URL provided by a tainted input, without first ensuring that URL leads to a trusted destination, and without warning users that they are being redirected outside of the current site. An attacker could use social engineering to get a victim to click a link to the application with a parameter defining another site to which the application will redirect the user\u2019s browser. Since the user may not be aware of the redirection, they may be under the misconception that the website they are currently browsing can be trusted.",
        "impact": "An attacker could use social engineering to get a victim to click a link to the application, so that the user will be immediately redirected to another site of the attacker's choice. An attacker can then craft a destination website to fool the victim; for example - they may craft a phishing website with an identical looking UI as the previous website's login page, and with a similar looking URL, convincing the user to submit their access credentials in the attacker's website. Another example would be a phishing website with an identical UI as that of a popular payment service, convincing the user to submit their payment information.",
        "mitigation": "1. Ideally, do not allow arbitrary URLs for redirection. Instead, create a mapping from user-provided parameter values to legitimate URLs.\n2. If it is necessary to allow arbitrary URLs:\n\t* For URLs inside the application site, first filter and encode the user-provided parameter, and then either:\n\t\t+ Create a white-list of allowed URLs inside the application\n\t\t+ Use variables as a relative URL as an absolute one, by prefixing it with the application site domain - this will ensure all redirection will occur inside the domain\n\t* For URLs outside the application (if necessary), either:\n\t\t+ White-list redirection to allowed external domains by first filtering URLs with trusted prefixes. Prefixes must be tested up to the third slash [/] - `scheme://my.trusted.domain.com/,` to prevent evasion. For example, if the third slash [/] is not validated and scheme://my.trusted.domain.com is trusted, the URL scheme://my.trusted.domain.com.evildomain.com would be valid under this filter, but the domain actually being browsed is evildomain.com, not domain.com.\n\t\t+ For fully dynamic open redirection, use an intermediate disclaimer page to provide users with a clear warning that they are leaving the site."
    },
    "dynamic set of null securitymanager": {
        "title": "Dynamic Set Of Null SecurityManager",
        "desc": "The SecurityManager is a class that allows applications to implement a security policy.\nWeb applications can take advantage of the Java Security Manager to avoid potentially dangerous actions according to its active security policy.",
        "impact": "Manually disabling the Java Security Manager (by setting it to null) removes the security hardening of the security policy, potentially opening new attack vectors to attackers in the web application.",
        "mitigation": "It is good practice to either completely disallow changing the Java security manager when the application starts, by initializing the application with option -Djava.security.manager=\"disallow\" or to extend the SecurityManger class with overridden check methods that fulfill the application security policy requirements."
    },
    "utf7 xss": {
        "title": "UTF7 XSS",
        "desc": "Application code sets the response header for charset to UTF-7, indicating to older browsers to decode UTF-7 characters. These UTF-7 characters could be decoded into HTML meta-characters, resulting in XSS.",
        "impact": "UTF-7 encoding is a form of encoding for special characters using ASCII characters. However, the way with which UTF-7 represents certain HTML characters is using normal non-meta-characters, which could allow bypassing HTML encoding and performing an XSS attack on the web-page.\n\n\nFor example, consider the following UTF-7 string:\n+ADw-script+AD4- alert(123)+ADw-/script+AD4-\n\n\nThis string, under UTF-7 encoding, will indicate to the browser to decode it as `<script>alert(123)</script>` , which would result in an XSS on browsers that support it.",
        "mitigation": "Avoid using UTF-7 as a web-page character-set encoding."
    },
    "information exposure through an error message": {
        "title": "Information Exposure Through an Error Message",
        "desc": "The application handles exceptions in an insecure manner, including raw details directly in the error message. This could occur in various ways: by not handling the exception; printing it directly to the output or file; explicitly returning the exception object; or by configuration. These exception details may include sensitive information that could leak to the users due to the occurrence of the runtime error.",
        "impact": "Exposed details about the application\u2019s environment, users, or associated data (for example, stack trace) could enable an attacker to find another flaw and help the attacker to mount an attack. This may also leak sensitive data, e.g. passwords or database fields.",
        "mitigation": "* Do not expose exception data directly to the output or users, instead return an informative, generic error message. Log the exception details to a dedicated log mechanism.\n* Any method that could throw an exception should be wrapped in an exception handling block that:\n\t+ Explicitly handles expected exceptions.\n\t+ Includes a default solution to explicitly handle unexpected exceptions.\n* Configure a global handler to prevent unhandled errors from leaving the application."
    },
    "use of broken or risky cryptographic algorithm": {
        "title": "Use of Broken or Risky Cryptographic Algorithm",
        "desc": "The application code specifies the name of the selected cryptographic algorithm, either via a String argument, a factory method, or a specific implementation class. These algorithms have fatal cryptographic weaknesses, that make it trivial to break in a reasonable timeframe. Strong algorithms should withstand attacks far beyond the realm of possible.",
        "impact": "Using a weak or broken algorithm ruins the protection granted by using cryptographic mechanisms in the first place, harming the confidentiality or integrity of sensitive user data. This could allow an attacker to steal secret information, alter sensitive data, or forge the source of modified messages.",
        "mitigation": "* Only use strong, approved cryptographic algorithms, including AES, RSA, ECC, and SHA-256 respectively, amongst others.\n* Do not use weak algorithms that are considered completely broken, such as DES, RC4, and MD5, amongst others.\n* Avoid, where possible, using legacy algorithms that are not considered \"future-proof\" with sufficient safety margins, even though they are considered \"safe enough\" for today. This includes algorithms that are weaker than they should be, and have stronger replacements, even if they are not yet fatally broken - such as SHA-1, 3DES,\n* Consider using a relevant official set of classifications, such as NIST or ENISA. If possible, use only FIPS 140-2 certified algorithm implementations."
    },
    "potential use of hard coded cryptographic key": {
        "title": "Potential Use of Hard coded Cryptographic Key",
        "desc": "The application code uses an encryption key to encrypt and decrypt sensitive data. While it is important to create this encryption key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code.\u00a0\n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text encryption key and use it to decrypt the sensitive data that the application was protecting.",
        "impact": "Static, unchangeable encryption keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the encryption key, this can be used to gain access to any encrypted secret data, thus violating the confidentiality of the data. Furthermore, it would be impossible to replace the encryption key once stolen. Note that if this is\u00a0a product that can be installed numerous times, the encryption key will always be the same, allowing an attacker to break all instances at the same cost.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as encryption keys, in plain text.\n* Never\u00a0hardcode encryption keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove the hardcoded encryption key from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "potential hardcoded password in connection string": {
        "title": "Potential Hardcoded password in Connection String",
        "desc": "The application has the database password hardcoded in the source code files, and uses this password in a connection string to the database or other server. This password is visible to anyone with access to source code, and cannot be changed without rebuilding or recompiling the application. Even after compilation or deployment, the password and connection string are still present in the binary program files or production environment.",
        "impact": "Hardcoded database passwords expose the application to password leakage, and the database to unauthorized access. If an attacker gains access to the source code (or can decompile the application binaries), the attacker will be able to steal the embedded passwords, and use them to directly access the database. This would enable the attacker to steal secret information, modify sensitive records, or delete important data.\u00a0\n\n\nIn addition, the password cannot be easily changed when required. In the eventual situation wherein it is a necessity to update the password, a new version of the application would need to be built and deployed to production systems.",
        "mitigation": "- Never hardcode sensitive data, such as database passwords.\u00a0\n\u00a0- Prefer to avoid requiring an explicit database password at all, instead using OS-integrated system authentication.\n\u00a0- Alternatively, store the password in an encrypted configuration file, and implement a mechanism enabling administrators to change the password. Ensure the file permissions are configured to restrict access to administrators only.\n\u00a0- In particular, if the database supports Integrated Authentication or Kerberos, prefer to use this over explicit credentials for the SQL user.\u00a0\n\u00a0- If possible, configure the JDBC URL with \"`integratedSecurity=true;`\" and \"`authenticationScheme=JavaKerberos`\" .\n\u00a0- Alternatively, define the database password and JDBC connection parameters in an encrypted configuration file, e.g. a\u00a0`.properties` file.\u00a0\n\u00a0- Ideally, leverage the Java Application Server infrastructure to\u00a0protect the database password\u00a0using a specific container-provided mechanism, e.g. Oracle's `Wallet`, WebSphere's `security.xml` with `CustomPasswordEncryption`, or JBoss' `SecureIdentityLoginModule`."
    },
    "cgi reflected xss all clients": {
        "title": "CGI Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use legitimate access to the application to submit modified data, which would be returned as output without proper sanitization. This would then be used to dynamically generate output to a generic output writer - in some scenarios, such as with CGI scripts, this output is sent directly to the user's browser, which would trigger the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "stored command argument injection": {
        "title": "Stored Command Argument Injection",
        "desc": "A potentially tainted value is passed as an argument to an external program, which is executed by code.",
        "impact": "The impact of an attacker-controlled argument passed to an external program depends on the functionality, capability, implementation and permissions granted to this program. Invoking a program that allows OS commands may allow command injection, an external compiler or interpreter may allow for code injection or a file path can be manipulated to allow path traversal. In other cases, the external program may itself be vulnerable to attack, such as a buffer overflow.",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege."
    },
    "command argument injection": {
        "title": "Command Argument Injection",
        "desc": "A potentially tainted value is passed as an argument to an external program, which is executed by code.",
        "impact": "The impact of an attacker-controlled argument passed to an external program depends on the functionality, capability, implementation and permissions granted to this program. Invoking a program that allows OS commands may allow command injection, an external compiler or interpreter may allow for code injection or a file path can be manipulated to allow path traversal. In other cases, the external program may itself be vulnerable to attack, such as a buffer overflow.",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege."
    },
    "cgi stored xss": {
        "title": "CGI Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into some data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use legitimate access to the application to submit modified data, which would be saved by the application to some data-store. This stored data would then be used to dynamically generate output to a generic output writer - in some scenarios, such as with CGI scripts, this output will be sent directly to the user's browser, which would trigger the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "cross site history manipulation": {
        "title": "Cross Site History Manipulation",
        "desc": "Modern browsers expose the user's browsing history to local JavaScript as a stack of previously visited URLs. While the browsers enforce a strict Same Origin Policy (SOP) to prevent pages from one website from reading visited URLs on other websites, the History object does leak the size of the history stack. Using only this information, in some situations the attacker can discover the results of certain checks the application server performs.\n\n\nFor example - if the application redirects an unauthenticated user to the login page, a script on another website can detect whether or not the\u00a0user is logged in, by checking the length of the history object.\u00a0This is done by first making a request to the page being redirected to (e.g. \"/login\"), then replacing that with a redirecting page that only redirects users if that user is not yet authenticated (e.g. \"/profile\") - if the length of history object remains the same, redirection has occurred back to the page being redirected to, and the history stack is not updated. If the history stack length is updated, that means the page did not redirect the user, causing the new page to be stored in the history stack.\n\n\nThis information leakage is enabled when the application redirects the user's browser based on the value of some condition, the state of the user's server-side session. e.g. whether the user is authenticated to the application, if the user has visited a certain page with specific parameters, or the value of some application data.\n\n\nNote that this issue does not affect all browsers, and depends on the browser's implementation of Javascript's history object behavior.",
        "impact": "An attacker could compromise the browser's Same Origin Policy and violate a user's privacy, by manipulating the browser's History object in JavaScript. This could allow the attacker in certain situations to detect whether the user is logged in, track the user's activity, or infer the\u00a0state of other conditional values. This may also enhance Cross Site Request Forgery (XSRF) attacks, by leaking the result of the initial attack.",
        "mitigation": "* Add the response header \"X-Frame-Options: DENY\" to all sensitive pages in the application, to protect against the IFrame version of XSHM in modern browser versions.\n* Add a random value to all redirection URLs as a parameter to ensure that they are unique when inserted into the history stack"
    },
    "db parameter tampering": {
        "title": "DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "dos by sleep": {
        "title": "DoS by Sleep",
        "desc": "The application uses a user-provided value to set its sleep period, without enforcing a limited range for this value.",
        "impact": "An attacker could provide a very high sleep value, effectively causing a denial of service for a long period of time.\n\n\nThis can keep server resources busy and, if triggered consecutively, cause the server to stop responding and become unavailable to users.",
        "mitigation": "1. Ideally, the sleep command\u2019s duration should not be be according to user input at all. It should be either hardcoded, defined in a configuration file, or dynamically calculated at runtime.\n2. If it is necessary to allow the user to define the sleep duration, this value MUST be checked and enforced to be within a predefined range of valid values."
    },
    "jwt use of none algorithm": {
        "title": "JWT Use Of None Algorithm",
        "desc": "The none algorithm was intended for cases where the integrity of the token was already verified. When the none algorithm is used and coupled with poor verification steps, unsigned tokens will be considered as valid tokens. Furthermore, if the verification algorithm uses the alg claim provided in the token header, they will likely skip the signature validation since the none algorithm does not contain a signature for validation.",
        "impact": "If the system uses JWT with the none algorithm a malicious user could create his own valid token. While using the none algorithm no signature will be present in the JWT token, since there is no signature to guarantee data integrity anyone can forge the JWT body with whatever claims they wish. This will result in an authentication bypass and/or arbitrary account takeover.",
        "mitigation": "* Make sure that the none algorithm is not used in any part of your JWT creation code.\n* Be careful with implementation cases where there is explicitly a need to set the signing algorithm or the key."
    },
    "jwt lack of expiration time": {
        "title": "JWT Lack Of Expiration Time",
        "desc": "The application does not set an Expiration Time(exp) claim in the JWT.",
        "impact": "Using JWTs that do not have an Expiration Time(exp) claim poses a security risk. A leaked token will allow attackers to impersonate the affected user, as without an Expiration Time a compromised token will be valid for an unlimited period of time. Besides the user account takeover with a forever valid token, having unlimited time access to a protected system may potentially allow attackers to further exploit the system.",
        "mitigation": "* Since there is no defined mechanism to revoke a JWT the only real defense is through Expiration Time.\n* Make sure to set an Expiration Time for the created JWTs."
    },
    "jwt no signature verification": {
        "title": "JWT No Signature Verification",
        "desc": "During the JWT verification step, the application does not validate the JWT signature and only decodes/parses its claims.",
        "impact": "If during the authentication process the JWT signature is not validated, there is no way to guarantee the integrity of the data present in the JWT body making the authentication mechanism obsolete. A malicious user could then add his own content and potentially have access to other user accounts as other protected resources.",
        "mitigation": "* Make sure to use the appropriate method for JWT verification, which should contemplate signature verification.\n* Make sure that the verification method used properly checks the signature, the expiration time as all other relevant content for your application requirements."
    },
    "external control of system or config setting": {
        "title": "External Control of System or Config Setting",
        "desc": "The application receives unvalidated input from the user, and directly sets that value to the application configuration or environment settings, without properly sanitizing or constraining the input.",
        "impact": "If an external user can control the application configuration or environment settings, she can disrupt application service, or cause the application to behave unexpectedly, possibly creating\u00a0additional vulnerabilities in the application, or even causing the application to perform malicious actions.",
        "mitigation": "* Do not allow user\u00a0input,\u00a0or otherwise untrusted data, to control sensitive values, particularly configuration or environment settings.\n* Always validate data received from users, before using it for any internal use."
    },
    "use of hard coded cryptographic key": {
        "title": "Use of Hard coded Cryptographic Key",
        "desc": "The application code uses an encryption key to encrypt and decrypt sensitive data. While it is important to create this encryption key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code.\u00a0\n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text encryption key and use it to decrypt the sensitive data that the application was protecting.",
        "impact": "Static, unchangeable encryption keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the encryption key, this can be used to gain access to any encrypted secret data, thus violating the confidentiality of the data. Furthermore, it would be impossible to replace the encryption key once stolen. Note that if this is\u00a0a product that can be installed numerous times, the encryption key will always be the same, allowing an attacker to break all instances at the same cost.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as encryption keys, in plain text.\n* Never\u00a0hardcode encryption keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove the hardcoded encryption key from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "undocumented api": {
        "title": "Undocumented API",
        "desc": "No automatic documentation is being used or if the documentation is being manually specified, some methods are not being correctly documented.",
        "impact": "Undocumented or outdated documentation on API endpoints make it more difficult to find and/or fix vulnerabilities.",
        "mitigation": "Generate documentation automatically by adopting open standards. Include the documentation build in your CI/CD pipeline.\nDocument all aspects of your API such as authentication, errors, redirects, rate limiting, cross-origin resource sharing (CORS) policy and endpoints, including their parameters, requests, and responses."
    },
    "hardcoded password in connection string": {
        "title": "Hardcoded password in Connection String",
        "desc": "The application has the database password hardcoded in the source code files, and uses this password in a connection string to the database or other server. This password is visible to anyone with access to source code, and cannot be changed without rebuilding or recompiling the application. Even after compilation or deployment, the password and connection string are still present in the binary program files or production environment.",
        "impact": "Hardcoded database passwords expose the application to password leakage, and the database to unauthorized access. If an attacker gains access to the source code (or can decompile the application binaries), the attacker will be able to steal the embedded passwords, and use them to directly access the database. This would enable the attacker to steal secret information, modify sensitive records, or delete important data.\u00a0\n\n\nIn addition, the password cannot be easily changed when required. In the eventual situation wherein it is a necessity to update the password, a new version of the application would need to be built and deployed to production systems.",
        "mitigation": "- Never hardcode sensitive data, such as database passwords.\u00a0\n\u00a0- Prefer to avoid requiring an explicit database password at all, instead using OS-integrated system authentication.\n\u00a0- Alternatively, store the password in an encrypted configuration file, and implement a mechanism enabling administrators to change the password. Ensure the file permissions are configured to restrict access to administrators only.\n\u00a0- In particular, if the database supports Integrated Authentication or Kerberos, prefer to use this over explicit credentials for the SQL user.\u00a0\n\u00a0- If possible, configure the JDBC URL with \"`integratedSecurity=true;`\" and \"`authenticationScheme=JavaKerberos`\" .\n\u00a0- Alternatively, define the database password and JDBC connection parameters in an encrypted configuration file, e.g. a\u00a0`.properties` file.\u00a0\n\u00a0- Ideally, leverage the Java Application Server infrastructure to\u00a0protect the database password\u00a0using a specific container-provided mechanism, e.g. Oracle's `Wallet`, WebSphere's `security.xml` with `CustomPasswordEncryption`, or JBoss' `SecureIdentityLoginModule`."
    },
    "http response splitting": {
        "title": "HTTP Response Splitting",
        "desc": "Since user input is being used in an HTTP response header, an attacker could include NewLine characters to make the header look like multiple headers with engineered content, potentially making the response look like multiple responses (for example, by engineering duplicate content-length headers). This can cause an organizational proxy server to provide the second, engineered response to a victim\u2019s subsequent request; or, if the proxy server also performs response caching, the attacker can send an immediate subsequent request to another site, causing the proxy server to cache the engineered response as a response from this second site and to later serve the response to other users.\n\n\nMany modern web frameworks mitigate this issue, by offering sanitization for new line characters in strings inserted into headers by default. However, since many older versions of web frameworks fail to automatically mitigate this issue, manual sanitization of input may be required.",
        "impact": "If the header setting code is of a vulnerable version, an attacker could:\n\n* Arbitrarily change the application server\u2019s response header to a victim\u2019s HTTP request by manipulating headers\n* Arbitrarily change the application server\u2019s response body by injecting two consecutive line breaks, which may result in Cross-Site Scripting (XSS) attacks\n* Cause cache poisoning, potentially controlling any site\u2019s HTTP responses going through the same proxy as this application.",
        "mitigation": "1. Validate all input, regardless of source (including cookies). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Additionally, remove or URL-encode all special (non-alphanumeric) user input before including it in the response header.\n3. Make sure to use an up-to-date framework."
    },
    "use of system exit": {
        "title": "Use of System exit",
        "desc": "Invocation of an exit method would immediately shut down the application.",
        "impact": "If an exit method can be invoked through some logical flow within the application, it will cause a prompt Denial-of-Service (DoS).",
        "mitigation": "Avoid using exit methods. Either handle any errors or exceptions, or configure the application to terminate in a timely manner."
    },
    "jwt sensitive information exposure": {
        "title": "JWT Sensitive Information Exposure",
        "desc": "The application stores data, which may contain PII (Personally Identifiable Information) or other sensitive data in the JWT body. JWTs do not provide any form of data confidentiality, all the data that is included in the token is public and an attacker can simply decode its content to retrieve all the included data.",
        "impact": "A malicious user that has access to any user's token, will be able to retrieve the stored information, such as user personal data (PII) and any other sensitive data from the JWT body. This would be detrimental to the user and harm their privacy and even lead to identity theft. Such violation could cause damage to reputation as financial loss for the affected companies.",
        "mitigation": "* JWTs are not suitable for storing sensitive data.\n* Remove any PII or secrets that are being included in the JWT body.\n* In case you need to encrypt data within JWTs use JWE(JSON Web Encryption)."
    },
    "jwt excessive expiration time": {
        "title": "JWT Excessive Expiration Time",
        "desc": "The application uses an excessive Expiration Time(exp) for the created JWTs.",
        "impact": "Using JWTs with an excessive Expiration Time(exp) claim poses a security risk. A leaked token will allow attackers to impersonate the affected user, with an excessive Expiration Time a compromised token will allow attackers to further explore the system and potentially conduct more attacks since his window for action, is bigger.",
        "mitigation": "* Keep in mind that long-lived tokens are generally a poor security practice.\n* Token expiration times are usually a tradeoff between the exposure period of a leaked token and the application usability.\n* There is no ideal expiration time as this is a context-dependent issue. We recommend not using tokens that are valid for longer than 24 hours or 86400 seconds.\n* Depending on your security requirements this value can be much shorter. Multiple organizations set this time period to 15 to 30 minutes."
    },
    "suspicious endpoints": {
        "title": "Suspicious Endpoints",
        "desc": "In some frameworks, such endpoints allows the user to monitor and interact with the framework application. On this case, the user should avoid use the keywords such as *debug*, *dev*, *test*, *old\\_** or *secret*",
        "impact": "The code contains words that suggest the presence of bugs, incomplete functionality, or weaknesses.",
        "mitigation": "In production is recommended to not use the above keywords."
    },
    "improper locking": {
        "title": "Improper Locking",
        "desc": "In order to improve performance and raise throughput, the application has several threads performing operations in parallel. In certain situations, sensitive methods need to ensure that other threads are not interferring with the integrity of their operations or data. To do so, these methods need to acquire a lock (commonly known as mutex, monitor, or other types) to synchronize access between threads.\n\n\nHowever, in this case, the synchronization lock is never unlocked, and can cause the other threads to continuously await its release indefinitely.",
        "impact": "Incomplete management of explicit thread locking can lead to deadlocked threads, wherein one thread (or several) is blocked while waiting for the other thread to release it's lock - which will\u00a0never happen, causing the other threads to be disabled indefinitely. This could also cause the application to\u00a0consume other resources indefinitely, without releasing them. At the very least, this flaw will severly limit throughput of the application, by blocking the multithreaded operations.",
        "mitigation": "* Always ensure any synchronization locks are explicitly released.\n* In particular, use strucutured error handling to ensure that the locks are released even after runtime exceptions.\n* Avoid manual locking, if\u00a0possible, instead using\u00a0automatic\u00a0locking via\u00a0synchronized blocks and methods where available."
    },
    "information exposure through query string": {
        "title": "Information Exposure Through Query String",
        "desc": "A password is being sent in a GET request as a query string parameter, either via concatenation of the password value to a URL, or by sending the password as a parameter in a GET request.\u00a0 Sending parameters in a GET request is caused either by explicitly setting the method to GET, or implicitly by using a mechanism that defaults to a GET request without changing the method to another method (such as POST).",
        "impact": "Sending sensitive information in a GET parameter as part of the URL's query string will result in this information potentially becoming cached by the browser, proxies, web-caches or be written into access logs. An attacker with access to any of the above will be able to retrieve this sensitive information.",
        "mitigation": "* Never send sensitive information in the URL. This includes:\n\t+ Credentials\n\t+ Session or access tokens\n\t+ Personal information"
    },
    "jwt use of hardcoded secret": {
        "title": "JWT Use Of Hardcoded Secret",
        "desc": "The application code uses JWT with a secret key to sign the issued tokens. While it is important to create this key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code. \n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text key and use it to issue valid tokens for the system that the JWT was protecting.",
        "impact": "Static, unchangeable secret keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the secret, this can be used to create valid JWTs that will be accepted by the application. An attacker in such a position can forge JWTs with the content of his choice bypassing authentication and authorization mechanisms that are dependent on such a secret.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as secret keys, in plain text.\n* Never hardcode secret keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove hardcoded keys from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "parameter tampering": {
        "title": "Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "excessive data exposure": {
        "title": "Excessive Data Exposure",
        "desc": "The API returns an object with potentially sensitive data-fields, without excluding, filtering or nullifying said sensitive data - thus exposing it in an API response.",
        "impact": "APIs often respond with objects for a client to consume and, at times, these objects may contain more information than the client requires or intends to use. If the object returned to the client has this excess data, and that data is sensitive, it would be exposed to potentially malicious clients of the API.",
        "mitigation": "* When returning objects that hold data from an API, always consider the types and contexts of data being returned - such as whether or not it is required by the API's consumers, and whether or not it is sensitive\n* Opt to white-list allowed data to be in control of data flow and remove excess"
    },
    "spring use of broken or risky cryptographic primitive": {
        "title": "Spring Use of Broken or Risky Cryptographic Primitive",
        "desc": "The application code specifies the name of the selected cryptographic algorithm, either via a String argument, a factory method, or a specific implementation class. These algorithms have fatal cryptographic weaknesses, that make it trivial to break in a reasonable timeframe. Strong algorithms should withstand attacks far beyond the realm of possible.",
        "impact": "Using a weak or broken algorithm ruins the protection granted by using cryptographic mechanisms in the first place, harming the confidentiality or integrity of sensitive user data. This could allow an attacker to steal secret information, alter sensitive data, or forge the source of modified messages.",
        "mitigation": "* Only use strong, approved cryptographic algorithms, including AES, RSA, ECC, and SHA-256 respectively, amongst others.\n* Do not use weak algorithms that are considered completely broken, such as DES, RC4, and MD5, amongst others.\n* Avoid, where possible, using legacy algorithms that are not considered \"future-proof\" with sufficient safety margins, even though they are considered \"safe enough\" for today. This includes algorithms that are weaker than they should be, and have stronger replacements, even if they are not yet fatally broken - such as SHA-1, 3DES,\n* Consider using a relevant official set of classifications, such as NIST or ENISA. If possible, use only FIPS 140-2 certified algorithm implementations."
    },
    "spring comparison timing attack": {
        "title": "Spring Comparison Timing Attack",
        "desc": "The method used to store the credentials is insecure.\n\n\nRegular comparison operations are usually optimized for performance. When these comparison methods operate over strings, they iterate each character on the two strings and if they find a difference they immediately break and return a false result for the comparison. The problem with this is the unintended side-channel vector that is created by an attacker who can control one of the comparison terms. Let's assume the challenge to break is \"AAA\". An attacker who is aware of the timing side-channel may send \"BAA\" and later send \"ABA\", noticing a slight increase in the average time taken to return the comparison result, simply because the comparison loop over each character on the strings now performs two iterations instead of only one (failing on the first character).",
        "impact": "Using an insecure form of credential storage could expose\u00a0users' and/or administrators' credentials to brute-force, rainbow-table and other types of attacks.\n\n\nEven if the application is using a secure\u00a0credential storage mechanism, it's still possible to implement the solution in an insecure manner and reduce the security of the credentials stored.\n\n\nUsing a non-constant-time comparison between hashes or passwords may cause a side-channel data leakage. A sophisticated attacker may be able to retrieve the challenge string by building a statistical model of the timing differences between carefully chosen authentication attempts.",
        "mitigation": "Credential storage, namely passwords, should be carefully done by using a password hashing function. Most hashing functions have been created with speed as a pre-requisite, to create cryptographically secure hashes for file integrity and other purposes, making them ill fit for direct use with passwords; other functions\u00a0have been broken in the past due to collisions or other security problems (MD5, SHA-1, etc\u2026) .\n\n\nOur recommendations for secure credential storage functions include:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2 (for legacy compatibility only)\n\n\nSecure hash comparison can be achieved in Java by using MessageDigest.isEqual.\n\n\nIn Spring, all implementations of the PasswordEncoder interface supply a `PasswordEncoder.matches` method, which implements a constant time comparison that can be used to correct this issue."
    },
    "privacy violation": {
        "title": "Privacy Violation",
        "desc": "The application sends user information, such as passwords, account information, or credit card numbers, outside the application, such as writing it to a local text or log file or sending it to an external web service.",
        "impact": "A user\u2019s personal information could be stolen by a malicious programmer, or an attacker that intercepts the data.",
        "mitigation": "1. Personal data should be removed before writing to logs or other files.\n2. Review the need and justification of sending personal data to remote web services."
    },
    "spring missing object level authorization": {
        "title": "Spring Missing Object Level Authorization",
        "desc": "Lack of spring-security configuration in the backend; Easily predictable object Ids in the application's frontend.",
        "impact": "The user may try to access objects that need an authorization level that the user shouldn't have, by guessing the object's id.",
        "mitigation": "Use Spring-Security annotations according to the desired Spring-Security configuration in order to safely create methods with an Authorization layer."
    },
    "spring missing function level authorization": {
        "title": "Spring Missing Function Level Authorization",
        "desc": "Lack of spring-security configuration in the backend; Easily predictable object Ids in the application's frontend.",
        "impact": "The user may try to access objects that need an authorization level that the user shouldn't have, by guessing the object's id.",
        "mitigation": "Use Spring-Security annotations according to the desired Spring-Security configuration in order to safely create methods with an Authorization layer."
    },
    "spring pbkdf2 insecure parameters": {
        "title": "Spring PBKDF2 Insecure Parameters",
        "desc": "The method used to store the credentials is insecure.",
        "impact": "Using an insecure form of credential storage could expose\u00a0users' and/or administrators' credentials to brute-force, rainbow-table and other types of attacks.\n\n\nEven if the application is using a secure\u00a0credential storage mechanism, it's still possible to implement the solution in an insecure manner and reduce the security of the credentials stored.",
        "mitigation": "Credential storage, namely passwords, should be carefully done by using a password hashing function. Most hashing functions have been created with speed as a pre-requisite, to create cryptographically secure hashes for file integrity and other purposes, making them ill fit for direct use with passwords; other functions\u00a0have been broken in the past due to collisions or other security problems (MD5, SHA-1, etc\u2026) .\n\n\nOur recommendations for secure credential storage functions include:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2 (for legacy compatibility only)\n\n\nUse the default recommended parameters, otherwise follow the parameter selection recommendations defined by the authors of the algorithms.\n\n\nPBKDF2 is recommended only for legacy uses, consider updating to a more secure solution.\n\n\nWhen using PBKDF2 the following values for its parameters are recommended:\n\n\nIteration Count\n\n* *10,000*\n\n\nLength of salt used\n\n* *At least 32bits*"
    },
    "spring bcrypt insecure parameters": {
        "title": "Spring BCrypt Insecure Parameters",
        "desc": "The method used to store the credentials is insecure.",
        "impact": "Using an insecure form of credential storage could expose\u00a0users' and/or administrators' credentials to brute-force, rainbow-table and other types of attacks.\n\n\nEven if the application is using a secure\u00a0credential storage mechanism, it's still possible to implement the solution in an insecure manner and reduce the security of the credentials stored.",
        "mitigation": "Credential storage, namely passwords, should be carefully done by using a password hashing function. Most hashing functions have been created with speed as a pre-requisite, to create cryptographically secure hashes for file integrity and other purposes, making them ill fit for direct use with passwords; other functions\u00a0have been broken in the past due to collisions or other security problems (MD5, SHA-1, etc\u2026) .\n\n\nOur recommendations for secure credential storage functions include:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2 (for legacy compatibility only)\n\n\nUse the default recommended parameters, otherwise follow the parameter selection recommendations defined by the authors of the algorithms.\n\n\nWhen using bcrypt the following values for its parameters are recommended:\n\n\nOverall Computation cost (2^c):\n\n* greater than 12"
    },
    "spring argon2 insecure parameters": {
        "title": "Spring Argon2 Insecure Parameters",
        "desc": "The method used to store the credentials is insecure.",
        "impact": "Using an insecure form of credential storage could expose\u00a0users' and/or administrators' credentials to brute-force, rainbow-table and other types of attacks.\n\n\nEven if the application is using a secure\u00a0credential storage mechanism, it's still possible to implement the solution in an insecure manner and reduce the security of the credentials stored.",
        "mitigation": "Credential storage, namely passwords, should be carefully done by using a password hashing function. Most hashing functions have been created with speed as a pre-requisite, to create cryptographically secure hashes for file integrity and other purposes, making them ill fit for direct use with passwords; other functions\u00a0have been broken in the past due to collisions or other security problems (MD5, SHA-1, etc\u2026) .\n\n\nOur recommendations for secure credential storage functions include:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2 (for legacy compatibility only)\n\n\nUse the default recommended parameters, otherwise follow the parameter selection recommendations defined by the authors of the algorithms.\n\n\nWhen using Argon2 the following parameters are recommended:\n\n\nNumber of Lanes (h):\n\n* *Double the number of CPUs*\n\n\nAmount of memory to be used (m):\n\n* *Backend Authentication - 4GiB*\n* *Frontend Authentication - 1GiB*\n* *Hard-drive Encryption Key - 6GiB*"
    },
    "spring scrypt insecure parameters": {
        "title": "Spring SCrypt Insecure Parameters",
        "desc": "The method used to store the credentials is insecure.",
        "impact": "Using an insecure form of credential storage could expose\u00a0users' and/or administrators' credentials to brute-force, rainbow-table and other types of attacks.\n\n\nEven if the application is using a secure\u00a0credential storage mechanism, it's still possible to implement the solution in an insecure manner and reduce the security of the credentials stored.",
        "mitigation": "Credential storage, namely passwords, should be carefully done by using a password hashing function. Most hashing functions have been created with speed as a pre-requisite, to create cryptographically secure hashes for file integrity and other purposes, making them ill fit for direct use with passwords; other functions\u00a0have been broken in the past due to collisions or other security problems (MD5, SHA-1, etc\u2026) .\n\n\nOur recommendations for secure credential storage functions include:\n\n* Argon2\n* scrypt\n* bcrypt\n* PBKDF2 (for legacy compatibility only)\n\n\nUse the default recommended parameters, otherwise follow the parameter selection recommendations defined by the authors of the algorithms.\n\n\nWhen using scrypt the following values for its parameters are recommended:\n\n\nCPU/Memory cost (N):\n\n* *2^14*\n\n\nInternal block size (r):\n\n* *8*\n\n\nParallel lanes (p):\n\n* *1*"
    },
    "redos from regex injection": {
        "title": "ReDoS From Regex Injection",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "spring use of hardcoded password": {
        "title": "Spring Use Of Hardcoded Password",
        "desc": "The application codebase\u00a0has string literal passwords embedded in the source code. This hardcoded value is used either to compare to user-provided credentials, or to authenticate downstream to a remote system (such as a database or a remote web service). \u00a0\n\n\nAn attacker only needs to gain access to the source code to reveal the hardcoded password. Likewise, the attacker can reverse engineer the compiled application binaries, and easily retrieve the embedded password. Once found, the attacker can easily use the password in impersonation attacks, either directly on the application or to the remote system.\u00a0\n\n\nFurthermore, once stolen, this password cannot be easily changed to prevent further misuse, unless a new version of the application is compiled. Moreover, if this application is distributed to numerous systems, stealing the password from one system automatically allows a class break in to all the deployed systems.",
        "impact": "Hardcoded passwords expose the application to password leakage. If an attacker gains access to the source code, she will be able to steal the embedded passwords, and use them to impersonate a valid user. This could include impersonating end users to the application, or impersonating the application to a remote system, such as a database or a remote web service.\u00a0\n\n\nOnce the attacker succeeds in impersonating the user or application, she will have full access to the system, and be able to do anything the impersonated identity could do.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not passwords.\n* In particular, user passwords should be stored in a\u00a0database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2). Do not compare user passwords with a hardcoded value.\n* Sytem passwords should be stored in a configuration file or the database, and protected with strong encryption (e.g. AES-256). Encryption keys should be securely managed, and not hardcoded."
    },
    "redos in match": {
        "title": "ReDoS In Match",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "redos in pattern": {
        "title": "ReDoS In Pattern",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "spring xsrf": {
        "title": "Spring XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid.\n\n\nSpring Security automatically enables Cross-Site Request Forgery protection when added to the classpath.\nWhen using form login and basic authentication, XSRF protection is required."
    },
    "redos in replace": {
        "title": "ReDoS In Replace",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"\n\n\nThe application utilizes a regex that is known to take a very long time, given certain values to match on; however these values are obtained from user input, allowing them to trigger this denial-of-service.",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "spring overly permissive cross origin resource sharing policy": {
        "title": "Spring Overly Permissive Cross Origin Resource Sharing Policy",
        "desc": "Modern browsers, by default, disallow resource sharing between different domains from accessing one another's DOM contents, cookie jars and other resources, specifically to prevent malicious web-applications from attacking legitimate web-applications and their users as part of the Same-Origin Policy (SOP). For example - website A cannot retrieve contents of website B by default, as that is a breach of the SOP. The Cross-Origin Resource Sharing (CORS) policy, defined by specific headers, allows loosening this strict default behavior to enable cross-site communications. However, when used incorrectly, CORS may enable\u00a0unintended and potentially malicious behavior by allowing an overly broad trust of web-applications that may submit requests and retrieve responses from the web-application.\n\n\nThe Access-Control-Allow-Origin is incorrectly set to an unsafe value in code.",
        "impact": "A Cross-Origin Resource Sharing (CORS) header,\u00a0\"Access-Control-Allow-Origin\", that is overly permissive may allow scripts from other web-sites to access, and often manipulate, resources on the affected web-application. These resources may include page contents, tokens and more, allowing potential Cross-Site Request Forgery (CSRF) or Cross-Site Scripting (XSS) attacks, performing actions on a user's behalf such as changing their password, or allow breach of user privacy.",
        "mitigation": "Where not explicitly required, do not set any CORS headers. Where required, consider business needs for setting these headers, and opt for the most restrictive configuration possible, such as white-listing trusted, secure and allowed domains access, while\u00a0utilizing other CORS headers to strictly provide required and expected functionality.\n\n\nSpring Security has a built-in mechanism to configure the CORS header using the @CrossOrigin annotation.\n\n\nSpring's default allowed origin is overly permissive and it is recommended to manually specify the allowed origins."
    },
    "spring missing hsts header": {
        "title": "Spring Missing HSTS Header",
        "desc": "Many users browse to websites by simply typing the domain name into the address bar, without the protocol prefix. The browser will automatically assume that the user's intended protocol is HTTP, instead of the\u00a0encrypted HTTPS protocol.\n\n\nWhen this initial request is made, an attacker can perform a Man-in-the-Middle attack and manipulate it to redirect users to a malicious web-site of the attacker's choosing. To protect the user from such an occurence, the HTTP Strict Transport Security (HSTS) header instructs the user's browser to disallow use of an unsecure HTTP connection to the the domain associated with the HSTS header.\n\n\nOnce\u00a0a browser that supports the HSTS feature has visited a web-site and the header was set, it will no longer allow\u00a0communicating with the domain over an HTTP connection.\n\n\nOnce an HSTS header was issued for a specific website, the browser is also instructed\u00a0to prevent users from manually overriding and accepting an untrusted SSL certificate for as long as the \"max-age\" value still applies. The recommended \"max-age\" value is for at least one year in seconds, or 31536000.",
        "impact": "Failure to set an HSTS header and provide it with a reasonable \"max-age\" value of at least one year may leave users vulnerable to Man-in-the-Middle attacks.",
        "mitigation": "* Before setting the HSTS header - consider the implications it may have:\n\t+ Forcing HTTPS will prevent any future use of HTTP, which could hinder some testing\n\t+ Disabling HSTS is not trivial, as once it is disabled on the site, it must also be disabled on the browser\n* Set the HSTS header either explicitly within application code, or using web-server configurations.\n* Ensure the \"max-age\" value for HSTS headers is set to 31536000 to ensure HSTS is strictly enforced for at least one year.\n* Include the \"includeSubDomains\" to maximize HSTS coverage, and ensure HSTS is enforced on all sub-domains under the current domain\n\t+ Note that this may prevent secure browser access to any sub-domains that utilize HTTP; however, use of HTTP is very severe and highly discouraged, even for websites that do not contain any sensitive information, as their contents can still be tampered via Man-in-the-Middle attacks to phish users under the HTTP domain.\n* Once HSTS has been enforced, submit the web-application's\u00a0address to an HSTS preload list - this will ensure that, even if a client is accessing the web-application for the first time (implying HSTS has not yet been set by the web-application), a browser that respects the HSTS preload list would still treat the web-application as if it had already issued an HSTS header. Note that this requires the server to have a trusted SSL certificate, and issue an HSTS header with a maxAge of 1 year (31536000)\n* Note that\u00a0this query is designed to return one result per application. This means that if more than one vulnerable response without an HSTS header is identified, only the first identified instance of this issue will be highlighted as a result. If a misconfigured instance of HSTS is identified (has a short lifespan, or is missing the \"includeSubDomains\" flag), that result will be flagged. Since HSTS is required to be enforced across the entire application to be considered a secure deployment of HSTS functionality, fixing this issue only where the query highlights this result is likely to produce subsequent results in other sections of the application; therefore, when adding this header via code, ensure it is uniformly deployed across the entire application. If this header is added via configuration, ensure that this configuration applies to the entire application.\n* Note that misconfigured HSTS headers that do not contain the recommended max-age value of at least one year or the \"includeSubDomains\" flag will still return a result for a missing HSTS header."
    },
    "spring modelview injection": {
        "title": "Spring ModelView Injection",
        "desc": "ModelAndView objects can be constructed from file URIs. If these URIs can be manipulated by user inputs, they are likely susceptible to attack.",
        "impact": "ModelAndView constructors can create ModelAndView objects from file URIs that, if resolved from user input, may allow potential inclusion and disclosure of local files or bypass of application logic, by either providing a relative path or prefixing it with the \"forward:\" string. Resolving ModelAndView from user inputs may also allow\u00a0performing Open Redirect attacks, by prefixing a URL\u00a0with the \"redirect:\" string, redirect users to a website of an attacker's choosing.",
        "mitigation": "Do not resolve ModelAndView objects based on unsanitized user inputs. If dynamic ModelAndView\u00a0resolution is required, consider applying a whitelist on allowed user inputs; otherwise, only return trusted an expected ModelAndView objects based on trusted values."
    },
    "spring missing x content type options": {
        "title": "Spring Missing X Content Type Options",
        "desc": "Modern browsers have the capability of sniffing Content Types. That functionality is used even when the Content-Type header is set.\n\n\nEnabling the X-Content-Type-Options response header ensures that browsers will follow the assigned Content-Type, serving as another line of defense for XSS attacks.",
        "impact": "Failure to set an X-Content-Type-Options header using the 'nosniff' flag may leave users more susceptible to MIME Sniffing attacks, which can result in cross-site scripting attacks.",
        "mitigation": "Enabling the X-Content-Type-Options header avoids the MIME Type sniffing capabilities of browsers, avoiding possible XSS vulnerabilities."
    },
    "spring missing xss protection header": {
        "title": "Spring Missing XSS Protection Header",
        "desc": "Many modern browsers have the capability of detecting potentially dangerous reflected cross-site scripting payloads.\nEnabling the X-XSS-Protection response header ensures that browsers that support the protection will use it, serving as another line of defense for XSS attacks.",
        "impact": "Failure to set an X-XSS-Protection header using 1 as a parameter may leave users more susceptible to reflected cross-site scripting attacks.",
        "mitigation": "Enabling the X-XSS-Protection header avoids detected reflected input to execute scripts - if that is the intended behavior for the webpage, using 0 as a parameter will disable this protection.\n\n\nAs this protection is based on browser detection, note that it won't completely sanitize XSS but it will make it more difficult to exploit.\n\n\nAdding Spring Security to the Java classpath enables its default headers. As this header is active by default, add it again if the default headers are being disabled manually."
    },
    "spring missing x frame options": {
        "title": "Spring Missing X Frame Options",
        "desc": "Failure to utilize the \"X-FRAME-OPTIONS\" header will likely allow attackers to perform Clickjacking attacks. Properly utilizing the \"X-FRAME-OPTIONS\" header would indicate to the browser to disallow embedding the web-page within a frame, mitigating this risk, if the browser supports this header. All modern browsers support this header by default.",
        "impact": "Allowing setting of web-pages inside of a frame in an untrusted web-page will leave these web-pages vulnerable to Clickjacking, otherwise known as a redress attack. This may allow an attacker to redress a vulnerable web-page by setting it inside a frame within a malicious web-page. By crafting a convincing malicious web-page, the attacker can then use the overlayed redress to convince the user to click a certain area of the screen, unknowingly clicking inside the frame containing the vulnerable web-page, and thus performing actions within the user's context on the attacker's behalf.",
        "mitigation": "Utilize the \"X-FRAME-OPTIONS\" header flags according to business requirements to restrict browsers that support this header from allowing embedding web-pages in a frame:\n\n\n\u00b7 \"X-Frame-Options: DENY\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame, including the current web-site.\n\n\n\u00b7 \"X-Frame-Options: SAMEORIGIN\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame,\u00a0excluding the current web-site.\n\n\n\u00b7 \"X-Frame-Options: ALLOW-FROM https://example.com/\" will indicate to the browser to disallow embedding any web-page inside a frame,\u00a0excluding\u00a0the web-site listed after the ALLOW-FROM parameter.\n\n\nBy default, Spring Security adds this header with the DENY flag."
    },
    "spring missing content security policy": {
        "title": "Spring Missing Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are not explicitly defined, default browser behavior would allow\u00a0untrusted content.\n\n\nThe application creates web responses, but does not properly set a Content-Security-Policy header.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to\u00a0a strict\u00a0Content Security Policy, it is promptly rejected by the browser. Failure to define a policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Explicitly set the Content-Security-Policy headers for all applicable policy types (frame, script, form, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header\u00a0managed by\u00a0web-server configurations, or within `<meta>` tags in the HTML `<head>` section."
    },
    "spring permissive content security policy": {
        "title": "Spring Permissive Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are\u00a0broadly defined, they are ineffective in blocking untrusted content.\n\n\nApplication code is used to set a Content-Security-Policy; however, it sets an overly permissive policy.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to a strict Content Security Policy, it is promptly rejected by the browser. Failure to enforce strict content behavior by\u00a0policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Set the Content-Security-Policy headers for all applicable policy types (frame, frame-ancestors, script, form-actions, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header managed by\u00a0web-server configurations, and within `<meta>` tags in HTML pages' `<head>` section.\n\n\nBy default, the CSP header isn't added in Spring Security, but it can be configured using its Java and XML configurations."
    },
    "spring missing expect ct header": {
        "title": "Spring Missing Expect CT Header",
        "desc": "When using SSL/TLS, browsers validate the certificate sent by the server during the connection's handshake against the client's list of recognized CAs (Certificate Authorities). This model's security transfers the trust from the server to the CA.\n\n\nDeclaring Expect-CT header makes the supported browsers use Certificate Transparency in order to detect compromises the CAs integrity and, as defined in the header parameters, to report and/or enforce a secure connection.\n\n\nUsing Certificate Transparency with Expect-CT and the right parameters, it's possible to avoid Man-in-the-Middle attacks.",
        "impact": "Failure to set an Expect-CT header and provide it with the \"enforce\" parameter and a reasonable \"max-age\" value of at least one year may leave users vulnerable to Man-in-the-Middle attacks.",
        "mitigation": "* Before setting the Expect-CT header - consider the implications it may have:\n\t+ Enforcing Expect-CT will prevent any future use of HTTP, which could hinder some testing\n\t+ Disabling Expect-CT is not trivial, as once it is disabled on the site, it must also be disabled on the browser\n* Test your environment by setting the Expect-CT header without the 'enforce' flag in order to check if there are certificate issues - then use the 'enforce' flag\n* Set the Expect-CT header either explicitly within application code, or using web-server configurations.\n* Ensure the \"max-age\" value for Expect-CT headers is set to 31536000 to ensure the use of Certificate Transparency is strictly enforced for at least one year.\n* If this header is added via configuration, ensure that this configuration applies to the entire application.\n\n\nBy default, Spring Security doesn't add this header."
    },
    "sql injection evasion attack": {
        "title": "SQL Injection Evasion Attack",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn particular, the application decodes the user input (typically from HTML encoding format), before embedding it in the database query. Since the application decodes the input before using it, an attacker could obscure the malicious payload by encoding it before sending to the server, thus concealing the attack from most protection mechanisms. \u00a0\n\n\nThus, the input could contain SQL commands that would be interpreted as such by the database, without being detected or blocked by most countermeasures.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* In particular, all data validation should be performed after canonicalization, i.e. after the data has been decoded and simplified.\n* Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries.\n* Prefer using\u00a0`PreparedStatement`\u00a0for parameterizing the queries, or even better\u00a0`CallableStatement`. Add dynamic data via the\u00a0`.set*()`\u00a0methods, instead of string concatenation.\n* Consider using an ORM package, such as\u00a0`Hibernate`,\u00a0`myBatis`, or others."
    },
    "trust boundary violation": {
        "title": "Trust Boundary Violation",
        "desc": "Server-side Session variables, or objects, are values assigned to a specific session, which is associated with a specific user. Often, they hold data relevant to that user's session, such as specific identifiers, user-type, authorization, authentication information and more. As such, the paradigm often associated to the Session object is that its contents can be trusted, as users cannot generally set these values themselves.\u00a0\n\n\nThe application places user input, which is untrusted data, in the server-side Session object, which is considered a trusted location. This could lead developers to treat untrusted data as trusted.",
        "impact": "Code that reads from Session variables may trust them as server-side variables, but they may have been tainted by user inputs. This can lead to tampering with parameters used to authenticate or authorize users. Further, tainted Session variables offer an additional attack surface against the application - if untrusted data taints a Session variable, and that Session variable\u00a0 is then used elsewhere without sanitization as if it were trusted, it could lead to further attacks such as Cross-Site Scripting, SQL Injection and more.",
        "mitigation": "1. Validate and sanitize all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Don\u2019t mix untrusted user input with trusted data."
    },
    "xsrf": {
        "title": "XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    },
    "struts duplicate config files": {
        "title": "Struts Duplicate Config Files",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple Struts configuration files exist, creating a conflict in selecting the correct settings.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove the duplicate `struts-config.xml` file."
    },
    "struts duplicate validation files": {
        "title": "Struts Duplicate Validation Files",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple Struts Validator configuration files exist, creating a conflict in selecting the correct settings.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.\n\n\nIn particular, the Validation framework may use the wrong input validation settings, allowing an attacker to bypass protections against attacks.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove the duplicate `validation.xml` file."
    },
    "struts duplicate validation forms": {
        "title": "Struts Duplicate Validation Forms",
        "desc": "The Struts framework provides automatic, configurable input forms and data validation. The framework selects the appropriate configuration for each request. However, when multiple elements with an identical name exist, the behavior is undefined and may not behave according to expectations. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, multiple `<form>` elements with the same name will cause the Validator framework to misbehave.",
        "impact": "The Struts framework provides configurable forms and validators to structure expected input. When this framework is misconfigured, the application may behave in an unexpected manner, and can be exposed to other input-based weaknesses. Moreover, this may indicate that the application configuration is out of date and not synchronized with the code logic, which could create additional vulnerabilities.\n\n\nIn particular, the Validation framework may use the wrong input validation settings, allowing an attacker to bypass protections against attacks.",
        "mitigation": "* Properly configure all `Struts` and `Struts Validator` settings. Ensure the configuration is synchronized with the current version of the code and all code changes.\n* In particular, ensure there are no duplicate files, form beans, validation fields, or elements, in the various configuration files.\n* Remove the duplicate `<form>` elements, and ensure that no further duplicate form validators are added."
    },
    "struts incomplete validate method definition": {
        "title": "Struts Incomplete Validate Method Definition",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThe form class extends one of the validating classes, from the `ValidatorForm` set of of classes. However, while the class implements its own validate() method, it does not call the base class's validate() that it overrides. This will prevent the Validator framework from applying its own validation, and it cannot check the form input with the configured requirements.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Prefer automatic validation by configuring the form using the `validation.xml`.\n* If you implement custom validation logic, by overriding the default `validate()` method, ensure this function calls `super.validate()`."
    },
    "struts form does not extend validation class": {
        "title": "Struts Form Does Not Extend Validation Class",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn particular, in this instance an `ActionForm` class does not extend the `Validator` classes, such as `ValidatorForm`\u00a0or\u00a0`DynaValidatorActionForm`.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* All ActionForm classes should inherit specifically from the Validator classes, including `ValidatorForm`, `ValidatorActionForm`, `DynaValidatorForm`, or `DynaValidatorActionForm`."
    },
    "struts form field without validator": {
        "title": "Struts Form Field Without Validator",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThe `ValidatorForm` subclass defines form fields that can be filled out and submitted by a user. However, some of these fields do not have automatic validation configured in the Validator configuration, validation.xml, and thus will not be automatically enforced by the framework.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.\n\n\nIt is possible that even a single unvalidated form field may be sufficient for an attacker to find an exploitable entry point to enable injection attacks.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Ensure that every field of every ValidatorForm in the application will have a corresponding validation property in the Validator configuration, even when implementing custom validation logic in an overridden validate() method."
    },
    "struts non private field in actionform class": {
        "title": "Struts Non Private Field In ActionForm Class",
        "desc": "The indicated field is defined as a `public` field, instead of `private` with corresponding getter and setter methods.",
        "impact": "Public fields can be modified directly without using the getter and setter methods. This might lead to unauthorized access, data corruption, or other input-based attacks.\n\n\nIn the Struts framework, all fields of ActionForm classes must be declared private, to prevent access to these fields without the getter and setter methods.",
        "mitigation": "* Define all fields as `private`. Create a `public getFieldName()` method to retrieve the value of the field, and a `public setFieldName()` method as needed to update it.\n* In particular, all `ActionForm` class fields must be private.\n* Do not set the value of a field in an `ActionForm` from other actions, this should be used only by the framework."
    },
    "struts thread safety violation in action class": {
        "title": "Struts Thread Safety Violation In Action Class",
        "desc": "The server typically caches and reuses instances of the classes used to service requests. If an instance of the class has member variables set to user-specific information, this may be shared with the next request that accesses the instance. Thus multiple threads will be reusing the same data, passing the same checks, and crossing each others flow.\n\n\nIn particular, the Struts controller shares the same ActionClass instances between multiple requests. Since the indicated member variable is declared as an instance field, it too will be shared across all requests for the same action.",
        "impact": "Sharing instance variables between requests, and between threads, can lead to race conditions, causing unauthorized access, data corruption, and other unintended behavior.",
        "mitigation": "* Do not use instance variables to store information related to a specific user or request.\n* Synchronize access to other resources that are not thread safe.\n* Action classes must be implemented in a thread-safe manner. Instead of instance fields, declare variables in method execution scope."
    },
    "struts unvalidated action form": {
        "title": "Struts Unvalidated Action Form",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nIn this instance, the Action Form is mapped to an action in the Struts configuration file, however the Validator configuration does not define a form validation element. Thus, this Action Form class will not benefit from automatic validation.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.\n\n\nIt is possible that even a single unvalidated form may be sufficient for an attacker to find an exploitable entry point to enable injection attacks.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Ensure that every Action Form that is mapped in the application will have a corresponding `form` validation element in the Validator configuration, even when implementing custom validation logic in an overridden `validate()` method."
    },
    "struts validation turned off": {
        "title": "Struts Validation Turned Off",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThe Struts Validator plug-in can be enabled or disabled for each action mapped to be accessible via the configuration file. In this case, this mapped action has its validation disabled.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Ensure that mapping of each form action has the validation enabled, by setting validate=\"true\"."
    },
    "struts validator without form field": {
        "title": "Struts Validator Without Form Field",
        "desc": "The Struts framework provides the Struts Validator plug-in, and related set of classes, to provide automatic, configurable validation of all input. There are several different mechanisms to enable and configure the different validations, and they all help ensure that the application is protected from attacks that exploit insufficient input validation.\u00a0\n\n\nHowever, if the Validator classes are not used, or used incorrectly, there is no longer any security benefit guaranteed to the application. This could possibly expose the application to other attacks against follow-on vulnerabilities.\n\n\nThe Struts Validator configuration, validation.xml, contains validation form `<field>` elements that refer to fields that no longer exist in their respective ValidatorForm class. This is likely due to changing requirements and code refactoring, however this indicates that the validation logic is not updated in step with the code.",
        "impact": "The Struts framework provides the Validator set of mechanisms to automatically enforce configured validation on all received input. Without using this framework, the application can be exposed to other weaknesses related to insufficient input validation. An attacker may be able to find a way to bypass any manual validation, and this could lead to other input-based attacks, such as SQL Injection, cross-site scripting, XML entity expansion, and more.\n\n\nIf the validation configuration is out of date and includes fields that no longer exist in the code of the ActionForm class, it is possible that additional new fields have been added to the class in code, yet are not validated automatically because the validation is not synchronized with the code logic.",
        "mitigation": "* Use the Struts Validator capabilities to automatically enforce input validation.\n* Use the Validator classes correctly, and configure the validation as needed by your particular input fields.\n* Prefer configured automatic validation over explicit checks in code.\n* Remove the unused Validation field information from validation.xml.\n* Always update the\u00a0`Validator`\u00a0configuration together with the code of the\u00a0`ActionForm`\u00a0classes."
    }
}