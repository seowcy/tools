{
    "heuristic 2nd order sql injection": {
        "title": "Heuristic 2nd Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by updating fields in the database. Later, the application reads this data from the database, and embeds it within the SQL query, as SQL commands. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Prefer using ADODB\u00a0`Command`\u00a0and\u00a0`Parameter`\u00a0objects with the\u00a0`Command`'s\u00a0`CommandType`\u00a0property set to\u00a0`adCmdStoredProc`, to safely call a database Stored Procedure instead of dynamically executing a SQL string directly. Provide the parameters to the SP using\u00a0`Parameter`\u00a0objects, using the\u00a0`Command`'s\u00a0`CreateParameter`\u00a0and\u00a0`Parameters.Append`\u00a0methods."
    },
    "heuristic db parameter tampering": {
        "title": "Heuristic DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "heuristic parameter tampering": {
        "title": "Heuristic Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "heuristic sql injection": {
        "title": "Heuristic SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by way of altering the user input. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Prefer using ADODB\u00a0`Command`\u00a0and\u00a0`Parameter`\u00a0objects with the\u00a0`Command`'s\u00a0`CommandType`\u00a0property set to\u00a0`adCmdStoredProc`, to safely call a database Stored Procedure instead of dynamically executing a SQL string directly. Provide the parameters to the SP using\u00a0`Parameter`\u00a0objects, using the\u00a0`Command`'s\u00a0`CreateParameter`\u00a0and\u00a0`Parameters.Append`\u00a0methods."
    },
    "heuristic stored xss": {
        "title": "Heuristic Stored XSS",
        "desc": "The application creates web pages that include data from the application\u2019s database. The data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. This data may have originated in input from another user. If the data includes HTML fragments or Javascript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary database data without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use legitimate access to the application to submit engineered data to the application\u2019s database. When another user subsequently accesses this data, web pages may be rewritten and malicious scripts may be activated.",
        "mitigation": "1. Validate all dynamic data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in output. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML attribute encoding for data output to attribute values\n\t* Javascript encoding for server-generated Javascript.\n3. Consider using either the ESAPI encoding library, or its built-in functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n4. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n5. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "heuristic xsrf": {
        "title": "Heuristic XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    },
    "code injection": {
        "title": "Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* Prefer passing user data to a pre-implemented script, e.g. in another isolated application."
    },
    "command injection": {
        "title": "Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application receives data from the user input, and passes it as a string to the Operating System. This unvalidated data is then executed by the OS as a system command, running with the same system privileges as the application.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege."
    },
    "connection string injection": {
        "title": "Connection String Injection",
        "desc": "In order to communicate with the database, or with another external server (for example, Active Directory), the application dynamically constructs a connection string. This connection string includes untrusted data, which may be controlled by a malicious user. Since it is not constrained or properly sanitized, the untrusted data could be used to maliciously manipulate the connection string.",
        "impact": "If an attacker could manipulate the application\u2019s connection string to the database server, they might be able do any of the following:\n\n* Damage application performance (by increasing the MIN POOL SIZE)\n* Tamper with the network connection (for example, via TRUSTED CONNECTION)\n* Direct the application to the attacker\u2019s bogus database\n* Discover the password to the system account on the database (by a brute-force attack).",
        "mitigation": "* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Do not allow users to control the database connection string. Avoid dynamically building connection strings based on untrusted data, especially user input.\n* Store all connection strings in appropriate configuration mechanisms. If it is necessary to dynamically construct a connection string at runtime, do not include untrusted data directly in the connection string; instead, allow users to select from pre-defined connection strings."
    },
    "ldap injection": {
        "title": "LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code."
    },
    "reflected xss all clients": {
        "title": "Reflected XSS All Clients",
        "desc": "The application creates web pages that include data from previous user input. The user input is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary user input without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use social engineering to cause a user to send the website engineered input, rewriting web pages and inserting malicious scripts. The attacker can then pretend to be the original website, which would enable the attacker to steal the user's password, request the user\u2019s credit card information, provide false information, or run malware. From the victim\u2019s point of view, this is the original website, and the victim would blame the site for incurred damage.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Fully encode all dynamic data before embedding it in output.\n3. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML Attribute encoding for data output to attribute values\n\t* JavaScript encoding for server-generated JavaScript.\n4. Consider using either the ESAPI encoding library, or the built-in platform functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n5. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n6. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "resource injection": {
        "title": "Resource Injection",
        "desc": "The application allocates a resource based on user input, enabling an attacker to control it.",
        "impact": "The impact of resource injection is highly implementation dependent. By allowing attackers to control server-side resource I/O, such as network, storage or memory, an attacker may reroute these resources to expose them, generate multiple instances to exhaust the resource, or create a resource in a manner that would block other I/O operations.",
        "mitigation": "* Do not allow a user or untrusted data to define parameters of I/O, such as network sockets, storage access or other resource configurations."
    },
    "second order sql injection": {
        "title": "Second Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the database, typically via forms on other web pages. Afterwards, the application reads this data from the database, and embeds it within the SQL query, as SQL commands.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer using ADODB\u00a0`Command`\u00a0and\u00a0`Parameter`\u00a0objects with the\u00a0`Command`'s\u00a0`CommandType`\u00a0property set to\u00a0`adCmdStoredProc`, to safely call a database Stored Procedure instead of dynamically executing a SQL string directly. Provide the parameters to the SP using\u00a0`Parameter`\u00a0objects, using the\u00a0`Command`'s\u00a0`CreateParameter`\u00a0and\u00a0`Parameters.Append`\u00a0methods."
    },
    "sql injection": {
        "title": "SQL Injection",
        "desc": "The application uses tainted values from an untrusted source to craft a raw MongoDB query. This allows the attacker to modify the syntax of the query, injecting new syntax, thus resulting in a NoSQL Injection.",
        "impact": "MongoDB is a document-oriented key-value pairs based database which is classified as a NoSQL database. If a query conducted on MongoDB contains An attacker able to modify the syntax of a raw MongoDB query would then be able to inject arbitrary values, logic or Javascript code which runs within the query's context. The simplest example for attacking this is by injecting an infinite loop, such as while(1), resulting in Denial-of-Service. Another good example is by adding return statements to the query, resulting in arbitrary values being returned.\n\n\nBroadly, NoSQL Injections may result in unexpected behavior, and may allow an attacker to modify, retrieve or delete arbitrary documents within the database, thus allowing them to bypass logic, checks and privileges.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenated strings to construct NoSQL filters.\n* Never use potentially tainted inputs when crafting raw queries\n* Always use a Document-Object Mapper to perform CRUD actions in MongoDB. A Document-Object Mapper ensures objects are paired to documents, and, under the hood, will perform proper sanitization of values to insure no tainted values ever alter the syntax of MongoDB queries. Document-Object Mappers are used in a very similar way to SQL's ORMs, by mapping data to objects and vice-versa."
    },
    "stored xss": {
        "title": "Stored XSS",
        "desc": "The application creates web pages that include data from the application\u2019s database. The data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. This data may have originated in input from another user. If the data includes HTML fragments or Javascript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary database data without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use legitimate access to the application to submit engineered data to the application\u2019s database. When another user subsequently accesses this data, web pages may be rewritten and malicious scripts may be activated.",
        "mitigation": "1. Validate all dynamic data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in output. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML attribute encoding for data output to attribute values\n\t* Javascript encoding for server-generated Javascript.\n3. Consider using either the ESAPI encoding library, or its built-in functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n4. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n5. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "utf7 xss": {
        "title": "UTF7 XSS",
        "desc": "The application creates web pages that include data from previous user input. The user input is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary user input without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use social engineering to cause a user to send the website engineered input, rewriting web pages and inserting malicious scripts. The attacker can then pretend to be the original website, which would enable the attacker to steal the user's password, request the user\u2019s credit card information, provide false information, or run malware. From the victim\u2019s point of view, this is the original website, and the victim would blame the site for incurred damage.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Fully encode all dynamic data before embedding it in output.\n3. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML Attribute encoding for data output to attribute values\n\t* JavaScript encoding for server-generated JavaScript.\n4. Consider using either the ESAPI encoding library, or the built-in platform functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n5. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n6. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "xpath injection": {
        "title": "XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code."
    },
    "blind sql injections": {
        "title": "Blind SQL Injections",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn this case, the attacker does not need to rely on the application returning data from the database. Instead, it is possible to leverage existing tools that perform a series of boolean tests based on varying user input, relying only on the existence of application errors to indicate server state. Thus, the full database content can gradually be obtained, one bit at a time.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nIn this case, while the actual exploit is constrained to single bit of information at a time, it is still possible to eventually retrieve all data from the system, though this process is more time consuming and would be rather noisy. Note that other consequences, such as data modification and creation, code execution, etc. are unaffected, and still equally exploitable.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Do not allow the user to dynamically provide the name of the queried table. Furthermore, if possible, completely avoid dynamically specifying table names.\n* Ensure that all exceptions are properly handled, without leaking information on the errors, server state, or that an error occurred at all.\n* Prefer using ADODB\u00a0`Command`\u00a0and\u00a0`Parameter`\u00a0objects with the\u00a0`Command`'s\u00a0`CommandType`\u00a0property set to\u00a0`adCmdStoredProc`, to safely call a database Stored Procedure instead of dynamically executing a SQL string directly. Provide the parameters to the SP using\u00a0`Parameter`\u00a0objects, using the\u00a0`Command`'s\u00a0`CreateParameter`\u00a0and\u00a0`Parameters.Append`\u00a0methods."
    },
    "client side only validation": {
        "title": "Client Side Only Validation",
        "desc": "Relience on client side validation\u00a0only",
        "impact": "Bypassing a client side validation may lead to\u00a0unexpected\u00a0and tampered data to the server.",
        "mitigation": "It is highly recommended to validate the input in the server side, alongside client side validation."
    },
    "dangerous file upload": {
        "title": "Dangerous File Upload",
        "desc": "The application allows users to upload a file to the application, which is saved to a file within the web site's directory. The application does not apply thorough validation checks on the uploaded file, especially with regards to the file type or contents. This enables the attacker to upload executable files, in particular web server code such as .ASP, .PHP, and .JSP files, and others.\u00a0\n\n\nWhen this is followed by a regular request to the web application for the previously uploaded files, the application server will then proceed to execute the code in the uploaded file, giving the attacker direct access to the command execution environment.",
        "impact": "An attacker that exploits this vulnerability would be able to cause the application server to execute arbitrary code, allowing the attacker to alter\u00a0the application, run any\u00a0operating system command, and even take over the server altogether, depending on the application's system privileges.",
        "mitigation": "Generic Guidance:\n\n* **Storage:** If possible, avoid saving uploaded files to disk on the server, instead storing them in an external data storage, e.g. database or document management system.\n* **Location:** User files should be stored in an isolated directory, outside of the web site's directory with direct browsing disabled. When required, the application should explicitly read the file in code, and stream the contents to the user applicatively.\n* **Non-execution:** Files uploaded from users should be explicitly marked as non-executable by the web / application server, e.g. in configuration file or by\u00a0directory.\n* **Validation:**\u00a0Always validate all user input. In particular, enforce a whitelist of allowed file-types, according to the file extenstion and/or MIME type. Do not allow arbitrary files (such as .ASP, .PHP, .JSP, .EXE, .HTML, and so on). For example, accept only images such as\u00a0.GIF, .JPG, .PNG, .BMP, and so on.\n* **Renaming:**\u00a0Explicilty impose a pre-defined extension according to the file type, before saving the file to disk. This can be a hardcoded extension, or a configured list of allowed file types.\n* **Privileges:**\u00a0As a measure of Defense-in-Depth, configure the application server to execute in a limited system account, with minimal OS privileges.\n\n\nSpecific Recommendations:\u00a0\n\n* **Validation:**\u00a0Validate the uploaded filename before saving the file to disk, and verify the total file size does not exceed defined limits."
    },
    "improper resource shutdown or release": {
        "title": "Improper Resource Shutdown or Release",
        "desc": "The application code allocates resource objects, but does not ensure these are always closed and released in a timely manner. This can include database connections, file handles, network sockets, or any other resource that needs to be released.\u00a0In some cases,\u00a0these might be released - but only if everything works as planned; if there is any runtime exception during the normal course of system operations, resources start to leak.\u00a0\n\n\nNote that even in managed-memory languages such as Java, these resources must be explicitly released. Many types of resource are not released even when the Garbage Collector runs; and even if the the object would eventually release the resource, we have no control over when the Garbage Collector does\u00a0run.",
        "impact": "Unreleased resources can cause a drain of those available for system use, eventually causing general reliability and availability problems, such as performance degradation, process bloat, and system instability. If a resource leak\u00a0can be intentionally exploited by an attacker, it may be possible to cause a widespread DoS (Denial of Service) attack. This might even expose sensitive information between unprivileged users, if the resource continues to retain\u00a0data or user id\u00a0between subsequent allocations.",
        "mitigation": "* Always close and release all resources.\n* Ensure resources are released (along with\u00a0any other necessary cleanup) in a `finally { }` block. Do not close resources in a `catch { }` block, since this is not ensured to be called.\n* Explicitly call .close() on any instance of a class that implements the `Closable` or `AutoClosable` interfaces.\n* Alternatively, an even better solution is to use the try-with-resources idiom, in order to automatically close any defined\u00a0`AutoClosable`\u00a0instances."
    },
    "just one of equals and hash code defined": {
        "title": "Just One of Equals and Hash code Defined",
        "desc": "The general language contract for implementing classes requires the class to implement both `.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods (or neither). This requirement is important for hash tables and other data structures, and to ensure the class behavior is consistent between these methods. However, this class does in fact only implement one of these methods, but not the other, resulting in a broken object.",
        "impact": "If an application class explictly defines an override for only one of the\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, but not the other, this can negatively affect the application's integrity, and possibly cause inconsistent and unexpected results. This may also affect system performance, when using instances of this class in a hashtable or set.",
        "mitigation": "* Define overriding implementations for both\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, or not at all. If one is overridden, then both must be.\n* Note the general principle is: if `x.equals(y)`, then `x.hashCode()` must be equal to `y.hashCode()`.\n* Consider using the `EqualsBuilder` and `HashCodeBuilder` classes from the Apache Commons library."
    },
    "cleansing canonicalization and comparison errors": {
        "title": "Cleansing Canonicalization and Comparison Errors",
        "desc": "Filesystem paths and Internet URLs can be represented in an unlimited number of different ways, using various encodings, folder misdirection, and path obfuscation techniques. If a path or address is not properly sanitized and fully canonicalized into it's most basic, simplified form, it would be impossible to check all possible variants of this path. Hence, any decision based on a specific attributes of the path would likely be mistaken, and can be evaded by an active attacker.",
        "impact": "If a security decision, such as access control for example, is taken based on unsanitized, user-controlled data, it may be possible for\u00a0an attacker to manipulate the format of the data,\u00a0and thus obfuscate the actual\u00a0target. For example, if users are allowed to read any page that has\u00a0their user id in the URL, a user can request a URL with multiple user ids. Another example could be an administrative interface, wherein users are forbidden from accessing any page under the `/admin/` folder; an attacker can hide the actual target by sending a request to `/NOTEXISTS/../admin/`\u00a0. This would evade the check for URLs starting with \"admin/\", if the request URL is not canonicalized before checking.",
        "mitigation": "* Avoid performing security decisions based on untrusted, user-controlled input.\n* Always sanitize all user input.\n* Before making any decision based on a URL or path parameter, always transform it first into its canonical form, before making any decisions or doing any checks on it."
    },
    "hardcoded absolute path": {
        "title": "Hardcoded Absolute Path",
        "desc": "Hardcoded paths are less flexible, and do not allow the application to account for changes in the environment. For example, the program might be installed in a different directory than the default. Likewise, different system languages and OS architectures can change the names of the system folders; for example, in a Spanish Windows machine there could\u00a0be\u00a0\"`C:\\Archivos de programa (x86)\\`\" instead of \"`C:\\Program Files\\`\".\u00a0\n\n\nMoreover, on Windows by default all directories and files created outside of the system folders and outside the user's profile, will be allow full read and write access to any authenticated user. An unauthorized, malicious user could access any sensitive data in these folders, despite the application assuming they are protected. Even worse, an attacker\u00a0could overwrite existing programs in these unprotected folders and plant malicious code, which\u00a0will be activated by the application.",
        "impact": "Generally, hardcoding absolute paths makes the application brittle, and will prevent the program from operating properly in some environments that do not have the identical file system structure. This will also cause software maintenance problems in future versions of the application, if the design or requirements were to change.\u00a0\n\n\nAdditionally, if the application uses this path to read or write data, this can cause a breach of confidentiality or\u00a0allow malicious input into the program. In some situations, this vulnerability might even allow a malicious user to override the expected functionality, and cause the application to run any arbitrary program and execute any code the attacker deploys to the server.",
        "mitigation": "* Do not hardcode absolute paths into the application.\n* Instead, store the absolute paths in an external configuration file, that can be modified as required for each environment.\n* Alternatively, use paths relative to the current application, if the target file is in a subdirectory of the application's root.\n* Do not assume a specific file system structure, outside of the application's subdirectories. On Windows, use the built-in expandable variables, such as `%WINDIR%`, `%PROGRAMFILES%,` and `%TEMP%`.\n* On Linux and other OS where available, implement a system jail (chroot) for the application, and store\u00a0all programs and data files there only.\n* Prefer storing all executables under the protected program directory (under \"`C:\\Program Files\\`\" by default on Windows).\n* Do not store sensitive data or configuration files in arbitrary folders. Likewise, do not store data files in the program directory. Instead, use the designated folders as intended, i.e. `%PROGRAMDATA%` and `%APPDATA%`\u00a0on Windows, respectively.\n* Configure hardened permissions to the most restricted as possible, according to the Principle of Least Privilege. Consider implementing this automatically in the installation and setup routines."
    },
    "use of hardcoded password": {
        "title": "Use Of Hardcoded Password",
        "desc": "The application codebase\u00a0has string literal passwords embedded in the source code. This hardcoded value is used either to compare to user-provided credentials, or to authenticate downstream to a remote system (such as a database or a remote web service). \u00a0\n\n\nAn attacker only needs to gain access to the source code to reveal the hardcoded password. Likewise, the attacker can reverse engineer the compiled application binaries, and easily retrieve the embedded password. Once found, the attacker can easily use the password in impersonation attacks, either directly on the application or to the remote system.\u00a0\n\n\nFurthermore, once stolen, this password cannot be easily changed to prevent further misuse, unless a new version of the application is compiled. Moreover, if this application is distributed to numerous systems, stealing the password from one system automatically allows a class break in to all the deployed systems.",
        "impact": "Hardcoded passwords expose the application to password leakage. If an attacker gains access to the source code, she will be able to steal the embedded passwords, and use them to impersonate a valid user. This could include impersonating end users to the application, or impersonating the application to a remote system, such as a database or a remote web service.\u00a0\n\n\nOnce the attacker succeeds in impersonating the user or application, she will have full access to the system, and be able to do anything the impersonated identity could do.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not passwords.\n* In particular, user passwords should be stored in a\u00a0database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2). Do not compare user passwords with a hardcoded value.\n* Sytem passwords should be stored in a configuration file or the database, and protected with strong encryption (e.g. AES-256). Encryption keys should be securely managed, and not hardcoded."
    },
    "hardcoded password in connection string": {
        "title": "Hardcoded password in Connection String",
        "desc": "The application has the database password hardcoded in the source code files, and uses this password in a connection string to the database or other server. This password is visible to anyone with access to source code, and cannot be changed without rebuilding or recompiling the application. Even after compilation or deployment, the password and connection string are still present in the binary program files or production environment.",
        "impact": "Hardcoded database passwords expose the application to password leakage, and the database to unauthorized access. If an attacker gains access to the source code (or can decompile the application binaries), the attacker will be able to steal the embedded passwords, and use them to directly access the database. This would enable the attacker to steal secret information, modify sensitive records, or delete important data.\u00a0\n\n\nIn addition, the password cannot be easily changed when required. In the eventual situation wherein it is a necessity to update the password, a new version of the application would need to be built and deployed to production systems.",
        "mitigation": "- Never hardcode sensitive data, such as database passwords.\u00a0\n\u00a0- Prefer to avoid requiring an explicit database password at all, instead using OS-integrated system authentication.\n\u00a0- Alternatively, store the password in an encrypted configuration file, and implement a mechanism enabling administrators to change the password. Ensure the file permissions are configured to restrict access to administrators only.\n\u00a0- In particular, if the database supports Integrated Windows Authentication, prefer to use a Windows user over SQL user.\u00a0\n\u00a0- Configure the connection string with \"`Integrated Security=SSPI;`\" (or \"`True`\").\n\u00a0- Alternatively, consider implementing a managed data access layer, for example with an external COM+ tier.\u00a0\n\u00a0- If the application is required to explicitly define the database credentials, these should be stored outside the source code, for example in a user environment settings."
    },
    "improper exception handling": {
        "title": "Improper Exception Handling",
        "desc": "The application performs some operation, such as database or file access, that could throw an exception. Since the application is not designed to properly handle the exception, the application could crash.",
        "impact": "An attacker could maliciously cause an exception that could crash the application, potentially resulting in a denial of service (DoS) or unexpected behavior under certain erroneous conditions. Exceptions may also occur without any malicious intervention, resulting in general instability.",
        "mitigation": "Any method that could cause an exception should be wrapped in a try-catch block that:\n\n* Explicitly handles expected exceptions\n* Includes a default solution to explicitly handle unexpected exceptions"
    },
    "improper transaction handling": {
        "title": "Improper Transaction Handling",
        "desc": "The application creates a connection to the database, and explicitly manages the database transaction by committing it when appropriate. However, the code does not explicitly roll back failed transactions, for example in the case of exceptions. This causes the application to rely on implementation-specific behavior, depending on the specific combination of technologies (such as the database server) and resultant configuration.",
        "impact": "Database transactions that are abandoned (if their associated connection is closed, before the transaction is committed or rolled back) can have several different results, depending on implementation and specific technologies in use. While in some scenarios the database will automatically roll back the transaction if the connection is closed, more often it will either automatically commit the transaction in its abortive state, or leave the transaction open indefinitely (depending on its configured timeout value).\u00a0\n\n\nIn the first case, a transaction that is committed after a runtime exception is likely to be in an inconsistent state, incompatible with the current runtime conditions. This would result in situation detrimental to the system's integrity and possibly even stability.\u00a0\n\n\nIn the second case, a transaction that is kept active\u00a0indefinitely would cause the database server to retain its locks on all records and tables affected by the transaction. This could cause general reliability and availability problems, leading to delays, degraded performance, or even deadlocks as one thread waits for the locks to be released.\u00a0\n\n\nIn either case this results in unexpected state, and is dependent on external factors such that the application is not controlling the result.",
        "mitigation": "* Always open database connections and begin transactions within a `try { }` block.\n* Ensure there are no active uncommitted transactions before closing a database connection.\n* Always rollback active transactions in the case of exceptions.\n* After handling the exception, ensure the transaction is rolled back in the `catch { }` block, or possibly in the `finally { }` block."
    },
    "insecure randomness": {
        "title": "Insecure Randomness",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values, it would be possible for an attacker to calculate past or future values.  \n\nSpecifically, if this pseudo-random value is used in any security context, such as one-time passwords, keys, secret identifiers or salts - an attacker would likely be able to predict the next value generated and steal it, or guess a previously generated value and spoof its original intent.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from knowing or predicting a given value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values, based on sources often used to derive certain randomness; however, while they may seem random, large statistical samples would demonstrate that they are insufficiently random, producing a much smaller space of possible \"random\" values than a truly random sample would. This could enable an attacker to derive or guess this value, and thus hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "* Always use a cryptographically secure pseudo-random number generator, instead of basic random methods, particularly when dealing with a security context\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, thus making brute-force attacks unfeasible."
    },
    "leaving temporary files": {
        "title": "Leaving Temporary Files",
        "desc": "It is very common for applications to use temporary files, as intermediate storage and to aid with processing large amounts of data or long-running calculations. Applications require such files so frequently that most operating systems allocate a dedicated area for temporary files, such as a TEMP directory, and several different mechanisms for creating them exist in most platforms. However, by default these temporary files are not deleted automatically, and will remain on disk indefinitely. If the program does not explicitly and proactively delete the temporary files when it is finished processing them, they might be accessbile to other users of the computer.",
        "impact": "Applications often create temporary files containing sensitive business data or personal information, in order to handle the file generation process in\u00a0several steps, or even as the output of an automatic process. These files, if left exposed\u00a0on disk for an indeterminate period of time, could leak the secret data to unauthorized users.",
        "mitigation": "* Always explicitly delete any temporary file created. Ensure temp file deletion will occur by wrapping it in a `finally { }` block, or call `File.deleteOnExit()` to ensure eventual deletion.\n* Additionally, to ensure that all temporary files will eventually be deleted, consider implementing additional functionality that will periodically scrape and delete all unused, existing temporary files.\n* Ensure all existing file handles or references are closed before attempting deletion."
    },
    "log forging": {
        "title": "Log Forging",
        "desc": "The application writes audit logs upon security-sensitive actions. Since the audit log includes user input that is neither checked for data type validity nor subsequently sanitized, the input could contain false information made to look like legitimate audit log data,",
        "impact": "An attacker could engineer audit logs of security-sensitive actions and lay a false audit trail, potentially implicating an innocent user or hiding an incident.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in logs.\n3. Use a secure logging mechanism."
    },
    "insufficiently protected credentials": {
        "title": "Insufficiently Protected Credentials",
        "desc": "User passwords are written to the database without being properly encrypted with a cryptographic hash. The application reads clear passwords straight from the database.",
        "impact": "An attacker could steal user credentials, enabling access to user accounts and confidential data.",
        "mitigation": "Store passwords using a cryptographic hash designed as a password protection scheme, such as:\n\n* Argon2\n* bcrypt\n* scrypt\n* PBKDF2 (with random salt) These need to be configured with an appropriately high work effort."
    },
    "information leak through persistent cookies": {
        "title": "Information Leak Through Persistent Cookies",
        "desc": "The application sends sensitive user data, including passwords, back to the user's browser embedded in a cookie. Persistent cookies are stored in a file on the user's computer, where they might be accessed by an unauthorized user, thus exposing the user's password.",
        "impact": "An attacker with access to the user's desktop, or unprotected network connection, could steal the user's password and other sensitive data stored in the cookie. Once the password is stolen, the attacker can impersonate her victim to the application, and do anything the user can do. The application would not be able to discern the difference, since the user's own password was used.",
        "mitigation": "Do not store passwords, or any other secret data besides sessionid, in cookies."
    },
    "session clearing problems": {
        "title": "Session Clearing Problems",
        "desc": "The web application tracks user state via a server-side session mechanism, providing the user's browser with a session identifier to allow the server to associate the browser request with the current\u00a0session. Typically the application will use this session object to cache various user-dependent data, however the application never actively removes this data from the session, or actively kills the session. If the user leaves the site after being logged in, the session remains active, even if the browser is closed. This can enable an attacker to continue to use the valid session identifier (e.g. if the user leaves the computer unlocked, or at an Internet cafe), and thus the live session. This will associate with the logged-in user.",
        "impact": "Leaving the user's session in an active state after the user leaves the site may enable an attacker to impersonate the user, via session hijacking. Once the attacker gains the victim's session identifier, the attacker can perform any action in the application that the user is permitted, including accessing the user's personal data such as reading the user's records or changing the user account.",
        "mitigation": "* Provide the user with a manual logout mechanism, to allow users to actively close their session.\n* Implement a session timeout, so that after a specific amount of time the session will automatically be logged out.\n* When logging out the user, call `Session.Abandon()` , and do not suffice with removing the sessionid from the browser's cookie.\n* If the application does not require user sessions, disable the session mechanism in Web.config file:\u00a0`<sessionState mode=\"Off\" />`"
    },
    "thread safety issue": {
        "title": "Thread Safety Issue",
        "desc": "Race Conditions occur when a public, single instance of a resource is used by multiple concurrent logical processes. If the these logical processes attempt to retrieve and update the resource without a timely management system, such as a lock, a Race Condition will occur.\n\n\nAn example for when a Race Condition occurs is a resource that may return a certain value to a process for further editing, and then updated by a second\u00a0process, resulting in the original process' data no longer being valid. Once the original process edits and updates the incorrect value back into the resource, the second process' update has been overwritten and lost.",
        "impact": "At best, a Race Condition may\u00a0cause errors in accuracy, overidden values or unexpected behavior that may result in denial-of-service. At worst, it may allow attackers to retrieve data or bypass security processes by replaying a controllable Race Condition until it plays out in their favor.",
        "mitigation": "When sharing resources between concurrent processes across the application ensure that these resources are\u00a0either thread-safe, or implement a locking mechanism to ensure expected concurrent activity."
    },
    "open redirect": {
        "title": "Open Redirect",
        "desc": "The application redirects the user\u2019s browser to a URL provided by a tainted input, without first ensuring that URL leads to a trusted destination, and without warning users that they are being redirected outside of the current site. An attacker could use social engineering to get a victim to click a link to the application with a parameter defining another site to which the application will redirect the user\u2019s browser. Since the user may not be aware of the redirection, they may be under the misconception that the website they are currently browsing can be trusted.",
        "impact": "An attacker could use social engineering to get a victim to click a link to the application, so that the user will be immediately redirected to another site of the attacker's choice. An attacker can then craft a destination website to fool the victim; for example - they may craft a phishing website with an identical looking UI as the previous website's login page, and with a similar looking URL, convincing the user to submit their access credentials in the attacker's website. Another example would be a phishing website with an identical UI as that of a popular payment service, convincing the user to submit their payment information.",
        "mitigation": "1. Ideally, do not allow arbitrary URLs for redirection. Instead, create a mapping from user-provided parameter values to legitimate URLs.\n2. If it is necessary to allow arbitrary URLs:\n\t* For URLs inside the application site, first filter and encode the user-provided parameter, and then either:\n\t\t+ Create a white-list of allowed URLs inside the application\n\t\t+ Use variables as a relative URL as an absolute one, by prefixing it with the application site domain - this will ensure all redirection will occur inside the domain\n\t* For URLs outside the application (if necessary), either:\n\t\t+ White-list redirection to allowed external domains by first filtering URLs with trusted prefixes. Prefixes must be tested up to the third slash [/] - `scheme://my.trusted.domain.com/,` to prevent evasion. For example, if the third slash [/] is not validated and scheme://my.trusted.domain.com is trusted, the URL scheme://my.trusted.domain.com.evildomain.com would be valid under this filter, but the domain actually being browsed is evildomain.com, not domain.com.\n\t\t+ For fully dynamic open redirection, use an intermediate disclaimer page to provide users with a clear warning that they are leaving the site."
    },
    "information exposure through an error message": {
        "title": "Information Exposure Through an Error Message",
        "desc": "The application handles exceptions in an insecure manner, including raw details directly in the error message. This could occur in various ways: by not handling the exception; printing it directly to the output or file; explicitly returning the exception object; or by configuration. These exception details may include sensitive information that could leak to the users due to the occurrence of the runtime error.",
        "impact": "Exposed details about the application\u2019s environment, users, or associated data (for example, stack trace) could enable an attacker to find another flaw and help the attacker to mount an attack. This may also leak sensitive data, e.g. passwords or database fields.",
        "mitigation": "* Do not expose exception data directly to the output or users, instead return an informative, generic error message. Log the exception details to a dedicated log mechanism.\n* Any method that could throw an exception should be wrapped in an exception handling block that:\n\t+ Explicitly handles expected exceptions.\n\t+ Includes a default solution to explicitly handle unexpected exceptions.\n* Configure a global handler to prevent unhandled errors from leaving the application."
    },
    "xss evasion attack": {
        "title": "XSS Evasion Attack",
        "desc": "The application web page includes data from a client-side controlled data\u00a0(including the page session). The user input is embedded in the page, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary client-side controlled input without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could bypass the regular channels\u00a0made by the system to avoid Cross-Site Scripting (XSS) attacks in order to inject JavaScript or HTML code. By using social engineering to cause a user to access the website with injection inputs, such as a URL with engineered session attributes, causing the browser to rewrite web pages.\u00a0The attacker can then pretend to be the original website, which would enable the attacker to steal the user's session, request the user\u2019s credentials, provide false information, or run malware. From the victim\u2019s point of view, this is the original website's action.",
        "mitigation": "Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\n* Data type\n* Size\n* Range\n* Format\n* Expected values\n**Secure-Coding Approach**\n\n\nFully encode all dynamic data before embedding it in the webpage. Encoding should be context-sensitive. For example: \n\n* HTML encoding for HTML content.\n* HTML Attribute encoding for data output to attribute values.\n* JavaScript encoding for JavaScript.\n\n\nIt is recommended to use the known libraries for encoding output, such as ESAPI."
    },
    "db parameter tampering": {
        "title": "DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "dos by sleep": {
        "title": "DoS by Sleep",
        "desc": "The application uses a user-provided value to set its sleep period, without enforcing a limited range for this value.",
        "impact": "An attacker could provide a very high sleep value, effectively causing a denial of service for a long period of time.",
        "mitigation": "1. Ideally, the sleep command\u2019s duration should not be be according to user input at all. It should be either hardcoded, defined in a configuration file, or dynamically calculated at runtime.\n2. If it is necessary to allow the user to define the sleep duration, this value MUST be checked and enforced to be within a predefined range of valid values."
    },
    "path traversal": {
        "title": "Path Traversal",
        "desc": "",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "use of hard coded cryptographic key": {
        "title": "Use of Hard coded Cryptographic Key",
        "desc": "The application code uses an encryption key to encrypt and decrypt sensitive data. While it is important to create this encryption key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code.\u00a0\n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text encryption key and use it to decrypt the sensitive data that the application was protecting.",
        "impact": "Static, unchangeable encryption keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the encryption key, this can be used to gain access to any encrypted secret data, thus violating the confidentiality of the data. Furthermore, it would be impossible to replace the encryption key once stolen. Note that if this is\u00a0a product that can be installed numerous times, the encryption key will always be the same, allowing an attacker to break all instances at the same cost.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as encryption keys, in plain text.\n* Never\u00a0hardcode encryption keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove the hardcoded encryption key from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "http response splitting": {
        "title": "HTTP Response Splitting",
        "desc": "Since user input is being used in an HTTP response header, an attacker could include NewLine characters to make the header look like multiple headers with engineered content, potentially making the response look like multiple responses (for example, by engineering duplicate content-length headers). This can cause an organizational proxy server to provide the second, engineered response to a victim\u2019s subsequent request; or, if the proxy server also performs response caching, the attacker can send an immediate subsequent request to another site, causing the proxy server to cache the engineered response as a response from this second site and to later serve the response to other users.\n\n\nMany modern web frameworks mitigate this issue, by offering sanitization for new line characters in strings inserted into headers by default. However, since many older versions of web frameworks fail to automatically mitigate this issue, manual sanitization of input may be required.",
        "impact": "If the header setting code is of a vulnerable version, an attacker could:\n\n* Arbitrarily change the application server\u2019s response header to a victim\u2019s HTTP request by manipulating headers\n* Arbitrarily change the application server\u2019s response body by injecting two consecutive line breaks, which may result in Cross-Site Scripting (XSS) attacks\n* Cause cache poisoning, potentially controlling any site\u2019s HTTP responses going through the same proxy as this application.",
        "mitigation": "1. Validate all input, regardless of source (including cookies). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Additionally, remove or URL-encode all special (non-alphanumeric) user input before including it in the response header.\n3. Make sure to use an up-to-date framework."
    },
    "improper locking": {
        "title": "Improper Locking",
        "desc": "In order to improve performance and raise throughput, the application has several threads performing operations in parallel. In certain situations, sensitive methods need to ensure that other threads are not interferring with the integrity of their operations or data. To do so, these methods need to acquire a lock (commonly known as mutex, monitor, or other types) to synchronize access between threads.\n\n\nHowever, in this case, the synchronization lock is never unlocked, and can cause the other threads to continuously await its release indefinitely.",
        "impact": "Incomplete management of explicit thread locking can lead to deadlocked threads, wherein one thread (or several) is blocked while waiting for the other thread to release it's lock - which will\u00a0never happen, causing the other threads to be disabled indefinitely. This could also cause the application to\u00a0consume other resources indefinitely, without releasing them. At the very least, this flaw will severly limit throughput of the application, by blocking the multithreaded operations.",
        "mitigation": "* Always ensure any synchronization locks are explicitly released.\n* In particular, use strucutured error handling to ensure that the locks are released even after runtime exceptions.\n* Avoid manual locking, if\u00a0possible, instead using\u00a0automatic\u00a0locking via\u00a0synchronized blocks and methods where available."
    },
    "parameter tampering": {
        "title": "Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "privacy violation": {
        "title": "Privacy Violation",
        "desc": "The application sends user information, such as passwords, account information, or credit card numbers, outside the application, such as writing it to a local text or log file or sending it to an external web service.",
        "impact": "A user\u2019s personal information could be stolen by a malicious programmer, or an attacker that intercepts the data.",
        "mitigation": "1. Personal data should be removed before writing to logs or other files.\n2. Review the need and justification of sending personal data to remote web services."
    },
    "reflected xss specific clients": {
        "title": "Reflected XSS Specific Clients",
        "desc": "The application creates web pages that include data from previous user input. The user input is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of embedding arbitrary user input without first encoding it in a format that would prevent the browser from treating it like HTML instead of plain text.",
        "impact": "An attacker could use social engineering to cause a user to send the website engineered input, rewriting web pages and inserting malicious scripts. The attacker can then pretend to be the original website, which would enable the attacker to steal the user's password, request the user\u2019s credit card information, provide false information, or run malware. From the victim\u2019s point of view, this is the original website, and the victim would blame the site for incurred damage.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Fully encode all dynamic data before embedding it in output.\n3. Encoding should be context-sensitive. For example:\n\t* HTML encoding for HTML content\n\t* HTML Attribute encoding for data output to attribute values\n\t* JavaScript encoding for server-generated JavaScript.\n4. Consider using either the ESAPI encoding library, or the built-in platform functions. For earlier versions of ASP.NET, consider using the AntiXSS library.\n5. In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n6. Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie."
    },
    "sql injection evasion attack": {
        "title": "SQL Injection Evasion Attack",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn particular, the application decodes the user input (typically from HTML encoding format), before embedding it in the database query. Since the application decodes the input before using it, an attacker could obscure the malicious payload by encoding it before sending to the server, thus concealing the attack from most protection mechanisms. \u00a0\n\n\nThus, the input could contain SQL commands that would be interpreted as such by the database, without being detected or blocked by most countermeasures.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* In particular, all data validation should be performed after canonicalization, i.e. after the data has been decoded and simplified.\n* Prefer using ADODB\u00a0`Command`\u00a0and\u00a0`Parameter`\u00a0objects with the\u00a0`Command`'s\u00a0`CommandType`\u00a0property set to\u00a0`adCmdStoredProc`, to safely call a database Stored Procedure instead of dynamically executing a SQL string directly. Provide the parameters to the SP using\u00a0`Parameter`\u00a0objects, using the\u00a0`Command`'s\u00a0`CreateParameter`\u00a0and\u00a0`Parameters.Append`\u00a0methods."
    },
    "stored code injection": {
        "title": "Stored Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* Prefer passing user data to pre-implemented script, e.g. in another isolated application.\n* Never blindly execute an untrusted file, especially a user-writable file."
    },
    "trust boundary violation": {
        "title": "Trust Boundary Violation",
        "desc": "Server-side Session variables, or objects, are values assigned to a specific session, which is associated with a specific user. Often, they hold data relevant to that user's session, such as specific identifiers, user-type, authorization, authentication information and more. As such, the paradigm often associated to the Session object is that its contents can be trusted, as users cannot generally set these values themselves.\u00a0\n\n\nThe application places user input, which is untrusted data, in the server-side Session object, which is considered a trusted location. This could lead developers to treat untrusted data as trusted.",
        "impact": "Code that reads from Session variables may trust them as server-side variables, but they may have been tainted by user inputs. This can lead to tampering with parameters used to authenticate or authorize users. Further, tainted Session variables offer an additional attack surface against the application - if untrusted data taints a Session variable, and that Session variable\u00a0 is then used elsewhere without sanitization as if it were trusted, it could lead to further attacks such as Cross-Site Scripting, SQL Injection and more.",
        "mitigation": "1. Validate and sanitize all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Don\u2019t mix untrusted user input with trusted data."
    },
    "unclosed connection": {
        "title": "Unclosed Connection",
        "desc": "The application opens many database connections. Since these are not a managed resource, the application is responsible for properly closing the connection and releasing the resource. The proper way of ensuring the connection will be released, no matter what and even in the case of errors, is to explicitly close the connection in a `finally { }` block, however the application does not do so.\u00a0\n\n\nThus,\u00a0even after the connection object goes out of scope of the current method, the underlying unmanaged resource will still not be released, despite the garbage collector.",
        "impact": "The application opens new connections to the database\u00a0in order to serve each request. However, the application does not properly ensure these database\u00a0connections are always explicitly closed and released. Since the database server typically has a relatively low limit on open connections, which are being held open by the application,\u00a0it would be relatively simple for an attacker to cause a Denial of Service (DoS) attack.\n\n\nThe attacker could simply send many requests to the server, each in a new session, causing the application to re-open many connections to the database, which are left open. This may\u00a0eventually cause the database to refuse to open additional connections for the application, thus blocking the application.",
        "mitigation": "Generic Guidance:\n\n* Always ensure the application properly cleans up any unmanaged or physical resources, such as open files or dastabase connections.\n* Prefer to implement the proper Dispose() pattern\n* Ensure all cleanup processes will always be run, even in the case of errors.\n* Be extra careful to avoid exceptions during the method cleanup and exception handling.\n* Prefer implementing the using () statement\u00a0pattern, which automatically disposes\u00a0its own resources.\n\n\nSpecific Recommendations:\n\n* Explicitly close all open database connections.\n* Perform connection cleanup in the `finally { }` block of the same `try { }` that opened the connection."
    },
    "xsrf": {
        "title": "XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    }
}