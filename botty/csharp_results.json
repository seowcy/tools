{
    "reliance on dns lookups in a decision": {
        "title": "Reliance on DNS Lookups in a Decision",
        "desc": "The application performs a reverse DNS resolution, based on the remote IP address, and performs a security check based on the returned hostname. However, it is relatively easy to spoof DNS names, or cause them to be misreported, depending on the context of the specific environment. If the remote server is controlled by the attacker, it can be configured to report a bogus hostname. Additionally, the attacker could also spoof the hostname if she controls the associated DNS server, or by attacking the legitimate DNS server, or by poisoning the server's DNS cache, or by modifying unprotected DNS traffic to the server. Regardless of the vector, a remote attacker can alter the detected network address, faking\u00a0the authentication details.",
        "impact": "Relying on reverse DNS records, without verifying domain ownership via cryptographic certificates or protocols, is not a sufficient authentication mechanism. Basing\u00a0any\u00a0security decisions on the registered hostname\u00a0could allow an external attacker to control the application flow. The attacker could possibly perform restricted operations, bypass access controls, and\u00a0even spoof the user's identity, inject a bogus hostname into the security log, and possibly other logic attacks.",
        "mitigation": "* Do not rely on DNS records, network addresses, or system hostnames as a form of authentication, or any other security-related decision.\n* Do not perform reverse DNS resolution over an unprotected protocol without record validation.\n* Implement a proper authentication mechanism, such as passwords, cryptographic certificates, or public key digital signatures.\n* Consider using proposed protocol\u00a0extensions to cryptographically protect DNS, e.g. DNSSEC (though note the limited support and other drawbacks)."
    },
    "race condition within a thread": {
        "title": "Race Condition within a Thread",
        "desc": "Most modern environments, and web in particular, require a high level of concurrent actions, invoking many instances of an object, or a singleton object multiple times, using an internal scheduler that decides which thread should be operating at the moment. This scheduler is often out of a developer's control, and may halt and resume concurrent threads. These threads often operate over shared resources, which are part of a functionality that is being invoked simultaneously across multiple logic flows; for example - static member variables are shared across all instances of an object type, while in singleton objects (such as servlets) any member variable is shared across all calls to the singleton.\n\n\nWhen working in an environment with concurrency, failure to ensure all operations on a shared resource are done atomically and in a synchronized manner may result in threads or processes overriding each other's actions or outputs, often contradicting intended logic. For example, consider the \"Time of Check, Time of Use\" problem (TOCTOU) - if two threads attempt to increment the same counter, thread 1 reads the value n, and is then halted by the scheduler, thread 2 will read the value n, and then both threads will attempt to update the value to n+1, where logic would dictate that it would be n+2. Had this counter been properly synchronized, thread 2 would have to wait for thread 1 to complete its entire atomic operation of checking and updating its value.",
        "impact": "A\u00a0race condition can cause erratic or unexpected application behavior. Additionally, if a race condition\u00a0can be influenced directly by users, an attacker may choose to replay a race condition until they obtain a desired\u00a0result, allowing them to induce certain application behavior that is not part of its intentional design.",
        "mitigation": "* Consider allocating independent\u00a0resources\u00a0for concurrent logical processes, unless required.\n* Where resource sharing is required, utilize a locking mechanism when handling shared resources to ensure that actions are performed atomically by the current process, so that these logical processes\u00a0are not overridden or disrupted by any other concurrent process.\n* When dealing with static member variables - always consider that these are shared across all instances of an object\n* When dealing with singleton objects (such as servlets) being invoked by multiple concurrent logical processes - always synchronize either the entire singleton or its member variables; otherwise any thread processing the singleton's static methods may cause TOCTOU issues"
    },
    "session fixation": {
        "title": "Session Fixation",
        "desc": "The application authenticates users without terminating existing sessions. As a result, an attacker could get a victim to log in to the application during the attacker\u2019s session (for example, by getting the victim to click on a link including a session ID), and the application would authenticate the attacker\u2019s session as the victim\u2019s user account.",
        "impact": "An attacker could get a user to log in using the attacker\u2019s session. The attacker could then do anything that the other user has permissions for, such as accessing that user\u2019s confidential information and performing transaction in that user\u2019s name.",
        "mitigation": "The application should terminate any existing sessions upon user authentication and create a new session for that user."
    },
    "use of cryptographically weak prng": {
        "title": "Use of Cryptographically Weak PRNG",
        "desc": "The application uses a weak method of generating pseudo-random values, such that other numbers could be determined from a relatively small sample size. Since the pseudo-random number generator used is designed for statistically uniform distribution of values, it is approximately deterministic. Thus, after collecting a few generated values, it would be possible for an attacker to calculate past or future values.  \n\nSpecifically, if this pseudo-random value is used in any security context, such as one-time passwords, keys, secret identifiers or salts - an attacker would likely be able to predict the next value generated and steal it, or guess a previously generated value and spoof its original intent.",
        "impact": "Random values are often used as a mechanism to prevent malicious users from knowing or predicting a given value, such as a password, encryption key, or session identifier. Depending on what this random value is used for, an attacker would be able to predict the next numbers generated, or previously generated values, based on sources often used to derive certain randomness; however, while they may seem random, large statistical samples would demonstrate that they are insufficiently random, producing a much smaller space of possible \"random\" values than a truly random sample would. This could enable an attacker to derive or guess this value, and thus hijack another user's session, impersonate another user, or crack an encryption key (depending on what the pseudo-random value was used for).",
        "mitigation": "* Always use a cryptographically secure pseudo-random number generator, instead of basic random methods, particularly when dealing with a security context\n* Use the cryptorandom generator that is built-in to your language or platform, and ensure it is securely seeded. Do not seed the generator with a weak, non-random seed. (In most cases, the default is securely random).\n* Ensure you use a long enough random value, thus making brute-force attacks unfeasible."
    },
    "use of broken or risky cryptographic algorithm": {
        "title": "Use Of Broken Or Risky Cryptographic Algorithm",
        "desc": "The application code specifies the name of the selected cryptographic algorithm, either via a String argument, a factory method, or a specific implementation class. These algorithms have fatal cryptographic weaknesses, that make it trivial to break in a reasonable timeframe. Strong algorithms should withstand attacks far beyond the realm of possible.",
        "impact": "Using a weak or broken algorithm ruins the protection granted by using cryptographic mechanisms in the first place, harming the confidentiality or integrity of sensitive user data. This could allow an attacker to steal secret information, alter sensitive data, or forge the source of modified messages.",
        "mitigation": "* Only use strong, approved cryptographic algorithms, including AES, RSA, ECC, and SHA-256 respectively, amongst others.\n* Do not use weak algorithms that are considered completely broken, such as DES, RC4, and MD5, amongst others.\n* Avoid, where possible, using legacy algorithms that are not considered \"future-proof\" with sufficient safety margins, even though they are considered \"safe enough\" for today. This includes algorithms that are weaker than they should be, and have stronger replacements, even if they are not yet fatally broken - such as SHA-1, 3DES,\n* Consider using a relevant official set of classifications, such as NIST or ENISA. If possible, use only FIPS 140-2 certified algorithm implementations."
    },
    "httponlycookies": {
        "title": "HttpOnlyCookies",
        "desc": "The web application framework, by default, does not set the \"httpOnly\" flag for the application's sessionid cookie and other sensitive application cookies. Likewise, the application does not explicitly use the \"httpOnly\" cookie flag, thus allowing client scripts to access the cookies by default.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, are typically accessible by client-side scripts, such as JavaScript. Unless the web application explicitly prevents this using the \"httpOnly\" cookie flag, these cookies could be read and accessed by malicious client scripts, such as Cross-Site Scripting (XSS). This flag would mitigate the damage done in case XSS vulnerabilities are discovered, according to Defense in Depth.",
        "mitigation": "- Always set the \"httpOnly\" flag for any sensitive server-side cookie.\n\u00a0- It is highly recommended to implement HTTP Strict Transport Security (HSTS) in order to ensure that the cookie will be sent over a secured channel.\n\u00a0- Explicitly set the \"httpOnly\" flag for each cookie set by the application.\n\n\n- In particular, explicitly set the `HttpCookie.HttpOnly` property to `true`, for any cookie being added to the response. This includes any cookie implicitly being added to the response via the `Response.Cookies` collection property.\u00a0\n\u00a0- Preferably, configure the web application framework to automatically set httpOnly on all cookies, by setting the `httpOnlyCookies` attribute on the `<httpCookies>` element to `\"true\"`, under `<system.web>` in your application's web.config.\n\u00a0- If the cookie is being written directly to the response headers, e.g. via the `Response.AppendHeader()` method with the \"`Set-Cookie`\" header name, append \"`;httpOnly;`\" to the end of the cookie value."
    },
    "improper encoding of output": {
        "title": "Improper Encoding Of Output",
        "desc": "The application dynamically creates JavaScript scripts in the website's pages, embedding\u00a0data generated on the server directly into the client JavaScript.\u00a0This data might be controllable from user input. In order to protect this page against Cross-Site Scripting (XSS) attacks, the application does ensure the data is encoded before being output into the response.\u00a0\n\n\nHowever, the application does not perform proper context-specific\u00a0encoding, in particular encoding the input for HTML instead of JavaScript-specific encoding. This could allow an attacker to inject a JavaScript payload into the response, despite the encoding. This JavaScript would be executed by the victim's browser.",
        "impact": "Since the application is not using context-specific encoding, it may be possible for an attacker to find a\u00a0Cross-Site Scripting (XSS) vulnerability, enabling them to\u00a0steal the user's password, request the user\u2019s credit card information, provide false information, or run malicious code. All this would still be in context of the original web application, from the victim's perspective, allowing the attacker to effectively control the user's experience on the target website.",
        "mitigation": "Generic Guidance\n\n* Avoid generating JavaScript code dynamically, based on user input or other data.\n* Fully encode all dynamic data before embedding it in output.\n* Encoding should be context-sensitive. For example:\n* HTML encoding for HTML content\n* HTML Attribute encoding for data output to attribute values\n* JavaScript encoding for server-generated JavaScript\n* Consider using the `System.Web.Security.AntiXss.AntiXssEncoder`\u00a0class (or the AntiXss library in older versions), to provide context-specific encoding methods.\n* In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie.\n* Implement Content Security Policy (CSP) headers, to constrain and restrict the source of JavaScript code.\n\n\nSpecific Recommendations\n\n* Remove the dynamically generated JavaScript code, and seperate any source of data from the source code.\n* If it is necessary to dynamically generate JavaScript from data, use context-specific encoding on all data to properly mitigate XSS and simliar attacks.\n* Consider using Razor's built-in context encoding nuggets."
    },
    "inappropriate encoding for output context": {
        "title": "Inappropriate Encoding for Output Context",
        "desc": "The application creates web pages that include data from previous user input. The user input is embedded directly in the page's HTML, causing the browser to display it as part of the web page. This input is first encoded into HTML before being embedded.\u00a0\n\n\nHowever, the application is using Razor syntax, which will automatically HTML encode any data output with the `@value` syntax. Thus, the Razor view-engine will re-encode data that was already encoded using the explicit `HtmlEncode()` function call, causing user data to be double-encoded in the output web page.",
        "impact": "In some situations, using the encoding functions in an incorrect manner will lead to double-encoded data. This would cause user input to be malformed, leading to further mistakes downstream. Note that there is no real risk of\u00a0Cross-Site Scripting (XSS) in this case, however bugs of this sort can eventually lead to bypassing security mechanisms (such as the automatic encoding) in order to fix the problem, causing further vulnerabilities.",
        "mitigation": "Generic Guidance:\n\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Fully encode all dynamic data before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* Prefer using functions built-in to the language or platform.\n* In the Content-Type HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the httpOnly flag on the session cookie, to prevent XSS exploits from stealing the cookie.\n\n\nSpecific Recommendations:\n\n* Do not explicitly call HtmlEncode() on data before it is output to the Razor webpage."
    },
    "off by one error": {
        "title": "Off By One Error",
        "desc": "The iterator used to access a data set uses an incorrect arithmetic comparator, resulting in an incorrect iteration count and an off-by-one error.",
        "impact": "Off by one errors often lead to unexpected behavior, depending on implementation. The most common risk of Off-by-One errors are unhandled exceptions.",
        "mitigation": "When using arithmetic operators as a stop condition, always consider that the size of a data-set is always larger than the data-set itself by one, as a data-set's 0th element is also occupied. Therefore, the final cell of a data-set is often minus one its actual size."
    },
    "client side injection": {
        "title": "Client Side Injection",
        "desc": "The app communicates with its local storage by calling methods on the storage classes, e.g.\u00a0`SqLiteDataBase.query()`, and passing selection variables to these methods. These classes internally create a\u00a0textual SQL query, including the parameters that were passed in.\u00a0Since these variables are based on untrusted input, and are\u00a0neither checked for data validity nor sanitized, the input could contain SQL commands that would be interpreted as such by the database.",
        "impact": "A remote attacker could access all of the app's data indirectly, by poisoning various methods of data input sent to the app (e.g. by sending an SMS or editing text fields). This could include\u00a0stealing any sensitive information stored by the app, such as personal user details or credit cards, and possibly even change or erase existing data.",
        "mitigation": "Generic Guidance\n\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In particular, all data validation should be performed after canonicalization, i.e. after the data has been decoded and simplified.\n* Do not concatenate untrusted input into the SQL query, instead only use parameterized queries and object bindings.\n\n\nSpecific Recommendations\n\n* Perform input sanitization after the decoding.\n* Do not send input (even indirectly) to injectable parameters, such as `whereClause` and `selection`; instead, use parameterized queries and submit the input to the database methods via the designated parameters, e.g. `whereArgs` and `selectionArgs`."
    },
    "insecure data storage": {
        "title": "Insecure Data Storage",
        "desc": "The application stores data, which may contain PII (Personally Identifiable Information), on the client browser or device. The application uses insecure forms of storage, which do not inherently provide any protection from unauthorized access. This data is not encrypted or sanitized before being stored, thus a malicious entity with access to the device or browser could easily retrieve the user's data.",
        "impact": "An attacker that has access to a user's client device, will be able to retrieve stored information, such as user's\u00a0sensitive personal data (PII) from the client storage. Use of this storage will also increase exposure of its content to theft via other means, such as cross-site scripting (XSS). This would be detrimental to the user and harm their privacy, and could\u00a0cause damage to reputation, financial loss, and even lead to identity theft.",
        "mitigation": "* Avoid\u00a0storing sensitive data, such as PII, on unprotected clients.\n* If PII or other sensitive data must be stored on the client, ensure it is encrypted or otherwise protected."
    },
    "insufficient transport layer protect": {
        "title": "Insufficient Transport Layer Protect",
        "desc": "The app handles various forms of sensitive data, and communicates with the remote application server. However,\u00a0the app connects using an \"`http://`\" URL, which will cause the underlying channel to use straight HTTP, without securing it with SSL/TLS.",
        "impact": "Sending data over the network is inherently risky, unless the communication channel is protected using a secured protocol. This is\u00a0especially true for mobile devices that are often connected to non-secure networks and\u00a0untrusted hotspots. An attacker can easily eavesdrop on the information\u00a0being sent over the air, and even manipulate the data in some scenarios.\n\n\nThus, an attacker could steal any personal or secret data sent over unencrypted HTTP, such as passwords, credit card details, social security numbers, and other forms of PII (Personally Identifiable Information), leading to identity theft and other forms of fraud. Additionally, it may be possible for an active attacker to alter the data and inject false or malicious data, causing further damage to the application server or the client app.",
        "mitigation": "Always use secure protocol by connecting to \"`https://`\" URLs. Never send sensitive data to an \"`http://`\" URL."
    },
    "poor authorization and authentication": {
        "title": "Poor Authorization and Authentication",
        "desc": "The mobile app collects device-specific identifiers, such as IMEI, and sends this to the app server. This is often used as a sole device identifier, serving as a proxy for user authentication.\n\n\nHowever, these details are not reliable, and can sometimes return bogus information. For example, mobile devices without a telephony component (e.g. tablet) would not have this type of identifier; some phones contain bugs wherein this data is not uniquely deterministic, and can return junk data or identical values for all devices of the same model. Additionally,\u00a0this hardware identifier might survive device resets, causing mis-identification if a user wipes his mobile device and passes it to another user.\u00a0\n\n\nMoreover, if the app server collects and correlates device-specific PII, e.g. IMEI, this will be considered a privacy violation.\u00a0\n\n\nFinally, reading this data will typically require elevated privileges for the mobile app, e.g. `READ_PHONE_STATE` on Android.",
        "impact": "If a device hardware identifier is being used to identify the mobile device, and by extension the users themselves, this could be abused or bypassed in various ways. In general, this is a weak form of authentication and can allow an attacker to impersonate another device, and\u00a0even lead to accidental cases of mistaken identity.\u00a0\n\n\nFurthermore, depending on the specific usage scenario, this could be considered a leak of personally identifiable information (PII) or other private data, such as IMEI of users' mobile devices.",
        "mitigation": "* Avoid collecting and tracking hardware-specific identifiers, or any other form of PII.\n* If appropriate, implement strong user-specific authentication instead of device authentication, for example user passwords.\n* If it is required to identify the device,\u00a0prefer app-specific (or installation-specific) identifiers over global device identifiers such as IMEI. In particular, use an app-generated UUID during installation."
    },
    "side channel data leakage": {
        "title": "Side Channel Data Leakage",
        "desc": "The application writes personal information, such as passwords or account information, to external media such as an SD card or to a log file, or, the application sends contacts or GPS location outside the device (over HTTP, email, or SMS). This can expose sensitive information.",
        "impact": "Sensitive information could be exposed, or malware could steal the information.",
        "mitigation": "1. Ideally, don\u2019t send contacts or GPS location out of the phone at all. If it is necessary to do so, send it over an encrypted channel such as HTTPS.\n2. Ideally, don\u2019t write sensitive data to log files or to external media. If it is necessary to do so, the data should be encrypted first."
    },
    "missing x frame options": {
        "title": "Missing X Frame Options",
        "desc": "Failure to utilize the \"X-FRAME-OPTIONS\" header will likely allow attackers to perform Clickjacking attacks. Properly utilizing the \"X-FRAME-OPTIONS\" header would indicate to the browser to disallow embedding the web-page within a frame, mitigating this risk, if the browser supports this header. All modern browsers support this header by default.",
        "impact": "Allowing setting of web-pages inside of a frame in an untrusted web-page will leave these web-pages vulnerable to Clickjacking, otherwise known as a redress attack. This may allow an attacker to redress a vulnerable web-page by setting it inside a frame within a malicious web-page. By crafting a convincing malicious web-page, the attacker can then use the overlayed redress to convince the user to click a certain area of the screen, unknowingly clicking inside the frame containing the vulnerable web-page, and thus performing actions within the user's context on the attacker's behalf.",
        "mitigation": "Utilize the \"X-FRAME-OPTIONS\" header flags according to business requirements to restrict browsers that support this header from allowing embedding web-pages in a frame:\n\n\n\u00b7 \"X-Frame-Options: DENY\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame, including the current web-site.\n\n\n\u00b7 \"X-Frame-Options: SAMEORIGIN\" will indicate to the browser to disallow\u00a0embedding any web-page inside a frame,\u00a0excluding the current web-site.\n\n\n\u00b7 \"X-Frame-Options: ALLOW-FROM https://example.com/\" will indicate to the browser to disallow embedding any web-page inside a frame,\u00a0excluding\u00a0the web-site listed after the ALLOW-FROM parameter."
    },
    "no request validation": {
        "title": "No Request Validation",
        "desc": "Since request validation is promptly blocks multiple meta-characters, ways to locally or globally disabling request validations have been introduced. However, using these overrides may leave the application exposed to attack.",
        "impact": "Request validation attempts to automatically identify potentially malicious content in user-provided inputs; if a potentially malicious\u00a0input is detected, the server rejects the entire request and throws an exception. Disabling this additional layer of defense may put the application at risk from malicious input, which may lead to cross-site scripting attacks, HTML injection, and more.",
        "mitigation": "Always consider the need and weigh the risks when explicitly disabling request validation. If disabling of request validation is required, consider the risks and outputs of any unvalidated inputs, and implement a different input validation solution appropriate to the output's context, as required.\n\n\nNote that Request Validation does not constitute as a sanitizer against cross-site scripting (XSS), HTML injection or any other form of attack. Request Validation\u00a0is simply an additional layer to assist in mitigation of these attacks, and it is recommended to have\u00a0it enabled."
    },
    "stored command injection": {
        "title": "Stored Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application reads the command from the database, and passes it as a string to the Operating System. The attacker may be able to load the malicious payload into the database fields beforehand, causing the application to load that command.\u00a0This unvalidated data is then executed by the OS as a system command, running with the same system privileges as the application.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege.\n* If absolutely necessary to call a system command or execute external program with untrusted data, initialize the\u00a0`Process`\u00a0with a hardcoded command or executable path (set to\u00a0`ProcessStartInfo.FileName`), and\u00a0use\u00a0`ProcessStartInfo.Arguments`\u00a0to isolate the externally-controlled parameters from the hardcoded executable target. Set the\u00a0`UseShellExecute`\u00a0property to\u00a0`false`.\n* Do not directly execute any shell or command interpreters, such as\u00a0`cmd`,\u00a0`make`, or\u00a0`powershell`, with any untrusted data that can be potentially controlled by an attacker."
    },
    "stored ldap injection": {
        "title": "Stored LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code.\n* Consider replacing direct LDAP queries with a higher-level, uniform object model for user management or authentication, depending on LDAP usage. For example, the classes in the `System.DirectoryServices.AccountManagement` namespace, including `UserPrincipal`, `GroupPrincipal`, `PrincipalContext` and more; or even the `MembershipProvider` or `ASP.NET Identity` models, as appropriate."
    },
    "stored xpath injection": {
        "title": "Stored XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code.\n* Use parameterized XPath queries instead of string concatenation, to fully separate the untrusted data from the expression.\n* Precompile the XPath query, containing XPath variables with\u00a0`$VARIABLE_NAME`\u00a0syntax, using\u00a0`XPathExpression.Compile()`\u00a0(or one of the various other\u00a0`.Compile()`\u00a0methods). Then call\u00a0`XPathExpression.SetContext()`\u00a0on the compiled query, passing in an instance of a custom\u00a0`XsltContext`\u00a0class. This custom subclass of\u00a0`XsltContext`\u00a0should define the required variables, and implement a resolving mechanism to return the appropriate values. Afterwards, call\u00a0`XPathNavigator.Evaluate()`\u00a0with the defined\u00a0`XPathExpression`\u00a0object."
    },
    "unchecked return value": {
        "title": "Unchecked Return Value",
        "desc": "The application calls a function, but does not check the result of this function's return values. The application simply ignores the result value, using it or passing it on with ensuring it is correct and desired, first.",
        "impact": "A program that does not check function return values could cause the application to enter an undefined state. This could lead to unexpected behavior and unintended consequences, including inconsistent data, system crashes or other error-based exploits.",
        "mitigation": "* Always check the result of any called function that returns a value, and verify the result is an expected value.\n* Ensure the calling function responds to all possible return values.\n* Expect runtime errors and handle them gracefully. Explicitly define a mechanism for handling unexpected errors."
    },
    "leftover debug code": {
        "title": "Leftover Debug Code",
        "desc": "During application development, it is common for programmers to implement specialized code, in order to ease debugging and testing. Often the programmer will even\u00a0enable the debug code to bypass security mechanisms, so as to focus the tests on the specific functionality and isolate it from the security architecture.\u00a0\n\n\nThis debug or test code is not removed from the codebase, and is then included in the software build and deployed to the production environment.",
        "impact": "Tests and debugging code are not intended to be deployed to the production environment, and can create unintended entry points, thus increasing the application's attack surface. Furthermore, this code is often not properly tested or maintained, and can retain historic vulnerabilities that were fixed in other parts of the codebase. Often, debug code will contain a functional \"back door\", by enabling the programmer to bypass operational security mechanisms, such as authentication or access controls.",
        "mitigation": "- Remove all debug code before deploying or building the application. Ensure the configuration settings are not defined to enable debug mode.\u00a0\n\u00a0- Implement all test code via a dedicated test framework, which can isolate the test case code from the rest of the application.\u00a0\n\u00a0- Avoid implementing special \"test code\", \"debugging-time\" functionality, or \"secret\" interfaces or parameters in the application code itself.\u00a0\n\u00a0- Define and implement a standard and automatic build / deployment process, using dedicated CI / CD tools, that can automatically configure the deployed application, exclude all temporary code, and include only intended application code."
    },
    "insecure cookie": {
        "title": "Insecure Cookie",
        "desc": "The web application framework by default does not set the \"secure\" flag for the application's sessionID cookie, and other sensitive application cookies. Likewise, the application does not explicitly use the \"secure\" cookie flag, allowing them to be sent in plaintext over an insecure session.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, should be sent to the server over a secure network communication (HTTPS) in order to prevent attackers from sniffing the traffic and stealing those cookies. Unless the web application explicitly prevents this by using the \"secure\" cookie flag, these cookies will also be sent over insecure traffic, which can lead to session hijacking and impersonation.",
        "mitigation": "* Always set the \"secure\" flag for any sensitive server-side cookies.\n* If the application explicitly handles cookies directly in application code, set the \"secure\" flag for sensitive cookies set by the application.\n**Secure-Code Approach**\n* Configure the application to always use \"secure\" cookies, in the site-wide configuration file.\n* Enable the Secure flag or use the relevant Set-Secure API in the code."
    },
    "cookie injection": {
        "title": "Cookie Injection",
        "desc": "Cookie injection occurs when input values provided by the user are inserted into cookies, either as a name, a value or a raw name-value pair.",
        "impact": "Cookie injection may allow attackers to inject values into a user's cookie string. Malicious cookie values may allow bypassing certain cross-site request forgery (XSRF) mitigations, perform cross-site scripting (XSS) attacks, exploit session fixation to hijack user sessions, cause denial of service via flooding of the cookie jar, and more.",
        "mitigation": "\u00b7 Do not rely on user inputs to set cookies - instead, determine the desired cookie value from a dynamic preset of possible cookie values, unless otherwise required.\n\n\n\u00b7 Never rely on users to set cookie names to avoid instances where inputs can be used to override other cookies which are in use by the application.\n\n\n\u00b7 If inserting dynamic input values into cookie values is required, ensure they are properly sanitized for their appropriate context - for example, if they are retrieved and rendered in HTML, ensure they are sanitized for HTML meta-characters to mitigate cross-site scripting (XSS)."
    },
    "improper restriction of xxe ref": {
        "title": "Improper Restriction of XXE Ref",
        "desc": "An attacker could upload an XML document that contains a DTD declaration, in particular an entity defintion that refers to a local file on the server's disk, e.g. `<!ENTITY xxe SYSTEM \"file:///c:/boot.ini\">`. The attacker would then include an XML entity reference that refers back to that entity definition, e.g. `<div>&xxe;</div>` . If the parsed XML document is then returned to the user, the result will include the contents of the sensitive system file.\u00a0\n\n\nThis is caused by the XML parser, which is configured to automatically parse DTD declarations and resolve entity references, instead of disabling both DTD and external references altogether.",
        "impact": "An\u00a0application that will parse and replace DTD entity references, in an XML document that the user controls, can allow an attacker to craft an XML document to read arbitrary server files. This XML document could contain an XML entity reference, which refers to an embedded DTD entity definition that points to any local file. This would enable the attacker to retrieve any arbitrary system file on the server.",
        "mitigation": "Generic Guidance:\n\n* Avoid processing user input directly, where possible.\n* If necessary to receive XML from the user, ensure the XML parser is restricted and constrained.\n* In particular, disable DTD parsing and resolving of entities. Apply a strict XML schema on the server, and validate the input XML accordingly.\n\n\nSpecific Recommendations:\n\n* Use safe XML parsers, and disable DTD parsing and entity resolving.\n* Do not enable DTD parsing or entity resolving."
    },
    "exposure of resource to wrong sphere": {
        "title": "Exposure of Resource to Wrong Sphere",
        "desc": "One of the application's classes exposes an internal variable as a public field, without constraining access, by exposing it as a property. Alternatively, public fields can be exposed without allowing their values to be externally modified.",
        "impact": "If a\u00a0class exposes an internal variable as a public field, without constraining access, the variable can be modified in unexpected ways, allowing an external consumer of the class to set arbitrary, unallowed values to the field. This could cause\u00a0to unexpected behavior if the class (or other consumers) make assumptions about the value of that variable. This could even lead to additional vulnerabilities, depending on how this value is used.",
        "mitigation": "* Avoid exposing internal variables and specific implementation as public fields.\n* Prefer exposing data as properties, and implement data validation and control in the property code as needed.\n* When exposing\u00a0a public field, constrain the value to be readonly via use of `final` modifier."
    },
    "heap inspection": {
        "title": "Heap Inspection",
        "desc": "String variables are immutable - in other words, once a string variable is assigned, its value cannot be changed or removed. Thus, these strings may remain\u00a0around in memory, possibly in multiple locations, for an indefinite period of time until the garbage collector happens to remove it. Sensitive data, such as passwords, will remain exposed in memory as plaintext with no control over their lifetime.\n\n\nWhile it may still be possible to retrieve data from memory, even if it uses a mutable container that is cleared, or retrieve a decryption key and decrypt sensitive data from memory - layering sensitive data with these types of protection would significantly increase the required effort to do so. By setting a high bar for retrieving sensitive data from memory, and reducing the amount and exposure of sensitive data in memory, an adversary is significantly less likely to succeed in obtaining valuable data.",
        "impact": "All variables stored by the application in unencrypted memory can potentially be retrieved by an unauthorized user, with privileged access to the\u00a0machine. For example, a privileged attacker could attach a debugger to the running process, or retrieve the process's memory from the swapfile or crash dump file.\u00a0Once the attacker\u00a0finds the user passwords in memory, these can be reused to easily impersonate the user to the system.",
        "mitigation": "When it comes to avoiding Heap Inspection, it is important to note that, given any read access to memory or a memory dump of an application, it is always likely to disclose some sensitive data to an adversary - these suggestions are part of defense-in-depth principles for protection of sensitive data in cases where such memory read access is successfully obtained. These recommendations will enable significant reduction in the lifespan and exposure of sensitive data in memory; however - given enough time, effort and unlimited access to memory, they will only go so far in protecting sensitive data being used by the application. The only way to handle Heap Inspection issues is to minimize and reduce data exposure, and obscure it in memory wherever possible.\n\n* Do not store sensitive data, such as passwords or encryption keys, in memory in plain-text, even for a short period of time.\n* Prefer to use specialized classes that store\u00a0encrypted data in memory to ensure it cannot be trivially retrieved from memory.\n* When required to use sensitive data in its raw form, temporarily store it in mutable data types, such as byte arrays, to reduce readability from memory, and then promptly zeroize the\u00a0memory locations, to reduce exposure duration of this data while in memory.\n* Ensure that memory dumps are not exchanged with untrusted parties, as even by ensuring all of the above - it may still be possible to reverse-engineer encrypted containers, or retrieve bytes of sensitive data from memory and rebuild it.\n* In .NET, instead of storing passwords in immutable strings, prefer to use an encrypted memory object, such as SecureString or ProtectedData."
    },
    "value shadowing": {
        "title": "Value Shadowing",
        "desc": "Value Shadowing occurs when a certain set of information can be searched and may contain values of the same name, whose precedence over one another is not immediately clear.\n\n\nFor example, in .NET, a Request object can be searched via an index (Request[param]) - however, the value whose key is\u00a0\"param\" in this implementation may be a query string parameter, a form parameter, a header, a server variable and more. This causes the value of Request[\"value\"] to be ambiguous, which could be leveraged for bypassing logic restrictions, security measures and value checks.",
        "impact": "Value shadowing may result in an incorrect reference, such as one value being validated while a completely different one is used, or a value assumed to be safe (such as headers automatically issued by the browser, or server parameters) which can actually be overwritten by user inputs.",
        "mitigation": "Always explicitly refer to the exact data context from which values are retrieved."
    },
    "heuristic 2nd order sql injection": {
        "title": "Heuristic 2nd Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by updating fields in the database. Later, the application reads this data from the database, and embeds it within the SQL query, as SQL commands. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Prefer using database-specific\u00a0`DbCommand`\u00a0subclasses with\u00a0`DbParameter`\u00a0objects and API. Set the command's\u00a0`CommandType`\u00a0property to\u00a0`CommandType.StoredProcedure`\u00a0, and add the parameters to the\u00a0`.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "heuristic db parameter tampering": {
        "title": "Heuristic DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "heuristic parameter tampering": {
        "title": "Heuristic Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "heuristic sql injection": {
        "title": "Heuristic SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that the apparent database access is encapsulated in an external component or API. Thus, the attacker is able to inject arbitrary data into the SQL query, by way of altering the user input. This query is then passed to the API or component, where it is presumably submitted to the database server.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nNote that in this case, the injection appears to be in an external component, which might be implementing its own internal checks.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer standard data access libraries and platform APIs, instead of using opaque 3rd party drivers.\n* Prefer using database-specific\u00a0`DbCommand`\u00a0subclasses with\u00a0`DbParameter`\u00a0objects and API. Set the command's\u00a0`CommandType`\u00a0property to\u00a0`CommandType.StoredProcedure`\u00a0, and add the parameters to the\u00a0`.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "heuristic stored xss": {
        "title": "Heuristic Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn attacker could use legitimate access to the application to submit modified data to the application\u2019s data-store. This would then be used to construct the returned web page, triggering the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* In .NET, when using Razor, consider that Razor is effective at sanitizing some HTML meta-characters, such as\u00a0`<`,\u00a0`>`,\u00a0`'`, \", but ignores characters that may use to evade sanitization in Javascript contexts and result in XSS, such as\u00a0`\\`,\u00a0\u00a0and line breaks. Consider Razor as a safe sanitizer only when outputting dynamic data in an HTML context."
    },
    "heuristic xsrf": {
        "title": "Heuristic XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    },
    "code injection": {
        "title": "Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege.\n* If dynamic execution is necessary, run all dynamic code in an external process, and pass the external data as a parameter to the process.\n* Alternatively, it is possible to perform dynamic execution of code in an\u00a0isolated sandbox, such as .NET\u2019s `AppDomain`\u00a0with `Evidence` to restrict its `PermissionSet` to the minimum, using `SecurityManager.GetStandardSandbox()`. (Note that this can never provide complete protection from sandbox exploits, and should be avoided if possible.)"
    },
    "command injection": {
        "title": "Command Injection",
        "desc": "The application runs an OS system-level command to complete it's task, rather than via the application code. The command includes untrusted data, that may be controllable by an attacker. This untrusted string may contain malicious system-level commands engineered by an attacker, which could be executed as though the attacker were running commands directly on the application server.\n\n\nIn this case, the application receives data from the user input, and passes it as a string to the Operating System. This unvalidated data is then executed by the OS as a system command, running with the same system privileges as the application.",
        "impact": "An attacker could run arbitrary system-level OS commands on the application server host. Depending on the application\u2019s OS permissions, these could include:\n\n* File actions (read / create / modify / delete)\n* Open a network connection to the attacker\u2019s server\n* Start and stop system services\n* Modify the running application\n* Complete server takeover",
        "mitigation": "* Refactor the code to avoid any direct shell command execution. Instead, use platform provided APIs or library calls.\n* If it is impossible to remove the command execution, execute only static commands that do not include dynamic, user-controlled data.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified format, rather than rejecting bad patterns (blacklist). Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In order to minimize damage as a measure of defense in depth, configure the application to run using a restricted user account that has no unnecessary OS privileges.\n* If possible, isolate all OS commands to use a separate dedicated user account that has minimal privileges only for the specific commands and files used by the application, according to the Principle of Least Privilege.\n* If absolutely necessary to call a system command or execute an external program with user input, initialize the `Process` with a hardcoded command or executable path (set to `ProcessStartInfo.FileName`), and\u00a0use `ProcessStartInfo.Arguments` to isolate the user-controlled parameters from the hardcoded executable target. Set the `UseShellExecute` property to `false`.\n* Do not directly execute any shell or command interpreters, such as `cmd`, `make`, or `powershell`, with user-controlled input."
    },
    "connection string injection": {
        "title": "Connection String Injection",
        "desc": "In order to communicate with the database, or with another external server (for example, Active Directory), the application dynamically constructs a connection string. This connection string includes untrusted data, which may be controlled by a malicious user. Since it is not constrained or properly sanitized, the untrusted data could be used to maliciously manipulate the connection string.",
        "impact": "If an attacker could manipulate the application\u2019s connection string to the database server, they might be able do any of the following:\n\n* Damage application performance (by increasing the MIN POOL SIZE)\n* Tamper with the network connection (for example, via TRUSTED CONNECTION)\n* Direct the application to the attacker\u2019s bogus database\n* Discover the password to the system account on the database (by a brute-force attack).",
        "mitigation": "* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Do not allow users to control the database connection string. Avoid dynamically building connection strings based on untrusted data, especially user input.\n* Store all connection strings in appropriate configuration mechanisms. If it is necessary to dynamically construct a connection string at runtime, do not include untrusted data directly in the connection string; instead, allow users to select from pre-defined connection strings.\n* If it is absolutely necessary to dynamically construct the connection string at runtime,\u00a0utilize platform-provided classes, such as `DbConnectionStringBuilder` and concrete implementation classes."
    },
    "ldap injection": {
        "title": "LDAP Injection",
        "desc": "The application communicates with an LDAP server, such as Active Directory, by sending a textual LDAP query or command. The application creates the query by simply concatenating strings, including untrusted data that may be controlled by an attacker. Since the data is neither validated nor properly sanitized, the input could contain LDAP commands that would be interpreted as such by the LDAP server.",
        "impact": "An attacker that is able to alter the\u00a0application\u2019s LDAP query with arbitrary data would have control over the results returned from the User Directory server. Most commonly, this would enable an attacker to bypass authentication, or impersonate another user. \u00a0\n\n\nFurthermore, this flaw can have various additional effects, depending on the architecture and usage model of the Directory service.\u00a0Depending on how the application is using LDAP, the attacker could potentially do any of the following:\n\n* Bypass authentication\n* Impersonate another user\n* Subvert authorization\n* Escalate privileges\n* Modify user attributes and group membership\n* Access sensitive data",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist. Accept only data fitting a specified structure, rather than reject bad patterns.  \n\nCheck for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid creating LDAP queries that are directly dependent on untrusted external data, if possible. For example, retrieve the user object from the LDAP server, and examine it's attributes in application code.\n* Consider replacing direct LDAP queries with a higher-level, uniform object model for user management or authentication, depending on LDAP usage. For example, the classes in the `System.DirectoryServices.AccountManagement` namespace including `UserPrincipal`, `GroupPrincipal`, `PrincipalContext` and more; or even the `MembershipProvider` or `ASP.NET Identity` models, as appropriate."
    },
    "reflected xss all clients": {
        "title": "Reflected XSS All Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* In .NET, when using Razor, consider that Razor is effective at sanitizing some HTML meta-characters, such as `<`, `>`, `'`, `\"`, but ignores characters that may use to evade sanitization in Javascript contexts and result in XSS, such as `\\`, ` and line breaks. Consider Razor as a safe sanitizer only when outputting dynamic data in an HTML context."
    },
    "resource injection": {
        "title": "Resource Injection",
        "desc": "The application allocates a resource based on user input, enabling an attacker to control it.",
        "impact": "The impact of resource injection is highly implementation dependent. By allowing attackers to control server-side resource I/O, such as network, storage or memory, an attacker may reroute these resources to expose them, generate multiple instances to exhaust the resource, or create a resource in a manner that would block other I/O operations.",
        "mitigation": "* Do not allow a user or untrusted data to define parameters of I/O, such as network sockets, storage access or other resource configurations."
    },
    "second order sql injection": {
        "title": "Second Order SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the database, typically via forms on other web pages. Afterwards, the application reads this data from the database, and embeds it within the SQL query, as SQL commands.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer using database-specific\u00a0`DbCommand`\u00a0subclasses with\u00a0`DbParameter`\u00a0objects and API. Set the command's\u00a0`CommandType`\u00a0property to\u00a0`CommandType.StoredProcedure`\u00a0, and add the parameters to the\u00a0`.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "sql injection": {
        "title": "SQL Injection",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Prefer using database-specific `DbCommand` subclasses with `DbParameter` objects and API. Set the command's `CommandType` property to `CommandType.StoredProcedure` , and add the parameters to the `.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "stored xss": {
        "title": "Stored XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nIn order to exploit this vulnerability, an attacker would load the malicious payload into the data-store, typically via regular forms on other web pages. Afterwards, the application reads this data from the data-store, and embeds it within the web page as displayed for another user.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nAn attacker could use legitimate access to the application to submit modified data to the application\u2019s data-store. This would then be used to construct the returned web page, triggering the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* In .NET, when using Razor, consider that Razor is effective at sanitizing some HTML meta-characters, such as\u00a0`<`,\u00a0`>`,\u00a0`'`, \", but ignores characters that may use to evade sanitization in Javascript contexts and result in XSS, such as\u00a0`\\`,\u00a0\u00a0and line breaks. Consider Razor as a safe sanitizer only when outputting dynamic data in an HTML context."
    },
    "utf7 xss": {
        "title": "UTF7 XSS",
        "desc": "Application code sets the response header for charset to UTF-7, indicating to older browsers to decode UTF-7 characters. These UTF-7 characters could be decoded into HTML meta-characters, resulting in XSS.",
        "impact": "UTF-7 encoding is a form of encoding for special characters using ASCII characters. However, the way with which UTF-7 represents certain HTML characters is using normal non-meta-characters, which could allow bypassing HTML encoding and performing an XSS attack on the web-page.\n\n\nFor example, consider the following UTF-7 string:\n+ADw-script+AD4- alert(123)+ADw-/script+AD4-\n\n\nThis string, under UTF-7 encoding, will indicate to the browser to decode it as `<script>alert(123)</script>` , which would result in an XSS on browsers that support it.",
        "mitigation": "Avoid using UTF-7 as a web-page character-set encoding."
    },
    "xpath injection": {
        "title": "XPath Injection",
        "desc": "The application queries an XML document by using a textual XPath query. The application creates the query by simply concatenating strings, including untrusted data potentially under an attacker's control. Since the external data is neither checked for data type validity nor subsequently sanitized, the data could be maliciously crafted to cause the application to select the wrong information from the XML document.",
        "impact": "An attacker that can modify the XPath query with an arbitrary expression will be able to control which nodes in the XML document will be selected, and thus what data the application will process. This can have various effects depending on the type of XML document and its usage, including retrieval of secret information, control of application flow, modification of sensitive data, reading arbitrary files, or even authentication bypass, impersonation, and privilege escalation.",
        "mitigation": "* Validate all external data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* Avoid making the XPath query dependent on external data.\n* If it is absolutely necessary to include untrusted data in the query, the data must at least be first properly validated or sanitized.\n* If possible, it is preferable to map XPath queries to external parameters, maintaining separation between data and code.\n* Use parameterized XPath queries instead of string concatenation, to fully separate the input from the expression.\n* Precompile the XPath query, containing XPath variables with `$VARIABLE_NAME` syntax, using\u00a0`XPathExpression.Compile()`\u00a0(or one of the various other `.Compile()` methods). Then call `XPathExpression.SetContext()` on the compiled query, passing in an instance of a custom\u00a0`XsltContext` class. This custom subclass of `XsltContext` should define the required variables, and implement a resolving mechanism to return the appropriate values. Afterwards, call\u00a0`XPathNavigator.Evaluate()` with the defined `XPathExpression` object."
    },
    "blind sql injections": {
        "title": "Blind SQL Injections",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn this case, the attacker does not need to rely on the application returning data from the database. Instead, it is possible to leverage existing tools that perform a series of boolean tests based on varying user input, relying only on the existence of application errors to indicate server state. Thus, the full database content can gradually be obtained, one bit at a time.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n\nIn this case, while the actual exploit is constrained to single bit of information at a time, it is still possible to eventually retrieve all data from the system, though this process is more time consuming and would be rather noisy. Note that other consequences, such as data modification and creation, code execution, etc. are unaffected, and still equally exploitable.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* Do not allow the user to dynamically provide the name of the queried table. Furthermore, if possible, completely avoid dynamically specifying table names.\n* Ensure that all exceptions are properly handled, without leaking information on the errors, server state, or that an error occurred at all.\n* Prefer using database-specific\u00a0`DbCommand`\u00a0subclasses with\u00a0`DbParameter`\u00a0objects and API. Set the command's\u00a0`CommandType`\u00a0property to\u00a0`CommandType.StoredProcedure`\u00a0, and add the parameters to the\u00a0`.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "client side only validation": {
        "title": "Client Side Only Validation",
        "desc": "Relience on client side validation\u00a0only",
        "impact": "Bypassing a client side validation may lead to\u00a0unexpected\u00a0and tampered data to the server.",
        "mitigation": "It is highly recommended to validate the input in the server side, alongside client side validation."
    },
    "dangerous file upload": {
        "title": "Dangerous File Upload",
        "desc": "The application allows users to upload a file to the application, which is saved to a file within the web site's directory. The application does not apply thorough validation checks on the uploaded file, especially with regards to the file type or contents. This enables the attacker to upload executable files, in particular web server code such as .ASP, .PHP, and .JSP files, and others.\u00a0\n\n\nWhen this is followed by a regular request to the web application for the previously uploaded files, the application server will then proceed to execute the code in the uploaded file, giving the attacker direct access to the command execution environment.",
        "impact": "An attacker that exploits this vulnerability would be able to cause the application server to execute arbitrary code, allowing the attacker to alter\u00a0the application, run any\u00a0operating system command, and even take over the server altogether, depending on the application's system privileges.",
        "mitigation": "Generic Guidance:\n\n* **Storage:** If possible, avoid saving uploaded files to disk on the server, instead storing them in an external data storage, e.g. database or document management system.\n* **Location:** User files should be stored in an isolated directory, outside of the web site's directory with direct browsing disabled. When required, the application should explicitly read the file in code, and stream the contents to the user applicatively.\n* **Non-execution:** Files uploaded from users should be explicitly marked as non-executable by the web / application server, e.g. in configuration file or by\u00a0directory.\n* **Validation:**\u00a0Always validate all user input. In particular, enforce a whitelist of allowed file-types, according to the file extenstion and/or MIME type. Do not allow arbitrary files (such as .ASP, .PHP, .JSP, .EXE, .HTML, and so on). For example, accept only images such as\u00a0.GIF, .JPG, .PNG, .BMP, and so on.\n* **Renaming:**\u00a0Explicilty impose a pre-defined extension according to the file type, before saving the file to disk. This can be a hardcoded extension, or a configured list of allowed file types.\n* **Privileges:**\u00a0As a measure of Defense-in-Depth, configure the application server to execute in a limited system account, with minimal OS privileges.\n\n\nSpecific Recommendations:\u00a0\n\n* **Validation:**\u00a0Validate the uploaded filename before saving the file to disk, and verify the total file size does not exceed defined limits."
    },
    "improper resource shutdown or release": {
        "title": "Improper Resource Shutdown or Release",
        "desc": "The application code allocates resource objects, but does not ensure these are always closed and released in a timely manner. This can include database connections, file handles, network sockets, or any other resource that needs to be released.\u00a0In some cases,\u00a0these might be released - but only if everything works as planned; if there is any runtime exception during the normal course of system operations, resources start to leak.\u00a0\n\n\nNote that even in managed-memory languages such as Java, these resources must be explicitly released. Many types of resource are not released even when the Garbage Collector runs; and even if the the object would eventually release the resource, we have no control over when the Garbage Collector does\u00a0run.",
        "impact": "Unreleased resources can cause a drain of those available for system use, eventually causing general reliability and availability problems, such as performance degradation, process bloat, and system instability. If a resource leak\u00a0can be intentionally exploited by an attacker, it may be possible to cause a widespread DoS (Denial of Service) attack. This might even expose sensitive information between unprivileged users, if the resource continues to retain\u00a0data or user id\u00a0between subsequent allocations.",
        "mitigation": "* Always close and release all resources.\n* Ensure resources are released (along with\u00a0any other necessary cleanup) in a `finally { }` block. Do not close resources in a `catch { }` block, since this is not ensured to be called.\n* Explicitly call .close() on any instance of a class that implements the `Closable` or `AutoClosable` interfaces.\n* Alternatively, an even better solution is to use the try-with-resources idiom, in order to automatically close any defined\u00a0`AutoClosable`\u00a0instances."
    },
    "just one of equals and hash code defined": {
        "title": "Just One of Equals and Hash code Defined",
        "desc": "The general language contract for implementing classes requires the class to implement both `.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods (or neither). This requirement is important for hash tables and other data structures, and to ensure the class behavior is consistent between these methods. However, this class does in fact only implement one of these methods, but not the other, resulting in a broken object.",
        "impact": "If an application class explictly defines an override for only one of the\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, but not the other, this can negatively affect the application's integrity, and possibly cause inconsistent and unexpected results. This may also affect system performance, when using instances of this class in a hashtable or set.",
        "mitigation": "* Define overriding implementations for both\u00a0`.equals()`\u00a0and\u00a0`.hashCode()`\u00a0methods, or not at all. If one is overridden, then both must be.\n* Note the general principle is: if `x.equals(y)`, then `x.hashCode()` must be equal to `y.hashCode()`.\n* Consider using the `EqualsBuilder` and `HashCodeBuilder` classes from the Apache Commons library."
    },
    "cleansing canonicalization and comparison errors": {
        "title": "Cleansing Canonicalization and Comparison Errors",
        "desc": "Filesystem paths and Internet URLs can be represented in an unlimited number of different ways, using various encodings, folder misdirection, and path obfuscation techniques. If a path or address is not properly sanitized and fully canonicalized into it's most basic, simplified form, it would be impossible to check all possible variants of this path. Hence, any decision based on a specific attributes of the path would likely be mistaken, and can be evaded by an active attacker.",
        "impact": "If a security decision, such as access control for example, is taken based on unsanitized, user-controlled data, it may be possible for\u00a0an attacker to manipulate the format of the data,\u00a0and thus obfuscate the actual\u00a0target. For example, if users are allowed to read any page that has\u00a0their user id in the URL, a user can request a URL with multiple user ids. Another example could be an administrative interface, wherein users are forbidden from accessing any page under the `/admin/` folder; an attacker can hide the actual target by sending a request to `/NOTEXISTS/../admin/`\u00a0. This would evade the check for URLs starting with \"admin/\", if the request URL is not canonicalized before checking.",
        "mitigation": "* Avoid performing security decisions based on untrusted, user-controlled input.\n* Always sanitize all user input.\n* Before making any decision based on a URL or path parameter, always transform it first into its canonical form, before making any decisions or doing any checks on it."
    },
    "hardcoded absolute path": {
        "title": "Hardcoded Absolute Path",
        "desc": "Hardcoded paths are less flexible, and do not allow the application to account for changes in the environment. For example, the program might be installed in a different directory than the default. Likewise, different system languages and OS architectures can change the names of the system folders; for example, in a Spanish Windows machine there could\u00a0be\u00a0\"`C:\\Archivos de programa (x86)\\`\" instead of \"`C:\\Program Files\\`\".\u00a0\n\n\nMoreover, on Windows by default all directories and files created outside of the system folders and outside the user's profile, will be allow full read and write access to any authenticated user. An unauthorized, malicious user could access any sensitive data in these folders, despite the application assuming they are protected. Even worse, an attacker\u00a0could overwrite existing programs in these unprotected folders and plant malicious code, which\u00a0will be activated by the application.",
        "impact": "Generally, hardcoding absolute paths makes the application brittle, and will prevent the program from operating properly in some environments that do not have the identical file system structure. This will also cause software maintenance problems in future versions of the application, if the design or requirements were to change.\u00a0\n\n\nAdditionally, if the application uses this path to read or write data, this can cause a breach of confidentiality or\u00a0allow malicious input into the program. In some situations, this vulnerability might even allow a malicious user to override the expected functionality, and cause the application to run any arbitrary program and execute any code the attacker deploys to the server.",
        "mitigation": "* Do not hardcode absolute paths into the application.\n* Instead, store the absolute paths in an external configuration file, that can be modified as required for each environment.\n* Alternatively, use paths relative to the current application, if the target file is in a subdirectory of the application's root.\n* Do not assume a specific file system structure, outside of the application's subdirectories. On Windows, use the built-in expandable variables, such as `%WINDIR%`, `%PROGRAMFILES%,` and `%TEMP%`.\n* On Linux and other OS where available, implement a system jail (chroot) for the application, and store\u00a0all programs and data files there only.\n* Prefer storing all executables under the protected program directory (under \"`C:\\Program Files\\`\" by default on Windows).\n* Do not store sensitive data or configuration files in arbitrary folders. Likewise, do not store data files in the program directory. Instead, use the designated folders as intended, i.e. `%PROGRAMDATA%` and `%APPDATA%`\u00a0on Windows, respectively.\n* Configure hardened permissions to the most restricted as possible, according to the Principle of Least Privilege. Consider implementing this automatically in the installation and setup routines."
    },
    "use of hardcoded password": {
        "title": "Use Of Hardcoded Password",
        "desc": "The application codebase\u00a0has string literal passwords embedded in the source code. This hardcoded value is used either to compare to user-provided credentials, or to authenticate downstream to a remote system (such as a database or a remote web service). \u00a0\n\n\nAn attacker only needs to gain access to the source code to reveal the hardcoded password. Likewise, the attacker can reverse engineer the compiled application binaries, and easily retrieve the embedded password. Once found, the attacker can easily use the password in impersonation attacks, either directly on the application or to the remote system.\u00a0\n\n\nFurthermore, once stolen, this password cannot be easily changed to prevent further misuse, unless a new version of the application is compiled. Moreover, if this application is distributed to numerous systems, stealing the password from one system automatically allows a class break in to all the deployed systems.",
        "impact": "Hardcoded passwords expose the application to password leakage. If an attacker gains access to the source code, she will be able to steal the embedded passwords, and use them to impersonate a valid user. This could include impersonating end users to the application, or impersonating the application to a remote system, such as a database or a remote web service.\u00a0\n\n\nOnce the attacker succeeds in impersonating the user or application, she will have full access to the system, and be able to do anything the impersonated identity could do.",
        "mitigation": "* Do not hardcode any secret data in source code, especially not passwords.\n* In particular, user passwords should be stored in a\u00a0database or directory service, and protected with a strong password hash (e.g. bcrypt, scrypt, PBKDF2, or Argon2). Do not compare user passwords with a hardcoded value.\n* Sytem passwords should be stored in a configuration file or the database, and protected with strong encryption (e.g. AES-256). Encryption keys should be securely managed, and not hardcoded."
    },
    "improper exception handling": {
        "title": "Improper Exception Handling",
        "desc": "The application performs some operation, such as database or file access, that could throw an exception. Since the application is not designed to properly handle the exception, the application could crash.",
        "impact": "An attacker could maliciously cause an exception that could crash the application, potentially resulting in a denial of service (DoS) or unexpected behavior under certain erroneous conditions. Exceptions may also occur without any malicious intervention, resulting in general instability.",
        "mitigation": "Any method that could cause an exception should be wrapped in a try-catch block that:\n\n* Explicitly handles expected exceptions\n* Includes a default solution to explicitly handle unexpected exceptions"
    },
    "improper transaction handling": {
        "title": "Improper Transaction Handling",
        "desc": "The application creates a connection to the database, and explicitly manages the database transaction by committing it when appropriate. However, the code does not explicitly roll back failed transactions, for example in the case of exceptions. This causes the application to rely on implementation-specific behavior, depending on the specific combination of technologies (such as the database server) and resultant configuration.",
        "impact": "Database transactions that are abandoned (if their associated connection is closed, before the transaction is committed or rolled back) can have several different results, depending on implementation and specific technologies in use. While in some scenarios the database will automatically roll back the transaction if the connection is closed, more often it will either automatically commit the transaction in its abortive state, or leave the transaction open indefinitely (depending on its configured timeout value).\u00a0\n\n\nIn the first case, a transaction that is committed after a runtime exception is likely to be in an inconsistent state, incompatible with the current runtime conditions. This would result in situation detrimental to the system's integrity and possibly even stability.\u00a0\n\n\nIn the second case, a transaction that is kept active\u00a0indefinitely would cause the database server to retain its locks on all records and tables affected by the transaction. This could cause general reliability and availability problems, leading to delays, degraded performance, or even deadlocks as one thread waits for the locks to be released.\u00a0\n\n\nIn either case this results in unexpected state, and is dependent on external factors such that the application is not controlling the result.",
        "mitigation": "* Always open database connections and begin transactions within a `try { }` block.\n* Ensure there are no active uncommitted transactions before closing a database connection.\n* Always rollback active transactions in the case of exceptions.\n* After handling the exception, ensure the transaction is rolled back in the `catch { }` block, or possibly in the `finally { }` block."
    },
    "leaving temporary files": {
        "title": "Leaving Temporary Files",
        "desc": "It is very common for applications to use temporary files, as intermediate storage and to aid with processing large amounts of data or long-running calculations. Applications require such files so frequently that most operating systems allocate a dedicated area for temporary files, such as a TEMP directory, and several different mechanisms for creating them exist in most platforms. However, by default these temporary files are not deleted automatically, and will remain on disk indefinitely. If the program does not explicitly and proactively delete the temporary files when it is finished processing them, they might be accessbile to other users of the computer.",
        "impact": "Applications often create temporary files containing sensitive business data or personal information, in order to handle the file generation process in\u00a0several steps, or even as the output of an automatic process. These files, if left exposed\u00a0on disk for an indeterminate period of time, could leak the secret data to unauthorized users.",
        "mitigation": "* Always explicitly delete any temporary file created. Ensure temp file deletion will occur by wrapping it in a `finally { }` block, or call `File.deleteOnExit()` to ensure eventual deletion.\n* Additionally, to ensure that all temporary files will eventually be deleted, consider implementing additional functionality that will periodically scrape and delete all unused, existing temporary files.\n* Ensure all existing file handles or references are closed before attempting deletion."
    },
    "log forging": {
        "title": "Log Forging",
        "desc": "The application writes audit logs upon security-sensitive actions. Since the audit log includes user input that is neither checked for data type validity nor subsequently sanitized, the input could contain false information made to look like legitimate audit log data,",
        "impact": "An attacker could engineer audit logs of security-sensitive actions and lay a false audit trail, potentially implicating an innocent user or hiding an incident.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Validation is not a replacement for encoding. Fully encode all dynamic data, regardless of source, before embedding it in logs.\n3. Use a secure logging mechanism."
    },
    "insufficiently protected credentials": {
        "title": "Insufficiently Protected Credentials",
        "desc": "User passwords are written to the database without being properly encrypted with a cryptographic hash. The application reads clear passwords straight from the database.",
        "impact": "An attacker could steal user credentials, enabling access to user accounts and confidential data.",
        "mitigation": "Store passwords using a cryptographic hash designed as a password protection scheme, such as:\n\n* Argon2\n* bcrypt\n* scrypt\n* PBKDF2 (with random salt) These need to be configured with an appropriately high work effort."
    },
    "information leak through persistent cookies": {
        "title": "Information Leak Through Persistent Cookies",
        "desc": "The application sends sensitive user data, including passwords, back to the user's browser embedded in a cookie. Persistent cookies are stored in a file on the user's computer, where they might be accessed by an unauthorized user, thus exposing the user's password.",
        "impact": "An attacker with access to the user's desktop, or unprotected network connection, could steal the user's password and other sensitive data stored in the cookie. Once the password is stolen, the attacker can impersonate her victim to the application, and do anything the user can do. The application would not be able to discern the difference, since the user's own password was used.",
        "mitigation": "Do not store passwords, or any other secret data besides sessionid, in cookies."
    },
    "potential redos": {
        "title": "Potential ReDoS",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos by injection": {
        "title": "Potential ReDoS By Injection",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos in code": {
        "title": "Potential ReDoS In Code",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "potential redos in static field": {
        "title": "Potential ReDoS In Static Field",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "session clearing problems": {
        "title": "Session Clearing Problems",
        "desc": "The web application tracks user state via a server-side session mechanism, providing the user's browser with a session identifier to allow the server to associate the browser request with the current\u00a0session. Typically the application will use this session object to cache various user-dependent data, however the application never actively removes this data from the session, or actively kills the session. If the user leaves the site after being logged in, the session remains active, even if the browser is closed. This can enable an attacker to continue to use the valid session identifier (e.g. if the user leaves the computer unlocked, or at an Internet cafe), and thus the live session. This will associate with the logged-in user.",
        "impact": "Leaving the user's session in an active state after the user leaves the site may enable an attacker to impersonate the user, via session hijacking. Once the attacker gains the victim's session identifier, the attacker can perform any action in the application that the user is permitted, including accessing the user's personal data such as reading the user's records or changing the user account.",
        "mitigation": "* Provide the user with a manual logout mechanism, to allow users to actively close their session.\n* Implement a session timeout, so that after a specific amount of time the session will automatically be logged out.\n* When logging out the user, call `Session.Abandon()` , and do not suffice with removing the sessionid from the browser's cookie.\n* If the application does not require user sessions, disable the session mechanism in Web.config file:\u00a0`<sessionState mode=\"Off\" />`"
    },
    "thread safety issue": {
        "title": "Thread Safety Issue",
        "desc": "Race Conditions occur when a public, single instance of a resource is used by multiple concurrent logical processes. If the these logical processes attempt to retrieve and update the resource without a timely management system, such as a lock, a Race Condition will occur.\n\n\nAn example for when a Race Condition occurs is a resource that may return a certain value to a process for further editing, and then updated by a second\u00a0process, resulting in the original process' data no longer being valid. Once the original process edits and updates the incorrect value back into the resource, the second process' update has been overwritten and lost.",
        "impact": "At best, a Race Condition may\u00a0cause errors in accuracy, overidden values or unexpected behavior that may result in denial-of-service. At worst, it may allow attackers to retrieve data or bypass security processes by replaying a controllable Race Condition until it plays out in their favor.",
        "mitigation": "When sharing resources between concurrent processes across the application ensure that these resources are\u00a0either thread-safe, or implement a locking mechanism to ensure expected concurrent activity."
    },
    "open redirect": {
        "title": "Open Redirect",
        "desc": "The application redirects the user\u2019s browser to a URL provided by a tainted input, without first ensuring that URL leads to a trusted destination, and without warning users that they are being redirected outside of the current site. An attacker could use social engineering to get a victim to click a link to the application with a parameter defining another site to which the application will redirect the user\u2019s browser. Since the user may not be aware of the redirection, they may be under the misconception that the website they are currently browsing can be trusted.",
        "impact": "An attacker could use social engineering to get a victim to click a link to the application, so that the user will be immediately redirected to another site of the attacker's choice. An attacker can then craft a destination website to fool the victim; for example - they may craft a phishing website with an identical looking UI as the previous website's login page, and with a similar looking URL, convincing the user to submit their access credentials in the attacker's website. Another example would be a phishing website with an identical UI as that of a popular payment service, convincing the user to submit their payment information.",
        "mitigation": "1. Ideally, do not allow arbitrary URLs for redirection. Instead, create a mapping from user-provided parameter values to legitimate URLs.\n2. If it is necessary to allow arbitrary URLs:\n\t* For URLs inside the application site, first filter and encode the user-provided parameter, and then either:\n\t\t+ Create a white-list of allowed URLs inside the application\n\t\t+ Use variables as a relative URL as an absolute one, by prefixing it with the application site domain - this will ensure all redirection will occur inside the domain\n\t* For URLs outside the application (if necessary), either:\n\t\t+ White-list redirection to allowed external domains by first filtering URLs with trusted prefixes. Prefixes must be tested up to the third slash [/] - `scheme://my.trusted.domain.com/,` to prevent evasion. For example, if the third slash [/] is not validated and scheme://my.trusted.domain.com is trusted, the URL scheme://my.trusted.domain.com.evildomain.com would be valid under this filter, but the domain actually being browsed is evildomain.com, not domain.com.\n\t\t+ For fully dynamic open redirection, use an intermediate disclaimer page to provide users with a clear warning that they are leaving the site."
    },
    "information exposure through an error message": {
        "title": "Information Exposure Through an Error Message",
        "desc": "The application handles exceptions in an insecure manner, including raw details directly in the error message. This could occur in various ways: by not handling the exception; printing it directly to the output or file; explicitly returning the exception object; or by configuration. These exception details may include sensitive information that could leak to the users due to the occurrence of the runtime error.",
        "impact": "Exposed details about the application\u2019s environment, users, or associated data (for example, stack trace) could enable an attacker to find another flaw and help the attacker to mount an attack. This may also leak sensitive data, e.g. passwords or database fields.",
        "mitigation": "* Do not expose exception data directly to the output or users, instead return an informative, generic error message. Log the exception details to a dedicated log mechanism.\n* Any method that could throw an exception should be wrapped in an exception handling block that:\n\t+ Explicitly handles expected exceptions.\n\t+ Includes a default solution to explicitly handle unexpected exceptions.\n* Configure a global handler to prevent unhandled errors from leaving the application."
    },
    "xss evasion attack": {
        "title": "XSS Evasion Attack",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nBy decoding data during this flow, an attacker may provide previously encoded data which would bypass defense mechanisms which filter out malicious characters (web-application firewalls, regular expressions and other server-side validation); this data would then be decoded after the checks verify data validity, evading defenses, and result in a Cross-Site Scripting (XSS) attack.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* If decoding of data is required prior to usage to avoid scenarios where double encoding occurs - ensure data is re-encoded. Always ensure that between the any decoded data and any output is at least one form of robust sanitization, which would prevent dangerous characters from evading sanitization by hiding in encoded data.\n* In .NET, when using Razor, consider that Razor is effective at sanitizing some HTML meta-characters, such as <, >, ', \", but ignores characters that may use to evade sanitization in Javascript contexts and result in XSS, such as \\, ` and line breaks. Consider Razor as a safe sanitizer only when outputting dynamic data in an HTML context."
    },
    "buffer overflow": {
        "title": "Buffer Overflow",
        "desc": "Buffer Overflows can manifest in numerous different variations. In it's most basic form, the attack controls a buffer, which is then copied to a smaller buffer without size verification. Because the attacker's source buffer is larger than the program's target buffer, the attacker's data overwrites whatever is next on the stack, allowing the attacker to control program structures.\n\n\nAlternatively, the vulnerability could be the result of improper bounds checking; exposing internal memory addresses outside of their valid scope; allowing the attacker to control the size of the target buffer; or various other forms.",
        "impact": "Buffer overflow attacks, in their various forms, could allow an attacker to control certain areas of memory. Typically, this is used to overwrite data on the stack necessary for the program to function properly, such as code and memory\u00a0addresses, though other forms of this attack exist. Exploiting this vulnerability can generally lead to system crashes, infinite loops, or even execution of arbitrary code.",
        "mitigation": "* Always perform proper bounds checking before copying buffers or strings.\n* Prefer to use safer functions and structures, e.g. safe string classes over `char*`, `strncpy` over `strcpy`, and so on.\n* Consistently apply tests for the size of buffers.\n* Do not return variable\u00a0addresses outside the scope of their variables."
    },
    "cgi xss": {
        "title": "CGI XSS",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use legitimate access to the application to submit modified data, which would be returned as output without proper sanitization. This would then be used to dynamically generate output to a generic output writer - in some scenarios, such as with CGI scripts, this output is sent directly to the user's browser, which would trigger the attack.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie."
    },
    "cross site history manipulation": {
        "title": "Cross Site History Manipulation",
        "desc": "Modern browsers expose the user's browsing history to local JavaScript as a stack of previously visited URLs. While the browsers enforce a strict Same Origin Policy (SOP) to prevent pages from one website from reading visited URLs on other websites, the History object does leak the size of the history stack. Using only this information, in some situations the attacker can discover the results of certain checks the application server performs.\n\n\nFor example - if the application redirects an unauthenticated user to the login page, a script on another website can detect whether or not the\u00a0user is logged in, by checking the length of the history object.\u00a0This is done by first making a request to the page being redirected to (e.g. \"/login\"), then replacing that with a redirecting page that only redirects users if that user is not yet authenticated (e.g. \"/profile\") - if the length of history object remains the same, redirection has occurred back to the page being redirected to, and the history stack is not updated. If the history stack length is updated, that means the page did not redirect the user, causing the new page to be stored in the history stack.\n\n\nThis information leakage is enabled when the application redirects the user's browser based on the value of some condition, the state of the user's server-side session. e.g. whether the user is authenticated to the application, if the user has visited a certain page with specific parameters, or the value of some application data.\n\n\nNote that this issue does not affect all browsers, and depends on the browser's implementation of Javascript's history object behavior.",
        "impact": "An attacker could compromise the browser's Same Origin Policy and violate a user's privacy, by manipulating the browser's History object in JavaScript. This could allow the attacker in certain situations to detect whether the user is logged in, track the user's activity, or infer the\u00a0state of other conditional values. This may also enhance Cross Site Request Forgery (XSRF) attacks, by leaking the result of the initial attack.",
        "mitigation": "* Add the response header \"X-Frame-Options: DENY\" to all sensitive pages in the application, to protect against the IFrame version of XSHM in modern browser versions.\n* Add a random value to all redirection URLs as a parameter to ensure that they are unique when inserted into the history stack"
    },
    "data filter injection": {
        "title": "Data Filter Injection",
        "desc": "",
        "impact": "An attacker could directly access all of the system's data. Using simple tools and text editing, the attacker would be able to steal any sensitive information stored in the server cache (such as personal user details or credit cards), and possibly change or erase existing data that could be subsequently used for other users or relied upon for security decisions. The application stores temporary data in its cache, and queries this data. The application creates the query by simply concatenating strings including the user's input. Since the user input is neither checked for data type validity nor subsequently sanitized, the input could contain commands that would be interpreted as such.",
        "mitigation": "1. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Instead of concatenating strings:\n\t* Use secure database components such as stored procedures, parameterized queries, and object bindings (for commands and parameters).\n\t* An even better solution is to use an ORM library, such as EntityFramework, Hibernate, or iBatis.\n3. Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n4. If possible, avoid making security decisions based on cached data, especially data shared between users."
    },
    "unsafe object binding": {
        "title": "Unsafe Object Binding",
        "desc": "Using object binding methods, built into MVC controllers, exposes all public setters to allow easily wiring values submitted by users in forms, to the objects and attributes they are intended to create or alter. This approach allows application code to skip the boilerplate code of having to parse requests for user values, and manually setting them individually into objects being created.\n\n\nHowever, this may also pose a significant risk to application logic and flow - naively mass binding objects in such a manner may also accidentally expose unintended objects or attributes, which could then be tampered with by an attacker.",
        "impact": "Unsafe binding of objects to requests may expose unintended setters to remote attackers, allowing them to directly access objects, attributes and even objects within objects via broadly binding setters to an incoming request.",
        "mitigation": "* Review all mass-assigned objects to ensure no unintended public setters or constructors are unintentionally exposed by this approach.\n* Ensure that, where required, access to attributes and objects is correctly restricted by application code.\n* Consider transitioning away from object binding methods to a more granular approach where values are only ever explicitly set, to prevent accidentally exposing unintended values to being implicitly altered."
    },
    "db parameter tampering": {
        "title": "DB Parameter Tampering",
        "desc": "The application accesses\u00a0user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application uses the user input to filter specific records from database tables, which contain sensitive personal information (e.g. user accounts or payment details). Since the application does not filter the records according to any user identifier, nor\u00a0constrain it to a pre-computed list of acceptable values, a malicious user can easily modify the submitted reference identifier, and thus access unauthorized records.",
        "impact": "A malicious user could access other users\u2019 personal information, by simply altering the reference parameter sent to the server. Thus, the malicious user could bypass access controls and access unauthorized records, such as other users accounts,\u00a0stealing confidential or restricted information.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Filter the database query according to\u00a0a user-specific identifier, such as the customer number.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "dos by sleep": {
        "title": "DoS by Sleep",
        "desc": "The application uses a user-provided value to set its sleep period, without enforcing a limited range for this value.",
        "impact": "An attacker could provide a very high sleep value, effectively causing a denial of service for a long period of time.",
        "mitigation": "1. Ideally, the sleep command\u2019s duration should not be be according to user input at all. It should be either hardcoded, defined in a configuration file, or dynamically calculated at runtime.\n2. If it is necessary to allow the user to define the sleep duration, this value MUST be checked and enforced to be within a predefined range of valid values."
    },
    "path traversal": {
        "title": "Path Traversal",
        "desc": "The application uses user input in the file path for accessing files on the application server\u2019s local disk.",
        "impact": "An attacker could define arbitrary file path for the application to use, potentially leading to:\n\n* Stealing sensitive files, such as configuration or system files\n* Overwriting files such as program binaries, configuration files, or system files\n* Deleting critical files, causing denial of service (DoS).",
        "mitigation": "1. Ideally, avoid depending on dynamic data for file selection.\n2. Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n3. Accept dynamic data only for the filename, not for the path and folders.\n4. Ensure that file path is fully canonicalized.\n5. Explicitly limit the application to use a designated folder that is separate from the applications binary folder.\n6. Restrict the privileges of the application\u2019s OS user to necessary files and folders. The application should not be able to write to the application binary folder, and should not read anything outside of the application folder and data folder."
    },
    "use of hard coded cryptographic key": {
        "title": "Use of Hard coded Cryptographic Key",
        "desc": "The application code uses an encryption key to encrypt and decrypt sensitive data. While it is important to create this encryption key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code.\u00a0\n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text encryption key and use it to decrypt the sensitive data that the application was protecting.",
        "impact": "Static, unchangeable encryption keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the encryption key, this can be used to gain access to any encrypted secret data, thus violating the confidentiality of the data. Furthermore, it would be impossible to replace the encryption key once stolen. Note that if this is\u00a0a product that can be installed numerous times, the encryption key will always be the same, allowing an attacker to break all instances at the same cost.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as encryption keys, in plain text.\n* Never\u00a0hardcode encryption keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove the hardcoded encryption key from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "hardcoded password in connection string": {
        "title": "Hardcoded password in Connection String",
        "desc": "The application has the database password hardcoded in the source code files, and uses this password in a connection string to the database or other server. This password is visible to anyone with access to source code, and cannot be changed without rebuilding or recompiling the application. Even after compilation or deployment, the password and connection string are still present in the binary program files or production environment.",
        "impact": "Hardcoded database passwords expose the application to password leakage, and the database to unauthorized access. If an attacker gains access to the source code (or can decompile the application binaries), the attacker will be able to steal the embedded passwords, and use them to directly access the database. This would enable the attacker to steal secret information, modify sensitive records, or delete important data.\u00a0\n\n\nIn addition, the password cannot be easily changed when required. In the eventual situation wherein it is a necessity to update the password, a new version of the application would need to be built and deployed to production systems.",
        "mitigation": "- Never hardcode sensitive data, such as database passwords.\u00a0\n\u00a0- Prefer to avoid requiring an explicit database password at all, instead using OS-integrated system authentication.\n\u00a0- Alternatively, store the password in an encrypted configuration file, and implement a mechanism enabling administrators to change the password. Ensure the file permissions are configured to restrict access to administrators only.\n\u00a0- In particular, if the database supports Integrated Windows Authentication, prefer to use a Windows user over SQL user.\u00a0\n\u00a0- Configure the connection string with \"`Trusted_Connection=True;`\", or \"`Integrated Security=SSPI;`\" (or \"`true`\").\n\u00a0- Alternatively, define the application's connection string in the `web.config` configuration file. Typically, this should be in the `connectionString` attribute of an `<add>` element, under the `<connectionStrings>` element.\u00a0\n\u00a0- Encrypt the configured connection strings using: `aspnet_regiis -pe \"connectionStrings\" -app \"/YourApplication\"`"
    },
    "http response splitting": {
        "title": "HTTP Response Splitting",
        "desc": "Since user input is being used in an HTTP response header, an attacker could include NewLine characters to make the header look like multiple headers with engineered content, potentially making the response look like multiple responses (for example, by engineering duplicate content-length headers). This can cause an organizational proxy server to provide the second, engineered response to a victim\u2019s subsequent request; or, if the proxy server also performs response caching, the attacker can send an immediate subsequent request to another site, causing the proxy server to cache the engineered response as a response from this second site and to later serve the response to other users.\n\n\nMany modern web frameworks mitigate this issue, by offering sanitization for new line characters in strings inserted into headers by default. However, since many older versions of web frameworks fail to automatically mitigate this issue, manual sanitization of input may be required.",
        "impact": "If the header setting code is of a vulnerable version, an attacker could:\n\n* Arbitrarily change the application server\u2019s response header to a victim\u2019s HTTP request by manipulating headers\n* Arbitrarily change the application server\u2019s response body by injecting two consecutive line breaks, which may result in Cross-Site Scripting (XSS) attacks\n* Cause cache poisoning, potentially controlling any site\u2019s HTTP responses going through the same proxy as this application.",
        "mitigation": "1. Validate all input, regardless of source (including cookies). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Additionally, remove or URL-encode all special (non-alphanumeric) user input before including it in the response header.\n3. Make sure to use an up-to-date framework."
    },
    "integer overflow": {
        "title": "Integer Overflow",
        "desc": "All numeric data-types have a bit-wise representation. If, after an arithmetic operation, a value exceeds its bit-wise representation's amount of bits, then the most significant numbers that are being added will simply be truncated, with the value that remains after this truncation being the leftover from the wraparound action - this is known as an \"Arithmetic Overflow\", or its common misnomer - \"Integer Overflow\", which is misleading, since this applies to many other types. If data-types that can overflow drop below their minimum value, they will wraparound negatively in what is commonly referred to as an underflow.\n\n\nFor example, if an unsigned 32bit integer is set to\u00a04,294,967,295 and 1 is added, it will overflow and wraparound to 0. If it were a signed 32bit integer with the value\u00a02,147,483,647 and 1 is added, it will overflow and wraparound to -2,147,483,648.\n\n\nTo ensure code correctness, checks must be made that values are within expected bounds so that the result of arithmetic operations will not overflow or underflow.",
        "impact": "An arithmetic overflow will\u00a0lead to undefined behavior and unintentional effects, such as data corruption (e.g. value wraparound, wherein maximum values become minimum values); system crashes; infinite loops; logic errors, such as bypassing of security mechanisms; truncation or loss of data; or even buffer overflows leading to arbitrary code execution, when performing memory operations with an overflowed numeric value.",
        "mitigation": "* When performing arithmetic operations on data that may contain any value, consider adding a check to ensure that this data is within bounds where the product of those operations would not result in an overflow nor an underflow.\n* Consider creating wrappers for all arithmetic operations that would have specific handling for exceptional conditions; for example, by throwing an exception if checks show an overflow had or would have occurred."
    },
    "deserialization of untrusted data": {
        "title": "Deserialization of Untrusted Data",
        "desc": "Object serialization and deserialization is integral to the process of remoting, wherein objects are passed between code instances over an intermediary medium, such as over a network. During deserialization, a new object is constructed from a serialized object provided over the medium; however, if the object being deserialized is untrusted, an unexpected and potentially dangerous object can be provided.",
        "impact": "Deserialization of untrusted data may allow attackers to craft and provide a malicious object to the deserializing code. If a dangerous object is unsecurely deserialized, it may result in execution of code or operating system commands, by invoking classes or methods potentially available to the object during the deserialization process.\n\n\nAdditionally, deserialization may bypass logical object validation. Since deserialization often uses its own means of constructing a new object from the serialized data, it may bypass checks enforced in constructors or setters, which would allow attackers to deserialize an object whose properties are not validated, incorrect or outright malicious. This may lead to unexpected behavior, affecting logic in ways that are entirely dependent on implementation.",
        "mitigation": "* Where possible, do not pass serialized object between remote instances. Instead, consider passing value primitives between instances and use these values to populate a newly constructed object.\n* If required, use a whitelist approach to passed objects. Always ensure the passed object is known, trusted and expected. Do not dynamically construct an object from any source unless the object has been verified and is of a trusted, known type, and may not contain untrusted objects within it.\n* When choosing a serializer - always consult vendor documentation, best practices and even known exploitation techniques to ensure that the serializer chosen and deployed is defensible, securely configured, and does not allow any potentially dangerous objects."
    },
    "improper locking": {
        "title": "Improper Locking",
        "desc": "In order to improve performance and raise throughput, the application has several threads performing operations in parallel. In certain situations, sensitive methods need to ensure that other threads are not interferring with the integrity of their operations or data. To do so, these methods need to acquire a lock (commonly known as mutex, monitor, or other types) to synchronize access between threads.\n\n\nHowever, in this case, the synchronization lock is never unlocked, and can cause the other threads to continuously await its release indefinitely.",
        "impact": "Incomplete management of explicit thread locking can lead to deadlocked threads, wherein one thread (or several) is blocked while waiting for the other thread to release it's lock - which will\u00a0never happen, causing the other threads to be disabled indefinitely. This could also cause the application to\u00a0consume other resources indefinitely, without releasing them. At the very least, this flaw will severly limit throughput of the application, by blocking the multithreaded operations.",
        "mitigation": "* Always ensure any synchronization locks are explicitly released.\n* In particular, use strucutured error handling to ensure that the locks are released even after runtime exceptions.\n* Avoid manual locking, if\u00a0possible, instead using\u00a0automatic\u00a0locking via\u00a0synchronized blocks and methods where available."
    },
    "parameter tampering": {
        "title": "Parameter Tampering",
        "desc": "The application provides user information without filtering by user ID. For example, it may provide information solely by a submitted account ID. The application concatenates the user input directly into the SQL query string, without any additional filtering. The application also does not perform any validation on the input, nor constrain it to a pre-computed list of acceptable values.",
        "impact": "A malicious user could access other users\u2019 information. By requesting information directly, such as by an account number, authorization may be bypassed and the attacker could steal confidential or restricted information (for example, a bank account balance), using a direct object reference.",
        "mitigation": "Generic Guidance:\u00a0\n\n* Enforce authorization checks before providing any access to sensitive data, including the specific object reference.\n* Explicitly block access to any unauthorized data, especially to other users\u2019 data.\n* If possible, avoid allowing the user to request arbitrary data by simply sending a record ID. For example, instead of having the user send an account ID, the application should look up the account ID for the current authenticated user session.\n\n\nSpecific Mitigation:\n\n* Do not concatenate user input directly into SQL queries.\n* Include a user-specific identifier as a filter in the WHERE clause of the SQL query.\n* Map the user input to an indirect reference, e.g. via a prepared list of allowable values."
    },
    "privacy violation": {
        "title": "Privacy Violation",
        "desc": "The application sends user information, such as passwords, account information, or credit card numbers, outside the application, such as writing it to a local text or log file or sending it to an external web service.",
        "impact": "A user\u2019s personal information could be stolen by a malicious programmer, or an attacker that intercepts the data.",
        "mitigation": "1. Personal data should be removed before writing to logs or other files.\n2. Review the need and justification of sending personal data to remote web services."
    },
    "redos by regex injection": {
        "title": "ReDoS By Regex Injection",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "redos in code": {
        "title": "ReDoS In Code",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "redos in validation": {
        "title": "ReDoS In Validation",
        "desc": "ReDoS (regular expression denial of service) is an algorithmic complexity attack, that exploits exponential time worst case complexity. In particular, certain regex patterns - either explicitly coded in the application, or accepted from user input and used for searching\u00a0text\u00a0- can cause extreme levels of processing for some input texts. For example, ``(a+)+`` would hang on an input of a long string of \"aaaaaaaaaaaaaaaaaaaaaaaa!\"",
        "impact": "ReDoS (regular expression denial of service) can use complex patterns to cause a denial of service (DoS). With certain patterns, processing time can grow exponentially in relation to input size. An attacker can use these regular expressions\u00a0to\u00a0cause the application\u00a0to spend a significant amount of computation time processing a regular expression over a data-set, causing the application to hang.",
        "mitigation": "* Do not use input for constructing a regular expression.\n* Ensure all hardcoded regexes are not vulnerable to ReDoS, specifically ensuring worst case complexity does not cause the application to hang.\n* Strive to avoid unnecessarily complex expressions; craft regular expressions that are as simple as possible."
    },
    "reflected xss specific clients": {
        "title": "Reflected XSS Specific Clients",
        "desc": "The application creates web pages that include untrusted data, whether from user input, the application\u2019s database, or from other external sources. The untrusted data is embedded directly in the page's HTML, causing the browser to display it as part of the web page. If the input includes HTML fragments or JavaScript, these are displayed too, and the user cannot tell that this is not the intended page. The vulnerability is the result of directly embedding arbitrary data without first encoding it in a format that would prevent the browser from treating it like HTML or code instead of plain text.\n\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.",
        "impact": "A successful XSS exploit would allow an attacker to rewrite web pages and insert malicious scripts which would alter the intended output. This could include HTML fragments, CSS styling rules, arbitrary JavaScript, or references to third party code. An attacker could use this to steal users' passwords, collect personal data such as credit card details, provide false information, or run malware. From the victim\u2019s point of view, this is performed by the genuine website, and the victim would blame the site for incurred damage.\n\n\nThe attacker could use social engineering to cause the user to send the website modified input, which will be returned in the requested web page.",
        "mitigation": "* Fully encode all dynamic data, regardless of source, before embedding it in output.\n* Encoding should be context-sensitive. For example:\n\t+ HTML encoding for HTML content\n\t+ HTML Attribute encoding for data output to attribute values\n\t+ JavaScript encoding for server-generated JavaScript\n* It is recommended to use the platform-provided encoding functionality, or known security libraries for encoding output.\n* Implement a Content Security Policy (CSP) with explicit whitelists for the application's resources only.\n* As an extra layer of protection, validate all untrusted data, regardless of source (note this is not a replacement for encoding). Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* In the `Content-Type` HTTP response header, explicitly define character encoding (charset) for the entire page.\n* Set the `HTTPOnly` flag on the session cookie for \"Defense in Depth\", to prevent any successful XSS exploits from stealing the cookie.\n* In .NET, when using Razor, consider that Razor is effective at sanitizing some HTML meta-characters, such as `<`, `>`, `'`, `\"`, but ignores characters that may use to evade sanitization in Javascript contexts and result in XSS, such as `\\`, ` and line breaks. Consider Razor as a safe sanitizer only when outputting dynamic data in an HTML context."
    },
    "sql injection evasion attack": {
        "title": "SQL Injection Evasion Attack",
        "desc": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\n\nIn particular, the application decodes the user input (typically from HTML encoding format), before embedding it in the database query. Since the application decodes the input before using it, an attacker could obscure the malicious payload by encoding it before sending to the server, thus concealing the attack from most protection mechanisms. \u00a0\n\n\nThus, the input could contain SQL commands that would be interpreted as such by the database, without being detected or blocked by most countermeasures.",
        "impact": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database.\u00a0\n\n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail.\u00a0\n\n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.",
        "mitigation": "* Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns.\n* In particular, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values.\n* Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n* Do not use dynamically concatenate strings to construct SQL queries.\n* Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries.\n* Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters).\n* Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n* In particular, all data validation should be performed after canonicalization, i.e. after the data has been decoded and simplified.\n* Prefer using database-specific\u00a0`DbCommand`\u00a0subclasses with\u00a0`DbParameter`\u00a0objects and API. Set the command's\u00a0`CommandType`\u00a0property to\u00a0`CommandType.StoredProcedure`\u00a0, and add the parameters to the\u00a0`.Parameters`\u00a0collection property instead of string concatenation.\n* Consider using an ORM library, such as Entity Framework, LINQ-To-SQL, nHibernate, or others."
    },
    "trust boundary violation": {
        "title": "Trust Boundary Violation",
        "desc": "Server-side Session variables, or objects, are values assigned to a specific session, which is associated with a specific user. Often, they hold data relevant to that user's session, such as specific identifiers, user-type, authorization, authentication information and more. As such, the paradigm often associated to the Session object is that its contents can be trusted, as users cannot generally set these values themselves.\u00a0\n\n\nThe application places user input, which is untrusted data, in the server-side Session object, which is considered a trusted location. This could lead developers to treat untrusted data as trusted.",
        "impact": "Code that reads from Session variables may trust them as server-side variables, but they may have been tainted by user inputs. This can lead to tampering with parameters used to authenticate or authorize users. Further, tainted Session variables offer an additional attack surface against the application - if untrusted data taints a Session variable, and that Session variable\u00a0 is then used elsewhere without sanitization as if it were trusted, it could lead to further attacks such as Cross-Site Scripting, SQL Injection and more.",
        "mitigation": "1. Validate and sanitize all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Check for:\n\t* Data type\n\t* Size\n\t* Range\n\t* Format\n\t* Expected values\n2. Don\u2019t mix untrusted user input with trusted data."
    },
    "unclosed connection": {
        "title": "Unclosed Connection",
        "desc": "The application opens many database connections. Since these are not a managed resource, the application is responsible for properly closing the connection and releasing the resource. The proper way of ensuring the connection will be released, no matter what and even in the case of errors, is to explicitly close the connection in a `finally { }` block, however the application does not do so.\u00a0\n\n\nThus,\u00a0even after the connection object goes out of scope of the current method, the underlying unmanaged resource will still not be released, despite the garbage collector.",
        "impact": "The application opens new connections to the database\u00a0in order to serve each request. However, the application does not properly ensure these database\u00a0connections are always explicitly closed and released. Since the database server typically has a relatively low limit on open connections, which are being held open by the application,\u00a0it would be relatively simple for an attacker to cause a Denial of Service (DoS) attack.\n\n\nThe attacker could simply send many requests to the server, each in a new session, causing the application to re-open many connections to the database, which are left open. This may\u00a0eventually cause the database to refuse to open additional connections for the application, thus blocking the application.",
        "mitigation": "Generic Guidance:\n\n* Always ensure the application properly cleans up any unmanaged or physical resources, such as open files or dastabase connections.\n* Prefer to implement the proper Dispose() pattern\n* Ensure all cleanup processes will always be run, even in the case of errors.\n* Be extra careful to avoid exceptions during the method cleanup and exception handling.\n* Prefer implementing the using () statement\u00a0pattern, which automatically disposes\u00a0its own resources.\n\n\nSpecific Recommendations:\n\n* Explicitly close all open database connections.\n* Perform connection cleanup in the `finally { }` block of the same `try { }` that opened the connection."
    },
    "xsrf": {
        "title": "XSRF",
        "desc": "The application performs some action that modifies database contents, based purely on HTTP request content, and does not require per-request renewed authentication (such as transaction authentication or a synchronizer token), instead relying solely on session authentication. This means that an attacker could use social engineering to cause a victim to browse to a link which contains a transaction request to the vulnerable application, submitting that request from the user's browser. Once the application receives the request, it would trust the victim\u2019s session, and would perform the action. This type of attack is known as Cross-Site Request Forgery (XSRF or CSRF).\n\n\nA Cross-Site Request Forgery attack relies on the trust between a server and an authenticated client. By only validating the session, the server ensures that a request has emerged from a client's web-browser. However, any website may submit GET and POST requests to other websites, to which the browser will automatically add the session token if it is in a cookie. This cross-site request can then be trusted as arriving from the user's browser, but does not validate that it was their intent was to make this request.",
        "impact": "An attacker could cause the victim to perform any action for which the victim is authorized, such as transferring funds from the victim\u2019s account to the attacker\u2019s. The action will be logged as being performed by the victim, in the context of their account, and potentially without their knowledge that this action has occurred.",
        "mitigation": "Mitigating XSRF requires an additional layer of authentication that is built into the request validation mechanism. This mechanism would attach an additional token that only applies to the given user; this token would be available within the user's web-page, but will not be attached automatically to a request from a different website (e.g. not stored in a cookie). Since the token is not automatically attached to the request, and is not available to the attacker, and is required by the server to process the request, it would be completely impossible for the attacker to fill in a valid cross-site form that contains this token.\n\n\nMany platforms offer built-in XSRF mitigation functionality which should be used, and perform this type of token management under the hood. Alternatively, use a known or trusted library which adds this functionality.\n\n\nIf implementing XSRF protection is required, this protection should adhere to the following rules:\n\n* Any state altering form (Create, Update, Delete operations) should enforce XSRF protection, by adding an XSRF token to every state altering form submission on the client.\n* An XSRF token should be generated, and be unique per-user per-session (and, preferably, per request).\n* The XSRF token should be inserted into the client side form, and be submitted to the server as part of the form request. For example, it could be a hidden field in an HTML form, or a custom header added by a Javascript request.\n* The XSRF token in the request body or custom header must then be verified as belonging to the current user by the server, before a request is authorized and processed as valid."
    },
    "cookieless authentication": {
        "title": "CookieLess Authentication",
        "desc": "With the user's session identifier, or authentication token, being sent in all application URLs, there are several ways this secret identifier can leak:\u00a0\n\n* Server and proxy logs\n* Referer HTTP header (especially to external systems)\n* User sharing of internal URLs\n* User screenshots\n\n\nIn any of these scenarios, and others, the user and browser are not treating the URL as secret, and thus could accidentally\u00a0expose the secret sessionid publicly. An attacker could easily reuse this sessionid to hijack the user's session.\u00a0\n\n\nAdditionally, an attacker can provide a user with a link to the attacker's pre-established session, causing the victim to login the attacker's session with the victim's credentials, essentially providing the attacker with the user's account. This is known as \"Session Fixation\".",
        "impact": "When an application enables cookieless authentication or sessions, the user identifiers (session id and authentication token) are sent embedded in all application URLs. This increases the risk of leaking the identifier to other unauthorized entities, such as other users or external systems, which would enable session hijacking attacks.\u00a0\n\n\nLikewise, URL-based identifiers can also enable injection attacks, such as session fixation attacks, allowing an attacker to pre-select the victim's sessionid.\u00a0\n\n\nIn either of these types of attacks, an\u00a0attacker can essentially take over a legitimate user's account, by reusing their active session. Once the attacker has access to the victim's session, she can do anything the user can, as the user.",
        "mitigation": "* Do not enable cookieless authentication or cookieless sessions.\n* Explicitly require the application to enforce cookie-based authentication and sessions only, using the \"`UseCookies`\" value to the `cookieless` attribute."
    },
    "cookieless session state": {
        "title": "CookieLess Session State",
        "desc": "With the user's session identifier, or authentication token, being sent in all application URLs, there are several ways this secret identifier can leak:\u00a0\n\n* Server and proxy logs\n* Referer HTTP header (especially to external systems)\n* User sharing of internal URLs\n* User screenshots\n\n\nIn any of these scenarios, and others, the user and browser are not treating the URL as secret, and thus could accidentally\u00a0expose the secret sessionid publicly. An attacker could easily reuse this sessionid to hijack the user's session.\u00a0\n\n\nAdditionally, an attacker can provide a user with a link to the attacker's pre-established session, causing the victim to login the attacker's session with the victim's credentials, essentially providing the attacker with the user's account. This is known as \"Session Fixation\".",
        "impact": "When an application enables cookieless authentication or sessions, the user identifiers (session id and authentication token) are sent embedded in all application URLs. This increases the risk of leaking the identifier to other unauthorized entities, such as other users or external systems, which would enable session hijacking attacks.\u00a0\n\n\nLikewise, URL-based identifiers can also enable injection attacks, such as session fixation attacks, allowing an attacker to pre-select the victim's sessionid.\u00a0\n\n\nIn either of these types of attacks, an\u00a0attacker can essentially take over a legitimate user's account, by reusing their active session. Once the attacker has access to the victim's session, she can do anything the user can, as the user.",
        "mitigation": "* Do not enable cookieless authentication or cookieless sessions.\n* Explicitly require the application to enforce cookie-based authentication and sessions only, using the \"`UseCookies`\" value to the `cookieless` attribute."
    },
    "debugenabled": {
        "title": "DebugEnabled",
        "desc": "During application development, it is common for programmers to implement specialized code, in order to ease debugging and testing. Often the programmer will even\u00a0enable the debug code to bypass security mechanisms, so as to focus the tests on the specific functionality and isolate it from the security architecture.\u00a0\n\n\nThis debug or test code is not removed from the codebase, and is then included in the software build and deployed to the production environment.",
        "impact": "Tests and debugging code are not intended to be deployed to the production environment, and can create unintended entry points, thus increasing the application's attack surface. Furthermore, this code is often not properly tested or maintained, and can retain historic vulnerabilities that were fixed in other parts of the codebase. Often, debug code will contain a functional \"back door\", by enabling the programmer to bypass operational security mechanisms, such as authentication or access controls.",
        "mitigation": "- Remove all debug code before deploying or building the application. Ensure the configuration settings are not defined to enable debug mode.\u00a0\n\u00a0- Implement all test code via a dedicated test framework, which can isolate the test case code from the rest of the application.\u00a0\n\u00a0- Avoid implementing special \"test code\", \"debugging-time\" functionality, or \"secret\" interfaces or parameters in the application code itself.\u00a0\n\u00a0- Define and implement a standard and automatic build / deployment process, using dedicated CI / CD tools, that can automatically configure the deployed application, exclude all temporary code, and include only intended application code."
    },
    "httponlycookies in config": {
        "title": "HttpOnlyCookies In Config",
        "desc": "The web application framework, by default, does not set the \"httpOnly\" flag for the application's sessionid cookie and other sensitive application cookies. Likewise, the application does not explicitly use the \"httpOnly\" cookie flag, thus allowing client scripts to access the cookies by default.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, are typically accessible by client-side scripts, such as JavaScript. Unless the web application explicitly prevents this using the \"httpOnly\" cookie flag, these cookies could be read and accessed by malicious client scripts, such as Cross-Site Scripting (XSS). This flag would mitigate the damage done in case XSS vulnerabilities are discovered, according to Defense in Depth.",
        "mitigation": "- Always set the \"httpOnly\" flag for any sensitive server-side cookie.\n\u00a0- It is highly recommended to implement HTTP Strict Transport Security (HSTS) in order to ensure that the cookie will be sent over a secured channel.\n\u00a0- Configure the application to always use \"httpOnly\" cookies in the site-wide configuration file.\n\u00a0- Set the `httpOnlyCookies` attribute on the `<httpCookies>` element, under `<system.web>` in your application's web.config, to `\"true\"`."
    },
    "requiressl": {
        "title": "RequireSSL",
        "desc": "The web application framework by default does not set the \"secure\" flag for the application's sessionID cookie, and other sensitive application cookies. Likewise, the application does not explicitly use the \"secure\" cookie flag, allowing them to be sent in plaintext over an insecure session.",
        "impact": "Cookies that contain the user's session identifier, and other sensitive application cookies, should be sent to the server over a secure network communication (HTTPS) in order to prevent attackers from sniffing the traffic and stealing those cookies. Unless the web application explicitly prevents this by using the \"secure\" cookie flag, these cookies will also be sent over insecure traffic, which can lead to session hijacking and impersonation.",
        "mitigation": "* Always set the \"secure\" flag for any sensitive server-side cookies.\n* If the application explicitly handles cookies directly in application code, set the \"secure\" flag for sensitive cookies set by the application.\n**Secure-Code Approach**\n* Configure the application to always use \"secure\" cookies, in the site-wide configuration file.\n* Enable the Secure flag or use the relevant Set-Secure API in the code."
    },
    "persistent connection string": {
        "title": "Persistent Connection String",
        "desc": "Setting Persist Security Info to TRUE allows security information, such username and password, to be obtained from a connection once it has been established.\u00a0\n\n\nSetting it to False will make sure that security information is discarded after it is used to create the connection, reducing its exposure.",
        "impact": "Allowing the server to retain credentials may allow an attacker to retrieve them, and connect to the back-end using permissions associated to these credentials.",
        "mitigation": "* Either explicitly set Persist Security Info to False, or leave it on its default value.\n* If Persist Security Info is required to be True (e.g. for development purposes), it is vital to remove this flag or set it to False after it is no longer required."
    },
    "elmah enabled": {
        "title": "Elmah Enabled",
        "desc": "ELMAH (Error Logging Modules and Handlers) is a service that logs errors and user behavior in the application. It is intended for internal logging testing use only; failure to remove or restrict remote access to ELMAH in a production environment would expose live request information.\n\n\nInformation retained by ELMAH information includes request headers, request contents and server information. When configured to be exposed, browsing to elmah.axd in application context will allow unauthenticated attackers to retrieve this information.",
        "impact": "Information contained in ELMAH pages is very likely to include request headers, including session cookies, as well as parameters provided by users. Session cookies could enable attackers to hijack user sessions, thus performing actions on a user's behalf. Other parameters provided by users may contain sensitive, personal or financial information which would be trivially available to attackers.",
        "mitigation": "* Disable any and all web-accessible logging facilities when deploying an application to a production environment.\n* Always ensure access to such facilities, even during staging, is as limited as possible to avoid information leaks.\n* If having ELMAH in a production environment is required, either block remote access to ELMAH, or enforce strict authentication and authorization requirements to prevent anonymous or unprivileged access"
    },
    "insufficient connection string encryption": {
        "title": "Insufficient Connection String Encryption",
        "desc": "Encrypting the connection string will make sure that the connection string credentials are secured and will not be exposed to anyone within the packets.",
        "impact": "Using plain-text connection string within the network to connect to a database will expose the credentials.",
        "mitigation": "* Always encrypt the connection string, preferably with a certificate provisioned by a certificate authority.\n* If there is no provisioned certificate from a known certificate authority then a self-signed certificate is possible as well."
    },
    "unencrypted web config file": {
        "title": "Unencrypted Web Config File",
        "desc": "The application utilizes a web.config file, which is stored locally on the file-system, and does not encrypt all sensitive elements within it.",
        "impact": "In .NET applications, web.config files often contain sensitive information such as service account login credentials or connection strings; this potentially sensitive data must be stored in a secure, encrypted container to prevent attackers with local file-system access from retrieving it.",
        "mitigation": "Ensure sensitive contents of web.config\u00a0files are encrypted at rest. For a best practice approach, utilize .NET aspnet\\_regiis.exe's tool to encrypt sensitive elements within web.config, so that they are read by the web-server, but cannot be plainly read from the file."
    },
    "missing column encryption": {
        "title": "Missing Column Encryption",
        "desc": "Database columns are stored in clear text which means, it would be pretty easy to read the data if one has access to the DB server. Encrypting The columns prior storing the data will ensure that confidentiality will sustained and will not be at risk.",
        "impact": "Storing data in clear text may allow users with access to the server to extract sensitive information",
        "mitigation": "If the DBMS in use support native column encryption, these facilities should be used, to protect the stored data."
    },
    "overly permissive cross origin resource sharing policy": {
        "title": "Overly Permissive Cross Origin Resource Sharing Policy",
        "desc": "Modern browsers, by default, disallow resource sharing between different domains from accessing one another's DOM contents, cookie jars and other resources, specifically to prevent malicious web-applications from attacking legitimate web-applications and their users as part of the Same-Origin Policy (SOP). For example - website A cannot retrieve contents of website B by default, as that is a breach of the SOP. The Cross-Origin Resource Sharing (CORS) policy, defined by specific headers, allows loosening this strict default behavior to enable cross-site communications. However, when used incorrectly, CORS may enable\u00a0unintended and potentially malicious behavior by allowing an overly broad trust of web-applications that may submit requests and retrieve responses from the web-application.\n\n\nThe Access-Control-Allow-Origin is incorrectly set to an unsafe value in code.",
        "impact": "A Cross-Origin Resource Sharing (CORS) header,\u00a0\"Access-Control-Allow-Origin\", that is overly permissive may allow scripts from other web-sites to access, and often manipulate, resources on the affected web-application. These resources may include page contents, tokens and more, allowing potential Cross-Site Request Forgery (CSRF) or Cross-Site Scripting (XSS) attacks, performing actions on a user's behalf such as changing their password, or allow breach of user privacy.",
        "mitigation": "Where not explicitly required, do not set any CORS headers. Where required, consider business needs for setting these headers, and opt for the most restrictive configuration possible, such as white-listing trusted, secure and allowed domains access, while\u00a0utilizing other CORS headers to strictly provide required and expected functionality."
    },
    "missing hsts header": {
        "title": "Missing HSTS Header",
        "desc": "Many users browse to websites by simply typing the domain name into the address bar, without the protocol prefix. The browser will automatically assume that the user's intended protocol is HTTP, instead of the\u00a0encrypted HTTPS protocol.\n\n\nWhen this initial request is made, an attacker can perform a Man-in-the-Middle attack and manipulate it to redirect users to a malicious web-site of the attacker's choosing. To protect the user from such an occurence, the HTTP Strict Transport Security (HSTS) header instructs the user's browser to disallow use of an unsecure HTTP connection to the the domain associated with the HSTS header.\n\n\nOnce\u00a0a browser that supports the HSTS feature has visited a web-site and the header was set, it will no longer allow\u00a0communicating with the domain over an HTTP connection.\n\n\nOnce an HSTS header was issued for a specific website, the browser is also instructed\u00a0to prevent users from manually overriding and accepting an untrusted SSL certificate for as long as the \"max-age\" value still applies. The recommended \"max-age\" value is for at least one year in seconds, or 31536000.",
        "impact": "Failure to set an HSTS header and provide it with a reasonable \"max-age\" value of at least one year may leave users vulnerable to Man-in-the-Middle attacks.",
        "mitigation": "* Before setting the HSTS header - consider the implications it may have:\n\t+ Forcing HTTPS will prevent any future use of HTTP, which could hinder some testing\n\t+ Disabling HSTS is not trivial, as once it is disabled on the site, it must also be disabled on the browser\n* Set the HSTS header either explicitly within application code, or using web-server configurations.\n* Ensure the \"max-age\" value for HSTS headers is set to 31536000 to ensure HSTS is strictly enforced for at least one year.\n* Include the \"includeSubDomains\" to maximize HSTS coverage, and ensure HSTS is enforced on all sub-domains under the current domain\n\t+ Note that this may prevent secure browser access to any sub-domains that utilize HTTP; however, use of HTTP is very severe and highly discouraged, even for websites that do not contain any sensitive information, as their contents can still be tampered via Man-in-the-Middle attacks to phish users under the HTTP domain.\n* Once HSTS has been enforced, submit the web-application's\u00a0address to an HSTS preload list - this will ensure that, even if a client is accessing the web-application for the first time (implying HSTS has not yet been set by the web-application), a browser that respects the HSTS preload list would still treat the web-application as if it had already issued an HSTS header. Note that this requires the server to have a trusted SSL certificate, and issue an HSTS header with a maxAge of 1 year (31536000)\n* Note that\u00a0this query is designed to return one result per application. This means that if more than one vulnerable response without an HSTS header is identified, only the first identified instance of this issue will be highlighted as a result. If a misconfigured instance of HSTS is identified (has a short lifespan, or is missing the \"includeSubDomains\" flag), that result will be flagged. Since HSTS is required to be enforced across the entire application to be considered a secure deployment of HSTS functionality, fixing this issue only where the query highlights this result is likely to produce subsequent results in other sections of the application; therefore, when adding this header via code, ensure it is uniformly deployed across the entire application. If this header is added via configuration, ensure that this configuration applies to the entire application.\n* Note that misconfigured HSTS headers that do not contain the recommended max-age value of at least one year or the \"includeSubDomains\" flag will still return a result for a missing HSTS header."
    },
    "deserialization of untrusted data msmq": {
        "title": "Deserialization of Untrusted Data MSMQ",
        "desc": "Object serialization and deserialization is integral to the process of remoting, wherein objects are passed between code instances over an intermediary medium, such as over a network. During deserialization, a new object is constructed from a serialized object provided over the medium; however, if the object being deserialized is untrusted, an unexpected and potentially dangerous object can be provided.\n\n\nWhen using MSMQ, Microsoft's Message Queuing infrastructure, processing a message with certain formatter such as the BinaryMessageFormatter without verifying the message type would result in seamless deserialization of an object sent in a message by the formatter.",
        "impact": "Deserialization of untrusted data may allow attackers to craft and provide a malicious object to the deserializing code. If a dangerous object is unsecurely deserialized, it may result in execution of code or operating system commands, by invoking classes or methods potentially available to the object during the deserialization process.\n\n\nAdditionally, deserialization may bypass logical object validation. Since deserialization often uses its own means of constructing a new object from the serialized data, it may bypass checks enforced in constructors or setters, which would allow attackers to deserialize an object whose properties are not validated, incorrect or outright malicious. This may lead to unexpected behavior, affecting logic in ways that are entirely dependent on implementation.",
        "mitigation": "* Where possible, do not pass serialized object between remote instances. Instead, consider passing value primitives between instances and use these values to populate a newly constructed object.\n* If required, use a whitelist approach to passed objects. Always ensure the passed object is known, trusted and expected. Do not dynamically construct an object from any source unless the object has been verified and is of a trusted, known type, and may not contain untrusted objects within it.\n* When choosing a serializer - always consult vendor documentation, best practices and even known exploitation techniques to ensure that the serializer chosen and deployed is defensible, securely configured, and does not allow any potentially dangerous objects."
    },
    "missing content security policy": {
        "title": "Missing Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are not explicitly defined, default browser behavior would allow\u00a0untrusted content.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to\u00a0a strict\u00a0Content Security Policy, it is promptly rejected by the browser. Failure to define a policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Explicitly set the Content-Security-Policy headers for all applicable policy types (frame, script, form, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header\u00a0managed by\u00a0web-server configurations, or within `<meta>` tags in the HTML `<head>` section."
    },
    "stored code injection": {
        "title": "Stored Code Injection",
        "desc": "The application performs some action by creating and running code that includes untrusted data, which might be under control of a malicious user. If the data contains malicious code, the executed code could contain system-level activities engineered by an attacker, as though the attacker were running code directly on the application server.",
        "impact": "An attacker could run arbitrary code on the application server host. Depending on the application\u2019s OS permissions,these could include:\n\n* Database access, such as reading or modifying sensitive data;\n* File actions (read / create / modify / delete);\n* Changing the website;\n* Open a network connection to the attacker\u2019s server;\n* Decrypt secret data using the application's encryption keys;\n* Start and stop system services;\n* Complete server takeover.",
        "mitigation": "* The application should not compile, execute, or evaluate any untrusted code from any external source, including user input, uploaded files, or a database.\n* If it is absolutely necessary to include external data in dynamic execution, it is permissible to pass the data as parameters to the code, but do not execute user data directly.\n* If it is necessary to pass untrusted data to dynamic execution, enforce very strict data validation. For example, accept only integers between certain values.\n* Validate all input, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. Parameters should be limited to an allowed character set, and non-validated input should be dropped. In addition to characters, check for:\n\t+ Data type\n\t+ Size\n\t+ Range\n\t+ Format\n\t+ Expected values\n* If possible, always prefer to whitelist known and trusted input instead of comparing to a blacklist.\n* Configure the application to run using a restricted user account that has no unnecessary privileges.\n* If possible, isolate all dynamic execution to use a separate, dedicated user account that has privileges only for the specific operations and files used by dynamic execution, according to the Principle of Least Privilege."
    },
    "permissive content security policy": {
        "title": "Permissive Content Security Policy",
        "desc": "The Content-Security-Policy header is used by modern browsers as an indicator for trusted sources of content, including media, images, scripts, frames and more. If these policies are\u00a0broadly defined, they are ineffective in blocking untrusted content.\n\n\nApplication code is used to set a Content-Security-Policy; however, it sets an overly permissive policy.",
        "impact": "The Content-Security-Policy header enforces that the source of content, such as the origin of a script, embedded (child) frame, embedding (parent) frame or image, are trusted and allowed by the current web-page; if, within the web-page, a content's source does not adhere to a strict Content Security Policy, it is promptly rejected by the browser. Failure to enforce strict content behavior by\u00a0policy may leave the application's users exposed to Cross-Site Scripting (XSS) attacks, Clickjacking attacks, content forgery and more.",
        "mitigation": "Set the Content-Security-Policy headers for all applicable policy types (frame, frame-ancestors, script, form-actions, script, media, img etc.) according to business requirements and deployment layout of external file hosting services. Specifically, do not use\u00a0a wildcard, '*', to specify these policies, as this would allow content from any external resource.\n\n\nThe Content-Security-Policy can be explicitly defined within web-application code, as a header managed by\u00a0web-server configurations, and within `<meta>` tags in HTML pages' `<head>` section."
    },
    "password in comment": {
        "title": "Password In Comment",
        "desc": "A well-developed application will have it's source code well commented. Often, programmers\u00a0will\u00a0leave deployment information in comments, or\u00a0retain debugging data that was used during development. These comments often contain secret data, such as passwords. These password comments are stored in the source code in perpetuity, and are not protected.",
        "impact": "It is often possible to\u00a0retrieve and view the application source code.\u00a0For web applications, it is even simpler to \"`View Source`\" in the user's browser. Thus, a malicious user can steal these passwords, and use them to impersonate whoever they belong to. It is not known if these are valid, current passwords, nor if they are user passwords or for backend systems, like a database.",
        "mitigation": "Do not store secrets, such as passwords, in source code comments."
    },
    "jwt no expiration time validation": {
        "title": "JWT No Expiration Time Validation",
        "desc": "Validation of the expiration claim (exp) is disabled for this JWT validator.",
        "impact": "If a valid JWT token with an expiration time claim ever leaks, it will be valid past its expiry time, as expiration time validation is disabled. This would allow an attacker to authenticate with an expired token.",
        "mitigation": "* Since there is no defined mechanism to revoke a JWT the only real defense is through Expiration Time.\n* Make sure to set an Expiration Time for the created JWTs.\n* Always validate the Expiration Time is still viable when validating JWTs."
    },
    "jwt lack of expiration time": {
        "title": "JWT Lack Of Expiration Time",
        "desc": "The application does not set an Expiration Time(exp) claim in the JWT.",
        "impact": "Using JWTs that do not have an Expiration Time(exp) claim poses a security risk. A leaked token will allow attackers to impersonate the affected user, as without an Expiration Time a compromised token will be valid for an unlimited period of time. Besides the user account takeover with a forever valid token, having unlimited time access to a protected system may potentially allow attackers to further exploit the system.",
        "mitigation": "* Since there is no defined mechanism to revoke a JWT the only real defense is through Expiration Time.\n* Make sure to set an Expiration Time for the created JWTs."
    },
    "jwt no signature verification": {
        "title": "JWT No Signature Verification",
        "desc": "During the JWT verification step, the application does not validate the JWT signature and only decodes/parses its claims.",
        "impact": "If during the authentication process the JWT signature is not validated, there is no way to guarantee the integrity of the data present in the JWT body making the authentication mechanism obsolete. A malicious user could then add his own content and potentially have access to other user accounts as other protected resources.",
        "mitigation": "* Make sure to use the appropriate method for JWT verification, which should contemplate signature verification.\n* Make sure that the verification method used properly checks the signature, the expiration time as all other relevant content for your application requirements."
    },
    "jwt sensitive information exposure": {
        "title": "JWT Sensitive Information Exposure",
        "desc": "The application stores data, which may contain PII (Personally Identifiable Information) or other sensitive data in the JWT body. JWTs do not provide any form of data confidentiality, all the data that is included in the token is public and an attacker can simply decode its content to retrieve all the included data.",
        "impact": "A malicious user that has access to any user's token, will be able to retrieve the stored information, such as user personal data (PII) and any other sensitive data from the JWT body. This would be detrimental to the user and harm their privacy and even lead to identity theft. Such violation could cause damage to reputation as financial loss for the affected companies.",
        "mitigation": "* JWTs are not suitable for storing sensitive data.\n* Remove any PII or secrets that are being included in the JWT body.\n* In case you need to encrypt data within JWTs use JWE(JSON Web Encryption)."
    },
    "jwt use of hardcoded secret": {
        "title": "JWT Use Of Hardcoded Secret",
        "desc": "The application code uses JWT with a secret key to sign the issued tokens. While it is important to create this key randomly and keep it secret, the application has a single, static key embedded in plain text in the source code. \n\n\nAn attacker could gain access to the source code - whether in the source control system, developer workstations, or the server filesystem or product binaries themselves. Once the attacker has gained access to the source code, it is trivial to retrieve the plain text key and use it to issue valid tokens for the system that the JWT was protecting.",
        "impact": "Static, unchangeable secret keys in the source code can be stolen by an attacker with access to the source code or the application binaries. Once the attacker has the secret, this can be used to create valid JWTs that will be accepted by the application. An attacker in such a position can forge JWTs with the content of his choice bypassing authentication and authorization mechanisms that are dependent on such a secret.",
        "mitigation": "Generic Guidance:\n\n* Do not store any sensitive information, such as secret keys, in plain text.\n* Never hardcode secret keys in the application source code.\n* Implement proper key management, including dynamically generating random keys, protecting keys, and replacing keys as necessary.\n\n\nSpecific Recommendations:\n\n* Remove hardcoded keys from the application source code. Instead, retrieve the key from an external, protected store."
    },
    "excessive data exposure": {
        "title": "Excessive Data Exposure",
        "desc": "The API returns an object with potentially sensitive data-fields, without excluding, filtering or nullifying said sensitive data - thus exposing it in an API response.",
        "impact": "APIs often respond with objects for a client to consume and, at times, these objects may contain more information than the client requires or intends to use. If the object returned to the client has this excess data, and that data is sensitive, it would be exposed to potentially malicious clients of the API.",
        "mitigation": "* When returning objects that hold data from an API, always consider the types and contexts of data being returned - such as whether or not it is required by the API's consumers, and whether or not it is sensitive\n* Opt to white-list allowed data to be in control of data flow and remove excess"
    },
    "jwt excessive expiration time": {
        "title": "JWT Excessive Expiration Time",
        "desc": "The application uses an excessive Expiration Time(exp) for the created JWTs.",
        "impact": "Using JWTs with an excessive Expiration Time(exp) claim poses a security risk. A leaked token will allow attackers to impersonate the affected user, with an excessive Expiration Time a compromised token will allow attackers to further explore the system and potentially conduct more attacks since his window for action, is bigger.",
        "mitigation": "* Keep in mind that long-lived tokens are generally a poor security practice.\n* Token expiration times are usually a tradeoff between the exposure period of a leaked token and the application usability.\n* There is no ideal expiration time as this is a context-dependent issue. We recommend not using tokens that are valid for longer than 24 hours or 86400 seconds.\n* Depending on your security requirements this value can be much shorter. Multiple organizations set this time period to 15 to 30 minutes."
    },
    "missing object level authorization": {
        "title": "Missing Object Level Authorization",
        "desc": "An object identifier is provided by an authenticated user's input to access said object without first checking this user is authorized to access this object.",
        "impact": "Missing object level authorization may allow authenticated users to provide direct identifiers to access or modify specific objects. Allowing authenticated but unauthorized users to directly access functionality over objects outside of their intended scope of control would constitute a vertical privilege escalation, while accessing objects associated with other users or roles constitutes a horizontal privilege escalation",
        "mitigation": "* Enforce strict authorization rules within any environment that requires authentication.\n* Even in cases where certain functionality should be accessible to all users - authorization should be explicitly enforced by access control rules to ensure it is strict, well-defined and universally enforced.\n* When using identifiers to access specific objects or records - always validate if a user is allowed to access this type of object with this functionality, and whether or not this object is within their scope of authority.\n* Where possible, rely on .NET annotations to manage authorization, roles and policies in an orderly manner to avoid situations where mixed methods of authorization cause critical object access authorization to be missed."
    },
    "missing function level authorization": {
        "title": "Missing Function Level Authorization",
        "desc": "The function requires authentication, but fails to enforce explicit authorization.",
        "impact": "Missing function level authorization may allow authenticated users to access a function without any authorization checks. If these authenticated users should not be authorized by design logic to access this functionality, they may perform vertical privilege escalation by directly accessing functionality they are not authorized to access.",
        "mitigation": "* Enforce strict authorization rules within any environment that requires authentication.\n* Even in cases where certain functionality should be accessible to all users - authorization should be explicitly enforced by access control rules to ensure it is strict, well-defined and universally enforced.\n* Where possible, rely on .NET annotations to manage authorization, roles and policies in an orderly manner to avoid situations where mixed methods of authorization cause critical functionality authorization to be missed."
    },
    "suspicious endpoints": {
        "title": "Suspicious Endpoints",
        "desc": "In some frameworks, such endpoints allows the user to monitor and interact with the framework application. On this case, the user should avoid use the keywords such as *debug*, *dev*, *test*, *old\\_** or *secret*",
        "impact": "The code contains words that suggest the presence of bugs, incomplete functionality, or weaknesses.",
        "mitigation": "In production is recommended to not use the above keywords."
    }
}